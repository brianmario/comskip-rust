#![allow(
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut,
    unused_parens,
    path_statements
)]
extern "C" {
    pub type __sFILEX;
    pub type dispatch_semaphore_s;
    fn close(_: libc::c_int) -> libc::c_int;
    fn getcwd(_: *mut libc::c_char, _: size_t) -> *mut libc::c_char;
    fn read(_: libc::c_int, _: *mut libc::c_void, _: size_t) -> ssize_t;
    fn write(__fd: libc::c_int, __buf: *const libc::c_void, __nbyte: size_t) -> ssize_t;
    fn usleep(_: useconds_t) -> libc::c_int;
    static mut _DefaultRuneLocale: _RuneLocale;
    fn __maskrune(_: __darwin_ct_rune_t, _: libc::c_ulong) -> libc::c_int;
    static mut __stdoutp: *mut FILE;
    static mut __stderrp: *mut FILE;
    fn fclose(_: *mut FILE) -> libc::c_int;
    fn feof(_: *mut FILE) -> libc::c_int;
    fn fflush(_: *mut FILE) -> libc::c_int;
    fn fgets(_: *mut libc::c_char, _: libc::c_int, _: *mut FILE) -> *mut libc::c_char;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(_: *mut FILE, _: libc::c_long, _: libc::c_int) -> libc::c_int;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn getc(_: *mut FILE) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn vsprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ::std::ffi::VaList)
        -> libc::c_int;
    fn fileno(_: *mut FILE) -> libc::c_int;
    fn fseeko(__stream: *mut FILE, __offset: off_t, __whence: libc::c_int) -> libc::c_int;
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;
    fn strncpy(_: *mut libc::c_char, _: *const libc::c_char, _: libc::c_ulong)
        -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn abs(_: libc::c_int) -> libc::c_int;
    fn atof(_: *const libc::c_char) -> libc::c_double;
    fn exit(_: libc::c_int) -> !;
    fn labs(_: libc::c_long) -> libc::c_long;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn strtol(_: *const libc::c_char, _: *mut *mut libc::c_char, _: libc::c_int) -> libc::c_long;
    fn ctime(_: *const time_t) -> *mut libc::c_char;
    fn localtime(_: *const time_t) -> *mut tm;
    fn time(_: *mut time_t) -> time_t;
    fn _strupr(string: *mut libc::c_char) -> *mut libc::c_char;
    fn max(i: libc::c_int, j: libc::c_int) -> libc::c_int;
    fn min(i: libc::c_int, j: libc::c_int) -> libc::c_int;
    fn myremove(f: *mut libc::c_char) -> libc::c_int;
    fn myfopen(f: *const libc::c_char, m: *mut libc::c_char) -> fileh;
    fn dispatch_semaphore_signal(dsema: dispatch_semaphore_t) -> intptr_t;
    fn dispatch_semaphore_wait(dsema: dispatch_semaphore_t, timeout: dispatch_time_t) -> intptr_t;
    fn dispatch_semaphore_create(value: intptr_t) -> dispatch_semaphore_t;
    fn open(_: *const libc::c_char, _: libc::c_int, _: ...) -> libc::c_int;
    fn __error() -> *mut libc::c_int;
    fn pthread_create(
        _: *mut pthread_t,
        _: *const pthread_attr_t,
        _: Option<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
        _: *mut libc::c_void,
    ) -> libc::c_int;
    fn fabs(_: libc::c_double) -> libc::c_double;
    fn ceil(_: libc::c_double) -> libc::c_double;
    fn arg_lit0(
        shortopts: *const libc::c_char,
        longopts: *const libc::c_char,
        glossary: *const libc::c_char,
    ) -> *mut arg_lit;
    fn arg_int0(
        shortopts: *const libc::c_char,
        longopts: *const libc::c_char,
        datatype: *const libc::c_char,
        glossary: *const libc::c_char,
    ) -> *mut arg_int;
    fn arg_intn(
        shortopts: *const libc::c_char,
        longopts: *const libc::c_char,
        datatype: *const libc::c_char,
        mincount: libc::c_int,
        maxcount: libc::c_int,
        glossary: *const libc::c_char,
    ) -> *mut arg_int;
    fn arg_strn(
        shortopts: *const libc::c_char,
        longopts: *const libc::c_char,
        datatype: *const libc::c_char,
        mincount: libc::c_int,
        maxcount: libc::c_int,
        glossary: *const libc::c_char,
    ) -> *mut arg_str;
    fn arg_filen(
        shortopts: *const libc::c_char,
        longopts: *const libc::c_char,
        datatype: *const libc::c_char,
        mincount: libc::c_int,
        maxcount: libc::c_int,
        glossary: *const libc::c_char,
    ) -> *mut arg_file;
    fn arg_end(maxerrors: libc::c_int) -> *mut arg_end;
    fn arg_nullcheck(argtable: *mut *mut libc::c_void) -> libc::c_int;
    fn arg_parse(
        argc: libc::c_int,
        argv: *mut *mut libc::c_char,
        argtable: *mut *mut libc::c_void,
    ) -> libc::c_int;
    fn arg_print_syntaxv(
        fp: *mut FILE,
        argtable: *mut *mut libc::c_void,
        suffix: *const libc::c_char,
    );
    fn arg_print_glossary(
        fp: *mut FILE,
        argtable: *mut *mut libc::c_void,
        format: *const libc::c_char,
    );
    fn arg_print_errors(fp: *mut FILE, end: *mut arg_end, progname_0: *const libc::c_char);
    fn arg_freetable(argtable: *mut *mut libc::c_void, n: size_t);
    static mut demux_pid: libc::c_int;
    static mut selected_audio_pid: libc::c_int;
    static mut selected_subtitle_pid: libc::c_int;
    static mut selected_video_pid: libc::c_int;
    static mut demux_asf: libc::c_int;
    static mut key: libc::c_int;
    static mut osname: [libc::c_char; 0];
    static mut xPos: libc::c_int;
    static mut yPos: libc::c_int;
    static mut lMouseDown: libc::c_int;
    static mut headerpos: int64_t;
    static mut reorderCC: libc::c_int;
    static mut framenum: libc::c_int;
    static mut pict_type: libc::c_char;
    static mut ms_audio_delay: libc::c_int;
    static mut is_h264: libc::c_int;
    fn backfill_frame_volumes();
    fn DecodeOnePicture(f: *mut FILE, pts: libc::c_double);
    fn CEW_init(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int;
    fn process_block(data: *mut libc::c_uchar, length: libc::c_long) -> libc::c_long;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __darwin_intptr_t = libc::c_long;
pub type __darwin_ct_rune_t = libc::c_int;
pub type __darwin_size_t = libc::c_ulong;
pub type __darwin_wchar_t = libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_ssize_t = libc::c_long;
pub type __darwin_time_t = libc::c_long;
pub type __darwin_off_t = __int64_t;
pub type __darwin_useconds_t = __uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: Option<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub __arg: *mut libc::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: libc::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [libc::c_char; 8176],
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type size_t = __darwin_size_t;
pub type int64_t = libc::c_longlong;
pub type intptr_t = __darwin_intptr_t;
pub type ssize_t = __darwin_ssize_t;
pub type uint64_t = libc::c_ulonglong;
pub type uint32_t = libc::c_uint;
pub type off_t = __darwin_off_t;
pub type useconds_t = __darwin_useconds_t;
pub type time_t = __darwin_time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _RuneRange {
    pub __nranges: libc::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _RuneCharClass {
    pub __name: [libc::c_char; 14],
    pub __mask: __uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _RuneLocale {
    pub __magic: [libc::c_char; 8],
    pub __encoding: [libc::c_char; 32],
    pub __sgetrune: Option<
        unsafe extern "C" fn(
            *const libc::c_char,
            __darwin_size_t,
            *mut *const libc::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: Option<
        unsafe extern "C" fn(
            __darwin_rune_t,
            *mut libc::c_char,
            __darwin_size_t,
            *mut *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256],
    pub __maplower: [__darwin_rune_t; 256],
    pub __mapupper: [__darwin_rune_t; 256],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut libc::c_void,
    pub __variable_len: libc::c_int,
    pub __ncharclasses: libc::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
pub type fpos_t = __darwin_off_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __sbuf {
    pub _base: *mut libc::c_uchar,
    pub _size: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __sFILE {
    pub _p: *mut libc::c_uchar,
    pub _r: libc::c_int,
    pub _w: libc::c_int,
    pub _flags: libc::c_short,
    pub _file: libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: libc::c_int,
    pub _cookie: *mut libc::c_void,
    pub _close: Option<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub _read: Option<
        unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_char, libc::c_int) -> libc::c_int,
    >,
    pub _seek: Option<unsafe extern "C" fn(*mut libc::c_void, fpos_t, libc::c_int) -> fpos_t>,
    pub _write: Option<
        unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, libc::c_int) -> libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: libc::c_int,
    pub _ubuf: [libc::c_uchar; 3],
    pub _nbuf: [libc::c_uchar; 1],
    pub _lb: __sbuf,
    pub _blksize: libc::c_int,
    pub _offset: fpos_t,
}
pub type FILE = __sFILE;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type uint8_t = libc::c_uchar;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *mut libc::c_char,
}
pub type pthread_t = __darwin_pthread_t;
pub type dispatch_time_t = uint64_t;
pub type dispatch_semaphore_t = *mut dispatch_semaphore_s;
pub type sema_t = dispatch_semaphore_t;
pub type fileh = *mut FILE;
pub type arg_resetfn = unsafe extern "C" fn(*mut libc::c_void) -> ();
pub type arg_scanfn = unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char) -> libc::c_int;
pub type arg_checkfn = unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int;
pub type arg_errorfn = unsafe extern "C" fn(
    *mut libc::c_void,
    *mut FILE,
    libc::c_int,
    *const libc::c_char,
    *const libc::c_char,
) -> ();
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arg_hdr {
    pub flag: libc::c_char,
    pub shortopts: *const libc::c_char,
    pub longopts: *const libc::c_char,
    pub datatype: *const libc::c_char,
    pub glossary: *const libc::c_char,
    pub mincount: libc::c_int,
    pub maxcount: libc::c_int,
    pub parent: *mut libc::c_void,
    pub resetfn: Option<arg_resetfn>,
    pub scanfn: Option<arg_scanfn>,
    pub checkfn: Option<arg_checkfn>,
    pub errorfn: Option<arg_errorfn>,
    pub priv_0: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arg_lit {
    pub hdr: arg_hdr,
    pub count: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arg_int {
    pub hdr: arg_hdr,
    pub count: libc::c_int,
    pub ival: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arg_str {
    pub hdr: arg_hdr,
    pub count: libc::c_int,
    pub sval: *mut *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arg_file {
    pub hdr: arg_hdr,
    pub count: libc::c_int,
    pub filename: *mut *const libc::c_char,
    pub basename: *mut *const libc::c_char,
    pub extension: *mut *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct arg_end {
    pub hdr: arg_hdr,
    pub count: libc::c_int,
    pub error: *mut libc::c_int,
    pub parent: *mut *mut libc::c_void,
    pub argval: *mut *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct frame_info {
    pub brightness: libc::c_int,
    pub schange_percent: libc::c_int,
    pub minY: libc::c_int,
    pub maxY: libc::c_int,
    pub uniform: libc::c_int,
    pub volume: libc::c_int,
    pub currentGoodEdge: libc::c_double,
    pub ar_ratio: libc::c_double,
    pub logo_present: bool,
    pub commercial: bool,
    pub isblack: bool,
    pub goppos: int64_t,
    pub pts: libc::c_double,
    pub pict_type: libc::c_char,
    pub minX: libc::c_int,
    pub maxX: libc::c_int,
    pub hasBright: libc::c_int,
    pub dimCount: libc::c_int,
    pub cutscenematch: libc::c_int,
    pub logo_filter: libc::c_double,
    pub xds: libc::c_int,
    pub cur_segment: libc::c_int,
    pub audio_channels: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct schange_info {
    pub frame: libc::c_long,
    pub percentage: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct black_frame_info {
    pub frame: libc::c_long,
    pub brightness: libc::c_int,
    pub uniform: libc::c_long,
    pub volume: libc::c_int,
    pub cause: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct block_info {
    pub f_start: libc::c_long,
    pub f_end: libc::c_long,
    pub b_head: libc::c_uint,
    pub b_tail: libc::c_uint,
    pub bframe_count: libc::c_uint,
    pub schange_count: libc::c_uint,
    pub schange_rate: libc::c_double,
    pub length: libc::c_double,
    pub score: libc::c_double,
    pub combined_count: libc::c_int,
    pub cc_type: libc::c_int,
    pub ar_ratio: libc::c_double,
    pub audio_channels: libc::c_int,
    pub cause: libc::c_int,
    pub more: libc::c_int,
    pub less: libc::c_int,
    pub brightness: libc::c_int,
    pub volume: libc::c_int,
    pub silence: libc::c_int,
    pub uniform: libc::c_int,
    pub stdev: libc::c_int,
    pub reffer: libc::c_char,
    pub logo: libc::c_double,
    pub correlation: libc::c_double,
    pub strict: libc::c_int,
    pub iscommercial: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct logo_block_info {
    pub start: libc::c_int,
    pub end: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ccPacket {
    pub cc1: [libc::c_uchar; 2],
    pub cc2: [libc::c_uchar; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cc_block_info {
    pub start_frame: libc::c_long,
    pub end_frame: libc::c_long,
    pub type_0: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct XDS_block_info {
    pub frame: libc::c_long,
    pub name: [libc::c_char; 40],
    pub v_chip: libc::c_int,
    pub duration: libc::c_int,
    pub position: libc::c_int,
    pub composite1: libc::c_int,
    pub composite2: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cc_text_info {
    pub start_frame: libc::c_long,
    pub end_frame: libc::c_long,
    pub text_len: libc::c_long,
    pub text: [libc::c_uchar; 256],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ar_block_info {
    pub start: libc::c_int,
    pub end: libc::c_int,
    pub ar_ratio: libc::c_double,
    pub volume: libc::c_int,
    pub height: libc::c_int,
    pub width: libc::c_int,
    pub minX: libc::c_int,
    pub maxX: libc::c_int,
    pub minY: libc::c_int,
    pub maxY: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ac_block_info {
    pub start: libc::c_int,
    pub end: libc::c_int,
    pub audio_channels: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct commercial_list_info {
    pub start: libc::c_long,
    pub end: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed {
    pub start_frame: libc::c_long,
    pub end_frame: libc::c_long,
    pub start_block: libc::c_int,
    pub end_block: libc::c_int,
    pub length: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub start_frame: libc::c_long,
    pub end_frame: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub frames: libc::c_long,
    pub ar_ratio: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub frames: libc::c_long,
    pub audio_channels: libc::c_int,
}
pub type C2RustUnnamed_3 = libc::c_uint;
pub const only_commercial: C2RustUnnamed_3 = 3;
pub const only_reffer: C2RustUnnamed_3 = 2;
pub const both_commercial: C2RustUnnamed_3 = 1;
pub const both_show: C2RustUnnamed_3 = 0;
#[inline]
unsafe extern "C" fn isascii(mut _c: libc::c_int) -> libc::c_int {
    return (_c & !(0x7f as libc::c_int) == 0 as libc::c_int) as libc::c_int;
}
#[inline]
unsafe extern "C" fn __istype(mut _c: __darwin_ct_rune_t, mut _f: libc::c_ulong) -> libc::c_int {
    return if isascii(_c) != 0 {
        (_DefaultRuneLocale.__runetype[_c as usize] as libc::c_ulong & _f != 0) as libc::c_int
    } else {
        (__maskrune(_c, _f) != 0) as libc::c_int
    };
}
#[no_mangle]
#[inline]
#[linkage = "external"]
pub unsafe extern "C" fn isalpha(mut _c: libc::c_int) -> libc::c_int {
    return __istype(_c, 0x100 as libc::c_long as libc::c_ulong);
}
#[no_mangle]
#[inline]
#[linkage = "external"]
pub unsafe extern "C" fn isspace(mut _c: libc::c_int) -> libc::c_int {
    return __istype(_c, 0x4000 as libc::c_long as libc::c_ulong);
}
#[no_mangle]
pub unsafe extern "C" fn __vaDriverInit_iHD(mut ctx: *mut libc::c_void) -> libc::c_int {
    return -(1 as libc::c_int);
}
#[no_mangle]
pub static mut argument_count: libc::c_int = 0;
#[no_mangle]
pub static mut argument: *mut *mut libc::c_char =
    0 as *const *mut libc::c_char as *mut *mut libc::c_char;
#[no_mangle]
pub static mut initialized: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut progname: *const libc::c_char = b"ComSkip\0" as *const u8 as *const libc::c_char;
#[no_mangle]
pub static mut out_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut incommercial_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut ini_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut plist_cutlist_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut zoomplayer_cutlist_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut zoomplayer_chapter_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut scf_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut vcf_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut vdr_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut projectx_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut avisynth_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut videoredo_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut videoredo3_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut btv_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut edl_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut ffmeta_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut ffsplit_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut live_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut ipodchap_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut edlp_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut bcf_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut edlx_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut cuttermaran_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut chapters_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut log_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut womble_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut mls_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut mpgtx_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut dvrcut_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut dvrmstb_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut mpeg2schnitt_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut tuning_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut training_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut aspect_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut cutscene_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut mkvtoolnix_chapters_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut mkvtoolnix_tags_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut audio_channels: libc::c_int = 0;
#[no_mangle]
pub static mut vo_init_done: libc::c_int = 0 as libc::c_int;
static mut in_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub static mut debug_cur_segment: libc::c_int = 0;
#[no_mangle]
pub static mut frame: *mut frame_info = 0 as *const frame_info as *mut frame_info;
#[no_mangle]
pub static mut frame_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_frame_count: libc::c_long = 0;
#[no_mangle]
pub static mut fps: libc::c_double = 22.0f64;
#[no_mangle]
pub unsafe extern "C" fn get_frame_pts(mut f: libc::c_int) -> libc::c_double {
    if frame.is_null() {
        return f as libc::c_double / fps;
    }
    if f < 1 as libc::c_int {
        f = 1 as libc::c_int;
    }
    if f as libc::c_long > frame_count - 1 as libc::c_int as libc::c_long {
        f = (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
    }
    return (*frame.offset(f as isize)).pts;
}
#[no_mangle]
pub static mut schange: *mut schange_info = 0 as *const schange_info as *mut schange_info;
#[no_mangle]
pub static mut schange_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_schange_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut black_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut black: *mut black_frame_info = 0 as *const black_frame_info as *mut black_frame_info;
#[no_mangle]
pub static mut max_black_count: libc::c_long = 0;
#[no_mangle]
pub static mut cblock: [block_info; 1000] = [block_info {
    f_start: 0,
    f_end: 0,
    b_head: 0,
    b_tail: 0,
    bframe_count: 0,
    schange_count: 0,
    schange_rate: 0.,
    length: 0.,
    score: 0.,
    combined_count: 0,
    cc_type: 0,
    ar_ratio: 0.,
    audio_channels: 0,
    cause: 0,
    more: 0,
    less: 0,
    brightness: 0,
    volume: 0,
    silence: 0,
    uniform: 0,
    stdev: 0,
    reffer: 0,
    logo: 0.,
    correlation: 0.,
    strict: 0,
    iscommercial: 0,
}; 1000];
#[no_mangle]
pub static mut block_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_block_count: libc::c_long = 0;
#[no_mangle]
pub static mut logo_block: *mut logo_block_info =
    0 as *const logo_block_info as *mut logo_block_info;
#[no_mangle]
pub static mut logo_block_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_logo_block_count: libc::c_long = 0;
#[no_mangle]
pub static mut processCC: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut lastcc: ccPacket = ccPacket {
    cc1: [0; 2],
    cc2: [0; 2],
};
#[no_mangle]
pub static mut cc: ccPacket = ccPacket {
    cc1: [0; 2],
    cc2: [0; 2],
};
#[no_mangle]
pub static mut cc_block: *mut cc_block_info = 0 as *const cc_block_info as *mut cc_block_info;
#[no_mangle]
pub static mut cc_block_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_cc_block_count: libc::c_long = 0;
#[no_mangle]
pub static mut last_cc_type: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut current_cc_type: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut cc_on_screen: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut cc_in_memory: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut XDS_block: *mut XDS_block_info = 0 as *const XDS_block_info as *mut XDS_block_info;
#[no_mangle]
pub static mut XDS_block_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_XDS_block_count: libc::c_long = 0;
#[no_mangle]
pub static mut cc_text: *mut cc_text_info = 0 as *const cc_text_info as *mut cc_text_info;
#[no_mangle]
pub static mut cc_text_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_cc_text_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut ar_block: *mut ar_block_info = 0 as *const ar_block_info as *mut ar_block_info;
#[no_mangle]
pub static mut ar_block_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_ar_block_count: libc::c_long = 0;
#[no_mangle]
pub static mut last_audio_channels: libc::c_int = 2 as libc::c_int;
#[no_mangle]
pub static mut last_ar_ratio: libc::c_double = 0.0f64;
#[no_mangle]
pub static mut ar_ratio_trend: libc::c_double = 0.0f64;
#[no_mangle]
pub static mut ar_ratio_trend_counter: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ar_ratio_start: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ar_misratio_trend_counter: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ar_misratio_start: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ac_block: *mut ac_block_info = 0 as *const ac_block_info as *mut ac_block_info;
#[no_mangle]
pub static mut ac_block_count: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut max_ac_block_count: libc::c_long = 0;
#[no_mangle]
pub static mut commercial_list: *mut commercial_list_info =
    0 as *const commercial_list_info as *mut commercial_list_info;
#[no_mangle]
pub static mut commercial_count: libc::c_int = -(1 as libc::c_int);
#[no_mangle]
pub static mut commercial: [C2RustUnnamed; 100000] = [C2RustUnnamed {
    start_frame: 0,
    end_frame: 0,
    start_block: 0,
    end_block: 0,
    length: 0.,
}; 100000];
#[no_mangle]
pub static mut reffer_count: libc::c_int = -(1 as libc::c_int);
#[no_mangle]
pub static mut reffer: [C2RustUnnamed_0; 100000] = [C2RustUnnamed_0 {
    start_frame: 0,
    end_frame: 0,
}; 100000];
#[no_mangle]
pub static mut ar_histogram: [C2RustUnnamed_1; 1000] = [C2RustUnnamed_1 {
    frames: 0,
    ar_ratio: 0.,
}; 1000];
#[no_mangle]
pub static mut dominant_ar: libc::c_double = 0.;
#[no_mangle]
pub static mut ac_histogram: [C2RustUnnamed_2; 12] = [C2RustUnnamed_2 {
    frames: 0,
    audio_channels: 0,
}; 12];
#[no_mangle]
pub static mut dominant_ac: libc::c_int = 0;
#[no_mangle]
pub static mut thread_count: libc::c_int = 2 as libc::c_int;
#[no_mangle]
pub static mut hardware_decode: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut skip_B_frames: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut lowres: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut live_tv: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_incommercial: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut incommercial_frames: libc::c_int = 1000 as libc::c_int;
#[no_mangle]
pub static mut live_tv_retries: libc::c_int = 6 as libc::c_int;
#[no_mangle]
pub static mut dvrms_live_tv_retries: libc::c_int = 300 as libc::c_int;
#[no_mangle]
pub static mut standoff: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut dvrmsstandoff: libc::c_int = 120000 as libc::c_int;
#[no_mangle]
pub static mut incomingCommandLine: [libc::c_char; 4096] = [0; 4096];
#[no_mangle]
pub static mut logofilename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut logfilename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut mpegfilename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut exefilename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut inbasename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut workbasename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut outbasename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut shortbasename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut inifilename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut dictfilename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut out_filename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut incommercial_filename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut outputdirname: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut filename: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut curvolume: libc::c_int = -(1 as libc::c_int);
#[no_mangle]
pub static mut ascr: libc::c_int = 0;
#[no_mangle]
pub static mut scr: libc::c_int = 0;
#[no_mangle]
pub static mut framenum_real: libc::c_int = 0;
#[no_mangle]
pub static mut frames_with_logo: libc::c_int = 0;
#[no_mangle]
pub static mut framesprocessed: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut HomeDir: [libc::c_char; 256] = [0; 256];
#[no_mangle]
pub static mut tempString: [libc::c_char; 256] = [0; 256];
#[no_mangle]
pub static mut average_score: libc::c_double = 0.;
#[no_mangle]
pub static mut brightness: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut sum_brightness: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut sum_count: libc::c_long = 0;
#[no_mangle]
pub static mut uniformHistogram: [libc::c_int; 256] = [0; 256];
#[no_mangle]
pub static mut brightHistogram: [libc::c_int; 256] = [0; 256];
#[no_mangle]
pub static mut blackHistogram: [libc::c_int; 256] = [0; 256];
#[no_mangle]
pub static mut volumeHistogram: [libc::c_int; 256] = [0; 256];
#[no_mangle]
pub static mut silenceHistogram: [libc::c_int; 256] = [0; 256];
#[no_mangle]
pub static mut logoHistogram: [libc::c_int; 256] = [0; 256];
#[no_mangle]
pub static mut volumeScale: libc::c_int = 10 as libc::c_int;
#[no_mangle]
pub static mut last_brightness: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut min_brightness_found: libc::c_int = 0;
#[no_mangle]
pub static mut min_volume_found: libc::c_int = 0;
#[no_mangle]
pub static mut max_logo_gap: libc::c_int = 0;
#[no_mangle]
pub static mut max_nonlogo_block_length: libc::c_int = 0;
#[no_mangle]
pub static mut logo_overshoot: libc::c_double = 0.;
#[no_mangle]
pub static mut logo_quality: libc::c_double = 0.;
#[no_mangle]
pub static mut width: libc::c_int = 0;
#[no_mangle]
pub static mut old_width: libc::c_int = 0;
#[no_mangle]
pub static mut videowidth: libc::c_int = 0;
#[no_mangle]
pub static mut height: libc::c_int = 0;
#[no_mangle]
pub static mut old_height: libc::c_int = 0;
#[no_mangle]
pub static mut ar_width: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut subsample_video: libc::c_int = 0x1ff as libc::c_int;
#[no_mangle]
pub static mut haslogo: [libc::c_char; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut selftest: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut verbose: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut avg_fps: libc::c_double = 22 as libc::c_int as libc::c_double;
#[no_mangle]
pub static mut border: libc::c_int = 10 as libc::c_int;
#[no_mangle]
pub static mut ticker_tape: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ticker_tape_percentage: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ignore_side: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ignore_left_side: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ignore_right_side: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut max_brightness: libc::c_int = 60 as libc::c_int;
#[no_mangle]
pub static mut maxbright: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut min_hasBright: libc::c_int = 255000 as libc::c_int;
#[no_mangle]
pub static mut min_dimCount: libc::c_int = 255000 as libc::c_int;
#[no_mangle]
pub static mut test_brightness: libc::c_int = 40 as libc::c_int;
#[no_mangle]
pub static mut max_avg_brightness: libc::c_int = 19 as libc::c_int;
#[no_mangle]
pub static mut max_volume: libc::c_int = 500 as libc::c_int;
#[no_mangle]
pub static mut max_silence: libc::c_int = 100 as libc::c_int;
#[no_mangle]
pub static mut min_silence: libc::c_int = 12 as libc::c_int;
#[no_mangle]
pub static mut punish_no_logo: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut validate_silence: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut validate_uniform: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut validate_scenechange: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut remove_silent_segments: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut validate_ar: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut punish: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut reward: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut min_volume: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut min_uniform: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut volume_slip: libc::c_int = 40 as libc::c_int;
#[no_mangle]
pub static mut max_repair_size: libc::c_int = 40 as libc::c_int;
#[no_mangle]
pub static mut ini_text: [libc::c_char; 40000] = [0; 40000];
#[no_mangle]
pub static mut max_commercialbreak: libc::c_double = 600 as libc::c_int as libc::c_double;
#[no_mangle]
pub static mut min_commercialbreak: libc::c_double = 20 as libc::c_int as libc::c_double;
#[no_mangle]
pub static mut max_commercial_size: libc::c_double = 120 as libc::c_int as libc::c_double;
#[no_mangle]
pub static mut min_commercial_size: libc::c_double = 4 as libc::c_int as libc::c_double;
#[no_mangle]
pub static mut min_show_segment_length: libc::c_double = 120.0f64;
#[no_mangle]
pub static mut require_div5: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut div5_tolerance: libc::c_double = -(1 as libc::c_int) as libc::c_double;
#[no_mangle]
pub static mut play_nice: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut global_threshold: libc::c_double = 1.05f64;
#[no_mangle]
pub static mut intelligent_brightness: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut logo_threshold: libc::c_double = 0.80f64;
#[no_mangle]
pub static mut logo_percentage_threshold: libc::c_double = 0.25f64;
#[no_mangle]
pub static mut logo_max_percentage_of_screen: libc::c_double = 0.12f64;
#[no_mangle]
pub static mut logo_min_percentage_of_screen: libc::c_double = 0.00f64;
#[no_mangle]
pub static mut logo_filter: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut non_uniformity: libc::c_int = 500 as libc::c_int;
#[no_mangle]
pub static mut brightness_jump: libc::c_int = 200 as libc::c_int;
#[no_mangle]
pub static mut black_percentile: libc::c_double = 0.0076f64;
#[no_mangle]
pub static mut uniform_percentile: libc::c_double = 0.003f64;
#[no_mangle]
pub static mut score_percentile: libc::c_double = 0.71f64;
#[no_mangle]
pub static mut logo_percentile: libc::c_double = 0.92f64;
#[no_mangle]
pub static mut logo_fraction: libc::c_double = 0.40f64;
#[no_mangle]
pub static mut commDetectMethod: libc::c_int = 0;
#[no_mangle]
pub static mut giveUpOnLogoSearch: libc::c_int = 2000 as libc::c_int;
#[no_mangle]
pub static mut delay_logo_search: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut cut_on_ar_change: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut cut_on_ac_change: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut added_recording: libc::c_int = 14 as libc::c_int;
#[no_mangle]
pub static mut after_start: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut before_end: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut delete_show_after_last_commercial: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut delete_show_before_first_commercial: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut delete_block_after_commercial: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut min_commercial_break_at_start_or_end: libc::c_int = 39 as libc::c_int;
#[no_mangle]
pub static mut always_keep_first_seconds: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut always_keep_last_seconds: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut connect_blocks_with_logo: bool = 1 as libc::c_int != 0;
#[no_mangle]
pub static mut delete_show_before_or_after_current: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut deleteLogoFile: bool = 1 as libc::c_int != 0;
#[no_mangle]
pub static mut useExistingLogoFile: bool = 1 as libc::c_int != 0;
#[no_mangle]
pub static mut startOverAfterLogoInfoAvail: bool = 1 as libc::c_int != 0;
#[no_mangle]
pub static mut doublCheckLogoCount: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut output_default: bool = 1 as libc::c_int != 0;
#[no_mangle]
pub static mut output_chapters: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut sage_framenumber_bug: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut sage_minute_bug: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut enable_mencoder_pts: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_plist_cutlist: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_zoomplayer_cutlist: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_zoomplayer_chapter: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_scf: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_videoredo: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_videoredo3: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_ipodchap: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut videoredo_offset: libc::c_int = 2 as libc::c_int;
#[no_mangle]
pub static mut edl_offset: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut timeline_repair: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut edl_skip_field: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut output_edl: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_live: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_edlp: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_bsplayer: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_edlx: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_btv: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_cuttermaran: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_mpeg2schnitt: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut cuttermaran_options: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut mpeg2schnitt_options: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut avisynth_options: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut dvrcut_options: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut output_demux: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_data: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_srt: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_smi: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_timing: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_womble: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_mls: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_mpgtx: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_dvrcut: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_dvrmstb: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_vdr: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_vcf: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_projectx: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_avisynth: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_mkvtoolnix: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut output_debugwindow: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_console: bool = 1 as libc::c_int != 0;
#[no_mangle]
pub static mut disable_heuristics: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut windowtitle: [libc::c_char; 1024] = unsafe {
    *::std::mem::transmute::<
        &[u8; 1024],
        &mut [libc::c_char; 1024],
    >(
        b"Comskip - %s\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
    )
};
#[no_mangle]
pub static mut output_tuning: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_training: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut output_false: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_aspect: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_ffmeta: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut output_ffsplit: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut noise_level: libc::c_int = 5 as libc::c_int;
#[no_mangle]
pub static mut framearray: bool = 1 as libc::c_int != 0;
#[no_mangle]
pub static mut output_framearray: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut only_strict: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut length_strict_modifier: libc::c_double = 3.0f64;
#[no_mangle]
pub static mut length_nonstrict_modifier: libc::c_double = 1.5f64;
#[no_mangle]
pub static mut combined_length_strict_modifier: libc::c_double = 2.0f64;
#[no_mangle]
pub static mut combined_length_nonstrict_modifier: libc::c_double = 1.25f64;
#[no_mangle]
pub static mut logo_present_modifier: libc::c_double = 0.01f64;
#[no_mangle]
pub static mut punish_modifier: libc::c_double = 2.0f64;
#[no_mangle]
pub static mut punish_threshold: libc::c_double = 1.3f64;
#[no_mangle]
pub static mut reward_modifier: libc::c_double = 0.5f64;
#[no_mangle]
pub static mut after_logo: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut before_logo: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut shrink_logo: libc::c_double = 5.0f64;
#[no_mangle]
pub static mut shrink_logo_tail: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut where_logo: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut excessive_length_modifier: libc::c_double = 0.01f64;
#[no_mangle]
pub static mut dark_block_modifier: libc::c_double = 0.3f64;
#[no_mangle]
pub static mut padding: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut remove_before: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut remove_after: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut min_schange_modifier: libc::c_double = 0.5f64;
#[no_mangle]
pub static mut max_schange_modifier: libc::c_double = 2.0f64;
#[no_mangle]
pub static mut schange_threshold: libc::c_int = 90 as libc::c_int;
#[no_mangle]
pub static mut schange_cutlevel: libc::c_int = 15 as libc::c_int;
#[no_mangle]
pub static mut cc_commercial_type_modifier: libc::c_double = 4.0f64;
#[no_mangle]
pub static mut cc_wrong_type_modifier: libc::c_double = 2.0f64;
#[no_mangle]
pub static mut cc_correct_type_modifier: libc::c_double = 0.75f64;
#[no_mangle]
pub static mut ar_wrong_modifier: libc::c_double = 2.0f64;
#[no_mangle]
pub static mut ac_wrong_modifier: libc::c_double = 1.0f64;
#[no_mangle]
pub static mut ar_rounding: libc::c_double = 100 as libc::c_int as libc::c_double;
#[no_mangle]
pub static mut ar_delta: libc::c_double = 0.08f64;
#[no_mangle]
pub static mut avg_brightness: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut maxi_volume: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut avg_volume: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut avg_silence: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut avg_uniform: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut avg_schange: libc::c_double = 0.0f64;
#[no_mangle]
pub static mut dictionary_modifier: libc::c_double = 1.05f64;
#[no_mangle]
pub static mut aggressive_logo_rejection: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut min_black_frames_for_break: libc::c_uint = 1 as libc::c_int as libc::c_uint;
#[no_mangle]
pub static mut detectBlackFrames: bool = false;
#[no_mangle]
pub static mut detectSceneChanges: bool = false;
#[no_mangle]
pub static mut dummy1: libc::c_int = 0;
#[no_mangle]
pub static mut frame_ptr: *mut libc::c_uchar = 0 as *const libc::c_uchar as *mut libc::c_uchar;
#[no_mangle]
pub static mut dummy2: libc::c_int = 0;
#[no_mangle]
pub static mut sceneHasChanged: bool = false;
#[no_mangle]
pub static mut sceneChangePercent: libc::c_int = 0;
#[no_mangle]
pub static mut lastFrameWasBlack: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut lastFrameWasSceneChange: bool = 0 as libc::c_int != 0;
static mut histogram: [libc::c_long; 256] = [0; 256];
static mut lastHistogram: [libc::c_long; 256] = [0; 256];
#[no_mangle]
pub static mut cutscenefile: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenefile1: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenefile2: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenefile3: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenefile4: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenefile5: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenefile6: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenefile7: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenefile8: [libc::c_char; 1024] = [0; 1024];
#[no_mangle]
pub static mut cutscenematch: libc::c_int = 0;
#[no_mangle]
pub static mut cutscenedelta: libc::c_int = 10 as libc::c_int;
#[no_mangle]
pub static mut cutsceneno: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut cutscenes: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut cutscene: [[libc::c_uchar; 120000]; 8] = [[0; 120000]; 8];
#[no_mangle]
pub static mut csbrightness: [libc::c_int; 8] = [0; 8];
#[no_mangle]
pub static mut cslength: [libc::c_int; 8] = [0; 8];
#[no_mangle]
pub static mut debugText: [libc::c_char; 20000] = [0; 20000];
#[no_mangle]
pub static mut logoInfoAvailable: bool = false;
#[no_mangle]
pub static mut secondLogoSearch: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut logoBuffersFull: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut logoTrendCounter: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut logoFreq: libc::c_double = 1.0f64;
#[no_mangle]
pub static mut num_logo_buffers: libc::c_int = 50 as libc::c_int;
#[no_mangle]
pub static mut lastLogoTest: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut logoFrameNum: *mut libc::c_int = 0 as *const libc::c_int as *mut libc::c_int;
#[no_mangle]
pub static mut oldestLogoBuffer: libc::c_int = 0;
#[no_mangle]
pub static mut curLogoTest: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut minHitsForTrend: libc::c_int = 10 as libc::c_int;
#[no_mangle]
pub static mut logoPercentage: libc::c_double = 0.0f64;
#[no_mangle]
pub static mut reverseLogoLogic: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut horiz_count: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut vert_count: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut borderIgnore: libc::c_double = 0.05f64;
#[no_mangle]
pub static mut subtitles: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut logo_at_bottom: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut edge_radius: libc::c_int = 2 as libc::c_int;
#[no_mangle]
pub static mut int_edge_radius: libc::c_int = 2 as libc::c_int;
#[no_mangle]
pub static mut edge_step: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut edge_level_threshold: libc::c_int = 5 as libc::c_int;
#[no_mangle]
pub static mut edge_weight: libc::c_int = 10 as libc::c_int;
#[no_mangle]
pub static mut edge_count: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut hedge_count: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut vedge_count: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut newestLogoBuffer: libc::c_int = -(1 as libc::c_int);
#[no_mangle]
pub static mut logoFrameBuffer: *mut *mut libc::c_uchar =
    0 as *const *mut libc::c_uchar as *mut *mut libc::c_uchar;
#[no_mangle]
pub static mut logoFrameBufferSize: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut lwidth: libc::c_int = 0;
#[no_mangle]
pub static mut lheight: libc::c_int = 0;
#[no_mangle]
pub static mut tlogoMinX: libc::c_int = 0;
#[no_mangle]
pub static mut tlogoMaxX: libc::c_int = 0;
#[no_mangle]
pub static mut tlogoMinY: libc::c_int = 0;
#[no_mangle]
pub static mut tlogoMaxY: libc::c_int = 0;
#[no_mangle]
pub static mut edgemask_filled: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut thoriz_edgemask: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut tvert_edgemask: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut clogoMinX: libc::c_int = 0;
#[no_mangle]
pub static mut clogoMaxX: libc::c_int = 0;
#[no_mangle]
pub static mut clogoMinY: libc::c_int = 0;
#[no_mangle]
pub static mut clogoMaxY: libc::c_int = 0;
#[no_mangle]
pub static mut choriz_edgemask: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut cvert_edgemask: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut play_nice_start: libc::c_int = -(1 as libc::c_int);
#[no_mangle]
pub static mut play_nice_end: libc::c_int = -(1 as libc::c_int);
#[no_mangle]
pub static mut play_nice_sleep: libc::c_long = 2 as libc::c_long;
#[no_mangle]
pub static mut dump_data_file: *mut FILE =
    0 as *const libc::c_void as *mut libc::c_void as *mut FILE;
#[no_mangle]
pub static mut ccData: [uint8_t; 500] = [0; 500];
#[no_mangle]
pub static mut ccDataLen: libc::c_int = 0;
static mut prevccData: [uint8_t; 500] = [0; 500];
static mut prevccDataLen: libc::c_int = 0;
#[no_mangle]
pub static mut cc_count: [libc::c_long; 5] = [
    0 as libc::c_int as libc::c_long,
    0 as libc::c_int as libc::c_long,
    0 as libc::c_int as libc::c_long,
    0 as libc::c_int as libc::c_long,
    0 as libc::c_int as libc::c_long,
];
#[no_mangle]
pub static mut most_cc_type: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut cc_screen: *mut *mut libc::c_uchar =
    0 as *const *mut libc::c_uchar as *mut *mut libc::c_uchar;
#[no_mangle]
pub static mut cc_memory: *mut *mut libc::c_uchar =
    0 as *const *mut libc::c_uchar as *mut *mut libc::c_uchar;
#[no_mangle]
pub static mut minY: libc::c_int = 0;
#[no_mangle]
pub static mut maxY: libc::c_int = 0;
#[no_mangle]
pub static mut minX: libc::c_int = 0;
#[no_mangle]
pub static mut maxX: libc::c_int = 0;
#[no_mangle]
pub static mut isSecondPass: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut lastFrame: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut lastFrameCommCalculated: libc::c_long = 0 as libc::c_int as libc::c_long;
#[no_mangle]
pub static mut ccCheck: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut loadingCSV: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut loadingTXT: bool = 0 as libc::c_int != 0;
#[no_mangle]
pub static mut helpflag: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut timeflag: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut recalculate: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut helptext: [*mut libc::c_char; 24] = [
    b"Help: press any key to remove\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"Key          Action\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"Arrows\t        Reposition current location\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"PgUp/PgDn      Reposition current location\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"n/p            Jump to next/previous cutpoint\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"e/b            Jump to next/previous end of cblock\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"z/u            Zoom in/out on the timeline\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"g              Graph on/off\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"x              XDS info on/off\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"t              Toggle current cblock between show and commercial\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"w              Write the new cutpoints to the ouput files\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"c              Dump this frame as CutSceneF2             Reduce the max_volume detection level\0"
        as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"F3             Reduce the non_uniformity detection level\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"F4             Reduce the max_avg_brighness detection level\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"F5             Toggle frame number / timecode display\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"During commercial break review\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"e              Set end of commercial to this position\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"b              Set begin of commercial to this position\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"i              Insert a new commercial\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char,
    b"d              Delete the commercial at current location\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"s              Jump to Start of the recording\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    b"f              Jump to Finish of the recording\0" as *const u8
        as *const libc::c_char as *mut libc::c_char,
    0 as *const libc::c_char as *mut libc::c_char,
];
#[no_mangle]
pub static mut currentGoodEdge: libc::c_double = 0.0f64;
#[no_mangle]
pub static mut lineStart: [libc::c_int; 1200] = [0; 1200];
#[no_mangle]
pub static mut lineEnd: [libc::c_int; 1200] = [0; 1200];
#[no_mangle]
pub static mut hor_edgecount: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut ver_edgecount: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut max_br: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut min_br: [libc::c_uchar; 4608000] = [0; 4608000];
#[no_mangle]
pub static mut graph: [libc::c_uchar; 13824000] = [0; 13824000];
#[no_mangle]
pub static mut gy: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub unsafe extern "C" fn CauseString(mut i: libc::c_int) -> *mut libc::c_char {
    static mut cs: [[libc::c_char; 80]; 4] = [[0; 80]; 4];
    static mut ii: libc::c_int = 0 as libc::c_int;
    let mut c: *mut libc::c_char = &mut *(*cs.as_mut_ptr().offset(ii as isize))
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut libc::c_char;
    let mut rc: *mut libc::c_char = &mut *(*cs.as_mut_ptr().offset(ii as isize))
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut libc::c_char;
    let fresh0 = c;
    c = c.offset(1);
    *fresh0 = (if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 30 as libc::c_int != 0 {
        '8' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh1 = c;
    c = c.offset(1);
    *fresh1 = (if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 29 as libc::c_int != 0 {
        '7' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh2 = c;
    c = c.offset(1);
    *fresh2 = (if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 22 as libc::c_int != 0 {
        '6' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh3 = c;
    c = c.offset(1);
    *fresh3 = (if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 17 as libc::c_int != 0 {
        '5' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh4 = c;
    c = c.offset(1);
    *fresh4 = (if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 16 as libc::c_int != 0 {
        '4' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh5 = c;
    c = c.offset(1);
    *fresh5 = (if i & (1 as libc::c_int) << 15 as libc::c_int != 0 {
        '3' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh6 = c;
    c = c.offset(1);
    *fresh6 = (if i & (1 as libc::c_int) << 14 as libc::c_int != 0 {
        '2' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh7 = c;
    c = c.offset(1);
    *fresh7 = (if i & (1 as libc::c_int) << 13 as libc::c_int != 0 {
        '1' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    if strncmp(
        (cs[ii as usize]).as_mut_ptr(),
        b"       \0" as *const u8 as *const libc::c_char,
        7 as libc::c_int as libc::c_ulong,
    ) != 0
    {
        let fresh8 = c;
        c = c.offset(1);
        *fresh8 = '{' as i32 as libc::c_char;
    } else {
        let fresh9 = c;
        c = c.offset(1);
        *fresh9 = ' ' as i32 as libc::c_char;
    }
    let fresh10 = c;
    c = c.offset(1);
    *fresh10 = (if i & (1 as libc::c_int) << 12 as libc::c_int != 0 {
        'F' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh11 = c;
    c = c.offset(1);
    *fresh11 = (if i & (1 as libc::c_int) << 11 as libc::c_int != 0 {
        'A' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh12 = c;
    c = c.offset(1);
    *fresh12 = (if i & (1 as libc::c_int) << 10 as libc::c_int != 0 {
        'E' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh13 = c;
    c = c.offset(1);
    *fresh13 = (if i & (1 as libc::c_int) << 9 as libc::c_int != 0 {
        'L' as i32
    } else if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 19 as libc::c_int != 0 {
        'B' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh14 = c;
    c = c.offset(1);
    *fresh14 = (if i & (1 as libc::c_int) << 8 as libc::c_int != 0 {
        'C' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh15 = c;
    c = c.offset(1);
    *fresh15 = (if i & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        'N' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh16 = c;
    c = c.offset(1);
    *fresh16 = (if i & (1 as libc::c_int) << 6 as libc::c_int != 0 {
        'S' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh17 = c;
    c = c.offset(1);
    *fresh17 = (if i & (1 as libc::c_int) << 1 as libc::c_int != 0 {
        'c' as i32
    } else if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 28 as libc::c_int != 0 {
        't' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh18 = c;
    c = c.offset(1);
    *fresh18 = (if i & (1 as libc::c_int) << 0 as libc::c_int != 0 {
        'l' as i32
    } else if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int != 0 {
        'v' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh19 = c;
    c = c.offset(1);
    *fresh19 = (if i & (1 as libc::c_int) << 2 as libc::c_int != 0 {
        's' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh20 = c;
    c = c.offset(1);
    *fresh20 = (if i & (1 as libc::c_int) << 5 as libc::c_int != 0 {
        'a' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh21 = c;
    c = c.offset(1);
    *fresh21 = (if i & (1 as libc::c_int) << 3 as libc::c_int != 0 {
        'u' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh22 = c;
    c = c.offset(1);
    *fresh22 = (if i & (1 as libc::c_int) << 4 as libc::c_int != 0 {
        'b' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh23 = c;
    c = c.offset(1);
    *fresh23 = (if i as libc::c_long & (1 as libc::c_int as libc::c_long) << 29 as libc::c_int != 0
    {
        'r' as i32
    } else {
        ' ' as i32
    }) as libc::c_char;
    let fresh24 = c;
    c = c.offset(1);
    *fresh24 = 0 as libc::c_int as libc::c_char;
    ii = (ii + 1 as libc::c_int) % 4 as libc::c_int;
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn ValidateBlackFrames(
    mut reason: libc::c_long,
    mut ratio: libc::c_double,
    mut remove: libc::c_int,
) -> libc::c_double {
    let mut i: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut last: libc::c_int = 0;
    let mut prev_cause: libc::c_int = 0;
    let mut strict_count: libc::c_int = 0 as libc::c_int;
    let mut negative_count: libc::c_int = 0 as libc::c_int;
    let mut positive_count: libc::c_int = 0 as libc::c_int;
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut total_cause: libc::c_int = 0;
    let mut length: libc::c_double = 0.;
    let mut summed_length: libc::c_double = 0.;
    let mut incommercial: libc::c_int = 0;
    let mut r: *mut libc::c_char =
        b" -undefined- \0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    if reason == ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long {
        r = b"Black Frame  \0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if reason == (1 as libc::c_int as libc::c_long) << 18 as libc::c_int {
        r = b"Volume       \0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if reason == ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_long {
        r = b"Scene Change \0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if reason == ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_long {
        r = b"Change       \0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if reason == ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_long {
        r = b"Uniform Frame\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if reason == ((1 as libc::c_int) << 5 as libc::c_int) as libc::c_long {
        r = b"Aspect Ratio \0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if reason == (1 as libc::c_int as libc::c_long) << 28 as libc::c_int {
        r = b"Cut Scene    \0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if reason == ((1 as libc::c_int) << 0 as libc::c_int) as libc::c_long {
        r = b"Logo         \0" as *const u8 as *const libc::c_char as *mut libc::c_char;
    }
    if ratio == 0.0f64 {
        return 0.0f64;
    }
    incommercial = 0 as libc::c_int;
    i = 0 as libc::c_int;
    strict_count = 0 as libc::c_int;
    count = 0 as libc::c_int;
    last = 0 as libc::c_int;
    length = 0.0f64;
    summed_length = 0.0f64;
    while (i as libc::c_long) < black_count {
        while (i as libc::c_long) < black_count
            && (*black.offset(i as isize)).cause as libc::c_long & reason
                == 0 as libc::c_int as libc::c_long
        {
            i += 1;
        }
        k = i;
        while (k as libc::c_long) < black_count
            && (*black.offset((k + 1 as libc::c_int) as isize)).cause as libc::c_long & reason
                != 0 as libc::c_int as libc::c_long
            && (*black.offset((k + 1 as libc::c_int) as isize)).frame
                == (*black.offset(k as isize)).frame + 1 as libc::c_int as libc::c_long
        {
            k += 1;
        }
        if (i as libc::c_long) < black_count {
            length = (if !frame.is_null() {
                (if (*black.offset(((i + k) / 2 as libc::c_int) as isize)).frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*black.offset(((i + k) / 2 as libc::c_int) as isize)).frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(
                            (*black.offset(((i + k) / 2 as libc::c_int) as isize)).frame as isize,
                        ))
                        .pts
                    })
                })
            } else {
                (*black.offset(((i + k) / 2 as libc::c_int) as isize)).frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if (*black.offset(last as isize)).frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*black.offset(last as isize)).frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((*black.offset(last as isize)).frame as isize)).pts
                    })
                })
            } else {
                (*black.offset(last as isize)).frame as libc::c_double / fps
            });
            if length > max_commercial_size {
                if incommercial != 0 {
                    incommercial = 0 as libc::c_int;
                    if summed_length < min_commercialbreak
                        && summed_length > 4.7f64
                        && (*black.offset(((i + k) / 2 as libc::c_int) as isize)).frame
                            < frame_count * 6 as libc::c_int as libc::c_long
                                / 7 as libc::c_int as libc::c_long
                        && (*black.offset(last as isize)).frame
                            > frame_count * 1 as libc::c_int as libc::c_long
                                / 7 as libc::c_int as libc::c_long
                    {
                        negative_count += 1;
                        Debug(
                            10 as libc::c_int,
                            b"Negative %s cutpoint at %6i, commercial too short\n\0" as *const u8
                                as *const libc::c_char
                                as *mut libc::c_char,
                            r,
                            (*black.offset(last as isize)).frame,
                        );
                    } else {
                        positive_count += 1;
                    }
                    summed_length = 0.0f64;
                } else {
                    positive_count += 1;
                }
                summed_length = 0.0f64;
            } else {
                summed_length += length;
                if incommercial != 0 && summed_length > max_commercialbreak {
                    if (*black.offset(((i + k) / 2 as libc::c_int) as isize)).frame
                        < frame_count * 6 as libc::c_int as libc::c_long
                            / 7 as libc::c_int as libc::c_long
                    {
                        negative_count += 1;
                        Debug(
                            10 as libc::c_int,
                            b"Negative %s cutpoint at %6i, commercial too long\n\0" as *const u8
                                as *const libc::c_char
                                as *mut libc::c_char,
                            r,
                            (*black.offset(((i + k) / 2 as libc::c_int) as isize)).frame,
                        );
                    }
                } else {
                    positive_count += 1;
                    incommercial = 1 as libc::c_int;
                }
            }
        }
        last = (i + k) / 2 as libc::c_int;
        i = k + 1 as libc::c_int;
    }
    Debug(
        1 as libc::c_int,
        b"Distribution of %s cutting: %3i positive and %3i negative, ratio is %6.4f\n\0"
            as *const u8 as *const libc::c_char as *mut libc::c_char,
        r,
        positive_count,
        negative_count,
        if negative_count > 0 as libc::c_int {
            positive_count as libc::c_double / negative_count as libc::c_double
        } else {
            9.99f64
        },
    );
    if (logoPercentage < logo_fraction || logoPercentage > logo_percentile)
        && negative_count > 1 as libc::c_int
    {
        Debug(
            1 as libc::c_int,
            b"Confidence of %s cutting: %3i negative without good logo is too much\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            r,
            negative_count,
        );
        if remove != 0 {
            k = (black_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
            while k >= 0 as libc::c_int {
                if (*black.offset(k as isize)).cause as libc::c_long & reason != 0 {
                    let ref mut fresh25 = (*black.offset(k as isize)).cause;
                    *fresh25 = (*fresh25 as libc::c_long & !reason) as libc::c_int;
                    if (*black.offset(k as isize)).cause == 0 as libc::c_int {
                        j = k;
                        while (j as libc::c_long) < black_count - 1 as libc::c_int as libc::c_long {
                            *black.offset(j as isize) =
                                *black.offset((j + 1 as libc::c_int) as isize);
                            j += 1;
                        }
                        black_count -= 1;
                    }
                }
                k -= 1;
            }
        }
    }
    i = 1 as libc::c_int;
    strict_count = 0 as libc::c_int;
    count = 0 as libc::c_int;
    prev_cause = 0 as libc::c_int;
    while (i as libc::c_long) < black_count {
        total_cause = (*black.offset(i as isize)).cause;
        k = i;
        while (k as libc::c_long) < black_count
            && (*black.offset((k + 1 as libc::c_int) as isize)).frame
                == (*black.offset(k as isize)).frame + 1 as libc::c_int as libc::c_long
        {
            k += 1;
            total_cause |= (*black.offset(k as isize)).cause;
        }
        last = (i + k) / 2 as libc::c_int;
        if total_cause as libc::c_long & reason != 0 && prev_cause as libc::c_long & reason != 0 {
            j = i - 1 as libc::c_int;
            while j > 0 as libc::c_int
                && (*black.offset((j - 1 as libc::c_int) as isize)).frame
                    == (*black.offset(j as isize)).frame - 1 as libc::c_int as libc::c_long
            {
                j -= 1;
            }
            length = (if !frame.is_null() {
                (if (*black.offset(i as isize)).frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*black.offset(i as isize)).frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((*black.offset(i as isize)).frame as isize)).pts
                    })
                })
            } else {
                (*black.offset(i as isize)).frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if (*black.offset(((i - 1 as libc::c_int + j) / 2 as libc::c_int) as isize)).frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*black.offset(((i - 1 as libc::c_int + j) / 2 as libc::c_int) as isize))
                        .frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(
                            (*black
                                .offset(((i - 1 as libc::c_int + j) / 2 as libc::c_int) as isize))
                            .frame as isize,
                        ))
                        .pts
                    })
                })
            } else {
                (*black.offset(((i - 1 as libc::c_int + j) / 2 as libc::c_int) as isize)).frame
                    as libc::c_double
                    / fps
            });
            if length > 1.0f64 && length < max_commercial_size {
                count += 1;
                if IsStandardCommercialLength(
                    length,
                    (if !frame.is_null() {
                        (if i <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if i >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(i as isize)).pts
                            })
                        })
                    } else {
                        i as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if j <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if j >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(j as isize)).pts
                            })
                        })
                    } else {
                        j as libc::c_double / fps
                    }) + 0.8f64,
                    0 as libc::c_int != 0,
                ) {
                    strict_count += 1;
                }
            }
        }
        prev_cause = reason as libc::c_int;
        k += 1;
        i = k;
    }
    if strict_count < 2 as libc::c_int
        || ((100 as libc::c_int * strict_count) as libc::c_double)
            < (100 as libc::c_int * count) as libc::c_double / ratio
    {
        Debug(
            1 as libc::c_int,
            b"Confidence of %s cutting: %3i out of %3i are strict, too low\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            r,
            strict_count,
            count,
        );
        if remove != 0 {
            k = (black_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
            while k >= 0 as libc::c_int {
                if (*black.offset(k as isize)).cause as libc::c_long & reason != 0 {
                    let ref mut fresh26 = (*black.offset(k as isize)).cause;
                    *fresh26 = (*fresh26 as libc::c_long & !reason) as libc::c_int;
                    if (*black.offset(k as isize)).cause == 0 as libc::c_int {
                        j = k;
                        while (j as libc::c_long) < black_count - 1 as libc::c_int as libc::c_long {
                            *black.offset(j as isize) =
                                *black.offset((j + 1 as libc::c_int) as isize);
                            j += 1;
                        }
                        black_count -= 1;
                    }
                }
                k -= 1;
            }
        }
    } else {
        Debug(
            1 as libc::c_int,
            b"Confidence of %s cutting: %3i out of %3i are strict\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            r,
            strict_count,
            count,
        );
    }
    return if count > 0 as libc::c_int {
        strict_count as libc::c_double / count as libc::c_double
    } else {
        0 as libc::c_int as libc::c_double
    };
}
#[no_mangle]
pub unsafe extern "C" fn BuildBlocks(mut recalc: bool) -> bool {
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut k: libc::c_int = 0 as libc::c_int;
    let mut a: libc::c_int = 0 as libc::c_int;
    let mut count: libc::c_int = 0;
    let mut v_count: libc::c_int = 0;
    let mut b_count: libc::c_int = 0;
    let mut black_start: libc::c_int = 0;
    let mut black_end: libc::c_int = 0;
    let mut cause: libc::c_int = 0 as libc::c_int;
    let mut black_threshold: libc::c_int = 0;
    let mut uniform_threshold: libc::c_int = 0;
    let mut prev_start: libc::c_int = 1 as libc::c_int;
    let mut prev_head: libc::c_int = 0 as libc::c_int;
    let mut b_start: libc::c_long = 0;
    let mut b_end: libc::c_long = 0;
    let mut b_counted: libc::c_long = 0;
    max_block_count = 1000 as libc::c_int as libc::c_long;
    block_count = 0 as libc::c_int as libc::c_long;
    recalculate = recalc as libc::c_int;
    InitializeBlockArray(0 as libc::c_int as libc::c_long);
    if !recalc {
        if intelligent_brightness {
            OutputbrightHistogram();
            black_threshold = FindBlackThreshold(black_percentile);
            max_avg_brightness = black_threshold;
            Debug(
                1 as libc::c_int,
                b"Setting brightness threshold to %i\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                black_threshold,
            );
        }
        if intelligent_brightness as libc::c_int != 0 && non_uniformity > 0 as libc::c_int {
            OutputuniformHistogram();
            uniform_threshold = FindUniformThreshold(uniform_percentile);
            non_uniformity = uniform_threshold;
            Debug(
                1 as libc::c_int,
                b"Setting uniform threshold to %i\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                uniform_threshold,
            );
            if commDetectMethod & 1 as libc::c_int != 0 {
                i = 1 as libc::c_int;
                while (i as libc::c_long) < frame_count {
                    let ref mut fresh27 = (*frame.offset(i as isize)).isblack;
                    *fresh27 =
                        (*fresh27 as libc::c_int & !((1 as libc::c_int) << 3 as libc::c_int)) != 0;
                    if non_uniformity > 0 as libc::c_int
                        && (*frame.offset(i as isize)).uniform < non_uniformity
                        && (*frame.offset(i as isize)).brightness < 250 as libc::c_int
                    {
                        InsertBlackFrame(
                            i,
                            (*frame.offset(i as isize)).brightness,
                            (*frame.offset(i as isize)).uniform,
                            (*frame.offset(i as isize)).volume,
                            (1 as libc::c_int) << 3 as libc::c_int,
                        );
                    }
                    i += 1;
                }
            }
        }
    }
    j = 0 as libc::c_int;
    i = 2 as libc::c_int;
    while (i as libc::c_long) < frame_count - 1 as libc::c_int as libc::c_long {
        if (*frame.offset((i - 1 as libc::c_int) as isize)).volume != -(1 as libc::c_int)
            && (*frame.offset(i as isize)).volume == -(1 as libc::c_int)
            && (*frame.offset((i + 1 as libc::c_int) as isize)).volume != -(1 as libc::c_int)
        {
            j += 1;
        }
        i += 1;
    }
    if j > 0 as libc::c_int {
        Debug(
            9 as libc::c_int,
            b"Single frames with missing audio: %d\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            j,
        );
    }
    if non_uniformity < min_uniform + 100 as libc::c_int {
        non_uniformity = min_uniform + 100 as libc::c_int;
    }
    if framearray {
        k = (black_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        while k >= 0 as libc::c_int {
            if (*black.offset(k as isize)).cause == (1 as libc::c_int) << 2 as libc::c_int
                || (*black.offset(k as isize)).cause == (1 as libc::c_int) << 1 as libc::c_int
                || (*black.offset(k as isize)).cause
                    == (1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int
            {
                i = ((*black.offset(k as isize)).frame - volume_slip as libc::c_long)
                    as libc::c_int;
                if i < 0 as libc::c_int {
                    i = 0 as libc::c_int;
                }
                j = ((*black.offset(k as isize)).frame + volume_slip as libc::c_long)
                    as libc::c_int;
                if j as libc::c_long > frame_count {
                    j = frame_count as libc::c_int;
                }
                count = 0 as libc::c_int;
                a = i;
                while a < j {
                    if (*frame.offset(a as isize)).volume < max_volume / 4 as libc::c_int {
                        count += volume_slip;
                    } else if (*frame.offset(a as isize)).volume < max_volume {
                        count += 1;
                    }
                    a += 1;
                }
                if count > volume_slip / 4 as libc::c_int {
                    (*black.offset(k as isize)).volume = max_volume / 2 as libc::c_int;
                } else {
                    (*black.offset(k as isize)).volume = max_volume * 10 as libc::c_int;
                }
            } else {
                i = ((*black.offset(k as isize)).frame - volume_slip as libc::c_long)
                    as libc::c_int;
                if i < 0 as libc::c_int {
                    i = 0 as libc::c_int;
                }
                j = ((*black.offset(k as isize)).frame + volume_slip as libc::c_long)
                    as libc::c_int;
                if j as libc::c_long > frame_count {
                    j = frame_count as libc::c_int;
                }
                a = i;
                while a < j {
                    if (*frame.offset(a as isize)).volume >= 0 as libc::c_int {
                        if (*black.offset(k as isize)).volume > (*frame.offset(a as isize)).volume {
                            (*black.offset(k as isize)).volume = (*frame.offset(a as isize)).volume;
                        }
                    }
                    a += 1;
                }
            }
            k -= 1;
        }
        k = (ar_block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        while k >= 0 as libc::c_int {
            i = (*ar_block.offset(k as isize)).end - volume_slip;
            if i < 0 as libc::c_int {
                i = 0 as libc::c_int;
            }
            j = (*ar_block.offset(k as isize)).end + volume_slip;
            if j as libc::c_long > frame_count {
                j = frame_count as libc::c_int;
            }
            (*ar_block.offset(k as isize)).volume = (*frame.offset(i as isize)).volume;
            a = i;
            while a < j {
                if (*frame.offset(a as isize)).volume >= 0 as libc::c_int {
                    if (*ar_block.offset(k as isize)).volume > (*frame.offset(a as isize)).volume {
                        (*ar_block.offset(k as isize)).volume = (*frame.offset(a as isize)).volume;
                        (*ar_block.offset(k as isize)).end = a;
                        if (k as libc::c_long) < ar_block_count - 1 as libc::c_int as libc::c_long {
                            (*ar_block.offset((k + 1 as libc::c_int) as isize)).start = a;
                        }
                    }
                }
                a += 1;
            }
            k -= 1;
        }
    }
    k = 1 as libc::c_int;
    while k < 255 as libc::c_int {
        if volumeHistogram[k as usize] > 10 as libc::c_int {
            min_volume = (k - 1 as libc::c_int) * volumeScale;
            break;
        } else {
            k += 1;
        }
    }
    k = 1 as libc::c_int;
    while k < 255 as libc::c_int {
        if uniformHistogram[k as usize] > 10 as libc::c_int {
            min_uniform = (k - 1 as libc::c_int) * 100 as libc::c_int;
            break;
        } else {
            k += 1;
        }
    }
    k = 0 as libc::c_int;
    while k < 255 as libc::c_int {
        if brightHistogram[k as usize] > 1 as libc::c_int {
            min_brightness_found = k;
            break;
        } else {
            k += 1;
        }
    }
    if max_volume > 0 as libc::c_int {
        k = (black_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        while k >= 0 as libc::c_int {
            if !((*black.offset(k as isize)).cause as libc::c_long
                & (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                != 0 as libc::c_int as libc::c_long)
            {
                if (*black.offset(k as isize)).volume > max_volume {
                    Debug(
                        12 as libc::c_int,
                        b"%i - Removing black frame %i, from black frame list because volume %i is more than %i, brightness %i, uniform %i\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        k,
                        (*black.offset(k as isize)).frame,
                        (*black.offset(k as isize)).volume,
                        max_volume,
                        (*black.offset(k as isize)).brightness,
                        (*black.offset(k as isize)).uniform,
                    );
                    j = k;
                    while (j as libc::c_long) < black_count - 1 as libc::c_int as libc::c_long {
                        *black.offset(j as isize) = *black.offset((j + 1 as libc::c_int) as isize);
                        j += 1;
                    }
                    black_count -= 1;
                }
            }
            k -= 1;
        }
    }
    k = (black_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
    while k >= 0 as libc::c_int {
        if !((*black.offset(k as isize)).cause as libc::c_long
            & (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
            != 0 as libc::c_int as libc::c_long)
        {
            if !((*black.offset(k as isize)).cause as libc::c_long
                & (1 as libc::c_int as libc::c_long) << 29 as libc::c_int
                != 0 as libc::c_int as libc::c_long)
            {
                if (*black.offset(k as isize)).cause & (1 as libc::c_int) << 4 as libc::c_int != 0
                    && (*black.offset(k as isize)).brightness > max_avg_brightness
                {
                    Debug(
                        12 as libc::c_int,
                        b"%i - Removing black frame %i, from black frame list because %i is more than %i, uniform %i\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        k,
                        (*black.offset(k as isize)).frame,
                        (*black.offset(k as isize)).brightness,
                        max_avg_brightness,
                        (*black.offset(k as isize)).uniform,
                    );
                    j = k;
                    while (j as libc::c_long) < black_count - 1 as libc::c_int as libc::c_long {
                        *black.offset(j as isize) = *black.offset((j + 1 as libc::c_int) as isize);
                        j += 1;
                    }
                    black_count -= 1;
                }
            }
        }
        k -= 1;
    }
    if non_uniformity > 0 as libc::c_int {
        k = (black_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        while k >= 0 as libc::c_int {
            if !((*black.offset(k as isize)).cause as libc::c_long
                & (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                != 0 as libc::c_int as libc::c_long)
            {
                if (*black.offset(k as isize)).cause & (1 as libc::c_int) << 3 as libc::c_int != 0
                    && (*black.offset(k as isize)).uniform > non_uniformity as libc::c_long
                {
                    Debug(
                        12 as libc::c_int,
                        b"%i - Removing uniform frame %i, from black frame list because %i is more than %i, brightness %i\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        k,
                        (*black.offset(k as isize)).frame,
                        (*black.offset(k as isize)).uniform,
                        non_uniformity,
                        (*black.offset(k as isize)).brightness,
                    );
                    j = k;
                    while (j as libc::c_long) < black_count - 1 as libc::c_int as libc::c_long {
                        *black.offset(j as isize) = *black.offset((j + 1 as libc::c_int) as isize);
                        j += 1;
                    }
                    black_count -= 1;
                }
            }
            k -= 1;
        }
    }
    if cut_on_ar_change == 2 as libc::c_int {
        if logoPercentage > logo_fraction && logoPercentage < logo_percentile {
            cut_on_ar_change = 1 as libc::c_int;
        }
    }
    cut_on_ar_change == 1 as libc::c_int;
    if commDetectMethod & 2 as libc::c_int != 0 && cut_on_ar_change != 0
        || cut_on_ar_change >= 2 as libc::c_int
    {
        i = 0 as libc::c_int;
        while (i as libc::c_long) < ar_block_count {
            if (cut_on_ar_change == 1 as libc::c_int
                || (*ar_block.offset(i as isize)).volume < max_volume)
                && (*ar_block.offset(i as isize)).ar_ratio != 0.0f64
                && (*ar_block.offset((i + 1 as libc::c_int) as isize)).ar_ratio != 0.0f64
            {
                a = (*ar_block.offset(i as isize)).end;
                InsertBlackFrame(
                    a,
                    (*frame.offset(a as isize)).brightness,
                    (*frame.offset(a as isize)).uniform,
                    (*frame.offset(a as isize)).volume,
                    (1 as libc::c_int) << 5 as libc::c_int,
                );
            }
            i += 1;
        }
    }
    if cut_on_ac_change != 0 {
        i = 0 as libc::c_int;
        while (i as libc::c_long) < ac_block_count {
            a = (*ac_block.offset(i as isize)).end;
            InsertBlackFrame(
                a,
                (*frame.offset(a as isize)).brightness,
                (*frame.offset(a as isize)).uniform,
                (*frame.offset(a as isize)).volume,
                ((1 as libc::c_int as libc::c_long) << 29 as libc::c_int) as libc::c_int,
            );
            i += 1;
        }
    }
    if ValidateBlackFrames(
        ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long,
        3.0f64,
        0 as libc::c_int,
    ) < 1 as libc::c_int as libc::c_double / 3.0f64
    {
        Debug(
            8 as libc::c_int,
            b"Black Frame cutting too low\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
    }
    if validate_scenechange != 0 {
        ValidateBlackFrames(
            ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_long,
            if logoPercentage < logo_fraction || logoPercentage > logo_percentile {
                1.2f64
            } else {
                3.5f64
            },
            1 as libc::c_int,
        );
    }
    if validate_uniform != 0 {
        ValidateBlackFrames(
            ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_long,
            if logoPercentage < logo_fraction || logoPercentage > logo_percentile {
                1.2f64
            } else {
                3.0f64
            },
            1 as libc::c_int,
        );
    }
    if commDetectMethod & 64 as libc::c_int != 0 {
        k = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while (i as libc::c_long) < frame_count {
            if (*frame.offset(i as isize)).volume < max_volume {
                k += 1;
            }
            i += 1;
        }
        if validate_silence != 0 {
            ValidateBlackFrames(
                (1 as libc::c_int as libc::c_long) << 18 as libc::c_int,
                3.0f64,
                1 as libc::c_int,
            );
        }
    }
    Debug(
        8 as libc::c_int,
        b"Black Frame List\n---------------------------\nBlack Frame Count = %i\nnr \tframe\tpts\tbright\tuniform\tvolume\t\tcause\tdimcount  bright   type\n\0"
            as *const u8 as *const libc::c_char as *mut libc::c_char,
        black_count,
    );
    k = 0 as libc::c_int;
    while (k as libc::c_long) < black_count {
        Debug(
            8 as libc::c_int,
            b"%3i\t%6i\t%8.3f\t%6i\t%6i\t%6i\t%6s\t%6i\t%6i\t%c\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            k,
            (*black.offset(k as isize)).frame,
            get_frame_pts((*black.offset(k as isize)).frame as libc::c_int),
            (*black.offset(k as isize)).brightness,
            (*black.offset(k as isize)).uniform,
            (*black.offset(k as isize)).volume,
            &mut *((CauseString as unsafe extern "C" fn(libc::c_int) -> *mut libc::c_char)(
                (*black.offset(k as isize)).cause,
            ))
            .offset(10 as libc::c_int as isize) as *mut libc::c_char,
            (*frame.offset((*black.offset(k as isize)).frame as isize)).dimCount,
            (*frame.offset((*black.offset(k as isize)).frame as isize)).hasBright,
            (*frame.offset((*black.offset(k as isize)).frame as isize)).pict_type as libc::c_int,
        );
        if ((k + 1 as libc::c_int) as libc::c_long) < black_count
            && (*black.offset(k as isize)).frame + 1 as libc::c_int as libc::c_long
                != (*black.offset((k + 1 as libc::c_int) as isize)).frame
        {
            Debug(
                8 as libc::c_int,
                b"-----------------------------\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
        }
        k += 1;
    }
    InsertBlackFrame(
        framesprocessed,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        (1 as libc::c_int) << 4 as libc::c_int,
    );
    i = 0 as libc::c_int;
    j = 0 as libc::c_int;
    a = ar_block_count as libc::c_int;
    cause = 0 as libc::c_int;
    block_count = 0 as libc::c_int as libc::c_long;
    prev_start = 1 as libc::c_int;
    prev_head = 0 as libc::c_int;
    while (i as libc::c_long) < black_count || (a as libc::c_long) < ar_block_count {
        commDetectMethod & 2 as libc::c_int == 0
            && (i as libc::c_long) < black_count
            && (*black.offset(i as isize)).cause
                & ((1 as libc::c_int) << 2 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int)
                != 0;
        cause = 0 as libc::c_int;
        b_start = (*black.offset(i as isize)).frame;
        cause |= (*black.offset(i as isize)).cause;
        b_end = b_start;
        j = i + 1 as libc::c_int;
        v_count = 0 as libc::c_int;
        b_count = 0 as libc::c_int;
        black_start = 0 as libc::c_int;
        black_end = 0 as libc::c_int;
        while (j as libc::c_long) < black_count
            && (if !frame.is_null() {
                (if (*black.offset(j as isize)).frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*black.offset(j as isize)).frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((*black.offset(j as isize)).frame as isize)).pts
                    })
                })
            } else {
                (*black.offset(j as isize)).frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if b_end <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if b_end >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(b_end as isize)).pts
                    })
                })
            } else {
                b_end as libc::c_double / fps
            }) < 1.0f64
        {
            if (*black.offset(j as isize)).frame - b_end > 2 as libc::c_int as libc::c_long
                && ((*black.offset(j as isize)).cause as libc::c_long
                    & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                    != 0 as libc::c_int as libc::c_long
                    && cause as libc::c_long
                        & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                        == 0 as libc::c_int as libc::c_long
                    || (*black.offset(j as isize)).cause as libc::c_long
                        & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                        == 0 as libc::c_int as libc::c_long
                        && cause as libc::c_long
                            & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                            != 0 as libc::c_int as libc::c_long)
            {
                Debug(
                    6 as libc::c_int,
                    b"At frame %i there is a gap of %i frames in the blackframe list\n\0"
                        as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    (*black.offset(j as isize)).frame,
                    (*black.offset(j as isize)).frame - b_end,
                );
            }
            if (*black.offset(j as isize)).cause as libc::c_long
                & (((1 as libc::c_int) << 4 as libc::c_int
                    | (1 as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 3 as libc::c_int) as libc::c_long
                    | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                != 0 as libc::c_int as libc::c_long
            {
                b_count += 1;
                if black_start == 0 as libc::c_int {
                    black_start = (*black.offset(j as isize)).frame as libc::c_int;
                }
                black_end = (*black.offset(j as isize)).frame as libc::c_int;
            }
            if (*black.offset(j as isize)).cause as libc::c_long
                & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                != 0 as libc::c_int as libc::c_long
            {
                v_count += 1;
            }
            if (*black.offset(j as isize)).cause == (1 as libc::c_int) << 5 as libc::c_int {
                cause |= (*black.offset(j as isize)).cause;
                j += 1;
            } else if cause == (1 as libc::c_int) << 5 as libc::c_int {
                cause |= (*black.offset(j as isize)).cause;
                let fresh28 = j;
                j = j + 1;
                b_end = (*black.offset(fresh28 as isize)).frame;
                b_start = b_end;
            } else {
                cause |= (*black.offset(j as isize)).cause;
                let fresh29 = j;
                j = j + 1;
                b_end = (*black.offset(fresh29 as isize)).frame;
            }
        }
        i = j;
        if b_count > 0 as libc::c_int
            && v_count as libc::c_double > 1.5f64 * b_count as libc::c_double
        {
            b_start = black_start as libc::c_long;
            b_end = black_end as libc::c_long;
            b_counted = b_count as libc::c_long;
        } else if b_count == 0 as libc::c_int && v_count > 5 as libc::c_int {
            b_start = b_start - 1 as libc::c_int as libc::c_long
                + (v_count / 2 as libc::c_int) as libc::c_long;
            b_end = b_end + 1 as libc::c_int as libc::c_long
                - (v_count / 2 as libc::c_int) as libc::c_long;
            b_counted = 3 as libc::c_int as libc::c_long;
        }
        cblock[block_count as usize].cause = cause;
        b_counted =
            (b_end - b_start + 1 as libc::c_int as libc::c_long) / 2 as libc::c_int as libc::c_long;
        cblock[block_count as usize].b_head = prev_head as libc::c_uint;
        cblock[block_count as usize].f_start = (prev_start as libc::c_uint)
            .wrapping_sub(cblock[block_count as usize].b_head)
            as libc::c_long;
        if b_end == framesprocessed as libc::c_long {
            cblock[block_count as usize].f_end = framesprocessed as libc::c_long;
        } else {
            cblock[block_count as usize].f_end =
                b_start + b_counted - 1 as libc::c_int as libc::c_long;
        }
        cblock[block_count as usize].b_tail = b_counted as libc::c_uint;
        cblock[block_count as usize].bframe_count =
            (cblock[block_count as usize].b_head).wrapping_add(cblock[block_count as usize].b_tail);
        cblock[block_count as usize].length = (if !frame.is_null() {
            (if cblock[block_count as usize].f_end <= 0 as libc::c_int as libc::c_long {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if cblock[block_count as usize].f_end >= framenum_real as libc::c_long {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(cblock[block_count as usize].f_end as isize)).pts
                })
            })
        } else {
            cblock[block_count as usize].f_end as libc::c_double / fps
        }) - (if !frame.is_null() {
            (if cblock[block_count as usize].f_start <= 0 as libc::c_int as libc::c_long {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if cblock[block_count as usize].f_start >= framenum_real as libc::c_long {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(cblock[block_count as usize].f_start as isize)).pts
                })
            })
        } else {
            cblock[block_count as usize].f_start as libc::c_double / fps
        });
        if block_count > 0 as libc::c_int as libc::c_long
            || (if !frame.is_null() {
                (if cblock[block_count as usize].f_end <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[block_count as usize].f_end >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[block_count as usize].f_end as isize)).pts
                    })
                })
            } else {
                cblock[block_count as usize].f_end as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if cblock[block_count as usize].f_start <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[block_count as usize].f_start >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[block_count as usize].f_start as isize)).pts
                    })
                })
            } else {
                cblock[block_count as usize].f_start as libc::c_double / fps
            }) > 1.0f64
            || cblock[block_count as usize].f_end == framesprocessed as libc::c_long
        {
            Debug(
                12 as libc::c_int,
                b"Creating cblock %i From %i (%i) to %i (%i) because of %s with %i head and %i tail\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                block_count,
                cblock[block_count as usize].f_start,
                cblock[block_count as usize].f_start
                    + cblock[block_count as usize].b_head as libc::c_long,
                cblock[block_count as usize].f_end,
                cblock[block_count as usize].f_end
                    - cblock[block_count as usize].b_tail as libc::c_long,
                CauseString(cause),
                cblock[block_count as usize].b_head,
                cblock[block_count as usize].b_tail,
            );
            block_count += 1;
            InitializeBlockArray(block_count);
            prev_start = (b_end + 1 as libc::c_int as libc::c_long) as libc::c_int;
            prev_head =
                (b_end - b_start - b_counted + 1 as libc::c_int as libc::c_long) as libc::c_int;
        }
    }
    i = (block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
    while i >= 1 as libc::c_int {
        let mut bfcount: libc::c_uint = (cblock[i as usize].b_head)
            .wrapping_add(cblock[(i - 1 as libc::c_int) as usize].b_tail);
        if bfcount < min_black_frames_for_break
            && cblock[(i - 1 as libc::c_int) as usize].cause
                == (1 as libc::c_int) << 4 as libc::c_int
        {
            Debug(
                10 as libc::c_int,
                b"Combining blocks %i and %i at %i because there are only %i black frames separating them.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i - 1 as libc::c_int,
                i,
                cblock[(i - 1 as libc::c_int) as usize].f_end,
                bfcount,
            );
            cblock[(i - 1 as libc::c_int) as usize].f_end = cblock[i as usize].f_end;
            cblock[(i - 1 as libc::c_int) as usize].b_tail = cblock[i as usize].b_tail;
            cblock[(i - 1 as libc::c_int) as usize].length = (if !frame.is_null() {
                (if cblock[(i - 1 as libc::c_int) as usize].f_end
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[(i - 1 as libc::c_int) as usize].f_end
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[(i - 1 as libc::c_int) as usize].f_end as isize)).pts
                    })
                })
            } else {
                cblock[(i - 1 as libc::c_int) as usize].f_end as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if cblock[(i - 1 as libc::c_int) as usize].f_start
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[(i - 1 as libc::c_int) as usize].f_start
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[(i - 1 as libc::c_int) as usize].f_start as isize))
                            .pts
                    })
                })
            } else {
                cblock[(i - 1 as libc::c_int) as usize].f_start as libc::c_double / fps
            });
            cblock[(i - 1 as libc::c_int) as usize].cause = cblock[i as usize].cause;
            k = i;
            while (k as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long {
                cblock[k as usize] = cblock[(k + 1 as libc::c_int) as usize];
                k += 1;
            }
            block_count -= 1;
        }
        i -= 1;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn FindLogoThreshold() {
    let mut i: libc::c_int = 0;
    let mut buckets: libc::c_int = 20 as libc::c_int;
    let mut counter: libc::c_int = 0 as libc::c_int;
    if framearray {
        i = 1 as libc::c_int;
        while (i as libc::c_long) < frame_count {
            logoHistogram[((*frame.offset(i as isize)).currentGoodEdge
                * (buckets - 1 as libc::c_int) as libc::c_double)
                as libc::c_int as usize] += 1;
            i += 1 as libc::c_int;
        }
        OutputLogoHistogram(buckets);
        counter = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < buckets {
            counter += logoHistogram[i as usize];
            if (100 as libc::c_int * counter) as libc::c_long / frame_count
                > 40 as libc::c_int as libc::c_long
            {
                break;
            }
            i += 1;
        }
        if i < buckets / 2 as libc::c_int {
            i = buckets * 3 as libc::c_int / 4 as libc::c_int;
        } else {
            if logoHistogram[(i - 2 as libc::c_int) as usize] < logoHistogram[i as usize] {
                i -= 2 as libc::c_int;
            }
            if logoHistogram[(i - 1 as libc::c_int) as usize] < logoHistogram[i as usize] {
                i -= 1 as libc::c_int;
            }
            if logoHistogram[(i - 1 as libc::c_int) as usize] < logoHistogram[i as usize] {
                i -= 1 as libc::c_int;
            }
            if logoHistogram[(i - 1 as libc::c_int) as usize] < logoHistogram[i as usize] {
                i -= 1 as libc::c_int;
            }
        }
        logo_quality = (i as libc::c_double + 0.5f64) / buckets as libc::c_double;
        Debug(
            8 as libc::c_int,
            b"Set Logo Quality = %.5f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            logo_quality,
        );
    }
    if logo_threshold == 0 as libc::c_int as libc::c_double {
        logo_threshold = logo_quality;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CleanLogoBlocks() {
    let mut i: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut sum_brightness_0: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut sum_volume: libc::c_int = 0;
    let mut s: libc::c_int = 0;
    let mut sum_silence: libc::c_int = 0;
    let mut sum_uniform: libc::c_int = 0;
    let mut sum_brightness2: libc::c_double = 0.;
    let mut sum_delta: libc::c_int = 0;
    if commDetectMethod & 2 as libc::c_int != 0
        && !reverseLogoLogic
        && connect_blocks_with_logo as libc::c_int != 0
    {
        i = (block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        while i >= 1 as libc::c_int {
            if CheckFrameForLogo(cblock[(i - 1 as libc::c_int) as usize].f_end as libc::c_int)
                as libc::c_int
                != 0
                && CheckFrameForLogo(cblock[i as usize].f_start as libc::c_int) as libc::c_int != 0
            {
                Debug(
                    6 as libc::c_int,
                    b"Joining blocks %i and %i at frame %i because they both have a logo.\n\0"
                        as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    i - 1 as libc::c_int,
                    i,
                    cblock[(i - 1 as libc::c_int) as usize].f_end,
                );
                cblock[(i - 1 as libc::c_int) as usize].f_end = cblock[i as usize].f_end;
                cblock[(i - 1 as libc::c_int) as usize].b_tail = cblock[i as usize].b_tail;
                if cblock[i as usize].length > cblock[(i - 1 as libc::c_int) as usize].length {
                    cblock[(i - 1 as libc::c_int) as usize].ar_ratio = cblock[i as usize].ar_ratio;
                }
                cblock[(i - 1 as libc::c_int) as usize].length = (if !frame.is_null() {
                    (if cblock[(i - 1 as libc::c_int) as usize].f_end
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[(i - 1 as libc::c_int) as usize].f_end
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(cblock[(i - 1 as libc::c_int) as usize].f_end as isize))
                                .pts
                        })
                    })
                } else {
                    cblock[(i - 1 as libc::c_int) as usize].f_end as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if cblock[(i - 1 as libc::c_int) as usize].f_start
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[(i - 1 as libc::c_int) as usize].f_start
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame
                                .offset(cblock[(i - 1 as libc::c_int) as usize].f_start as isize))
                            .pts
                        })
                    })
                } else {
                    cblock[(i - 1 as libc::c_int) as usize].f_start as libc::c_double / fps
                });
                cblock[(i - 1 as libc::c_int) as usize].cause = cblock[i as usize].cause;
                k = i;
                while (k as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long {
                    cblock[k as usize] = cblock[(k + 1 as libc::c_int) as usize];
                    k += 1;
                }
                block_count -= 1;
            }
            i -= 1;
        }
    }
    k = -(1 as libc::c_int);
    avg_brightness = 0 as libc::c_int as libc::c_long;
    avg_volume = 0 as libc::c_int as libc::c_long;
    maxi_volume = 0 as libc::c_int as libc::c_long;
    avg_silence = 0 as libc::c_int as libc::c_long;
    avg_uniform = 0 as libc::c_int as libc::c_long;
    avg_schange = 0.0f64;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        sum_brightness_0 = 0 as libc::c_int;
        sum_volume = 0 as libc::c_int;
        sum_silence = 0 as libc::c_int;
        sum_uniform = 0 as libc::c_int;
        sum_brightness2 = 0.0f64;
        sum_delta = 0 as libc::c_int;
        if framearray {
            k = (cblock[i as usize].f_start + 1 as libc::c_int as libc::c_long) as libc::c_int;
            while (k as libc::c_long) < cblock[i as usize].f_end {
                b = abs((*frame.offset(k as isize)).brightness
                    - (*frame.offset((k - 1 as libc::c_int) as isize)).brightness);
                v = (*frame.offset(k as isize)).volume;
                if maxi_volume < v as libc::c_long {
                    maxi_volume = v as libc::c_long;
                }
                s = if (*frame.offset(k as isize)).volume < max_volume {
                    0 as libc::c_int
                } else {
                    99 as libc::c_int
                };
                sum_brightness_0 += b;
                sum_volume += v;
                sum_silence += s;
                sum_uniform += abs((*frame.offset(k as isize)).uniform
                    - (*frame.offset((k - 1 as libc::c_int) as isize)).uniform);
                sum_brightness2 += (b * b) as libc::c_double;
                sum_delta += abs((*frame.offset(k as isize)).brightness
                    - (*frame.offset((k - 1 as libc::c_int) as isize)).brightness);
                k += 1;
            }
        }
        n = (cblock[i as usize].f_end - cblock[i as usize].f_start
            + 1 as libc::c_int as libc::c_long) as libc::c_int;
        if n > 0 as libc::c_int {
            cblock[i as usize].brightness = sum_brightness_0 * 1000 as libc::c_int / n;
            cblock[i as usize].volume = sum_volume / n;
            cblock[i as usize].silence = sum_silence / n;
            cblock[i as usize].uniform = sum_uniform / n;
        }
        cblock[i as usize].schange_count = CountSceneChanges(
            cblock[i as usize].f_start as libc::c_int,
            cblock[i as usize].f_end as libc::c_int,
        ) as libc::c_uint;
        if cblock[i as usize].schange_count != 0 {
            cblock[i as usize].schange_rate =
                cblock[i as usize].schange_count as libc::c_double / n as libc::c_double;
        } else {
            cblock[i as usize].schange_rate = 0.0f64;
        }
        cblock[i as usize].stdev = 100 as libc::c_int * sum_delta / n;
        avg_brightness += (sum_brightness_0 * 1000 as libc::c_int) as libc::c_long;
        avg_volume += sum_volume as libc::c_long;
        avg_silence += sum_silence as libc::c_long;
        avg_uniform += sum_uniform as libc::c_long;
        avg_schange += cblock[i as usize].schange_rate * n as libc::c_double;
        i += 1;
    }
    n = (cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
        - cblock[0 as libc::c_int as usize].f_start) as libc::c_int;
    if n > 0 as libc::c_int {
        avg_brightness /= n as libc::c_long;
        avg_volume /= n as libc::c_long;
        avg_silence /= n as libc::c_long;
        avg_uniform /= n as libc::c_long;
        avg_schange /= n as libc::c_double;
    }
}
#[no_mangle]
pub unsafe extern "C" fn InitScanLines() {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < height {
        if i < clogoMinY - 5 as libc::c_int || i > clogoMaxY + 5 as libc::c_int {
            lineStart[i as usize] = border;
            lineEnd[i as usize] = videowidth - 1 as libc::c_int - border;
        } else if clogoMinX > videowidth - clogoMaxX {
            lineStart[i as usize] = border;
            lineEnd[i as usize] = if 0 as libc::c_int > clogoMinX - 5 as libc::c_int {
                0 as libc::c_int
            } else {
                clogoMinX - 5 as libc::c_int
            };
        } else {
            lineStart[i as usize] =
                if (videowidth - 1 as libc::c_int) < clogoMaxX + 5 as libc::c_int {
                    videowidth - 1 as libc::c_int
                } else {
                    clogoMaxX + 5 as libc::c_int
                };
            lineEnd[i as usize] = videowidth - 1 as libc::c_int - border;
        }
        i += 1;
    }
    i = height;
    while i < 1200 as libc::c_int {
        lineStart[i as usize] = 0 as libc::c_int;
        lineEnd[i as usize] = 0 as libc::c_int;
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn InitHasLogo() {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    memset(
        haslogo.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ((3840 as libc::c_int * 1200 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    y = if 0 as libc::c_int > clogoMinY - 5 as libc::c_int {
        0 as libc::c_int
    } else {
        clogoMinY - 5 as libc::c_int
    };
    while y
        < (if (1200 as libc::c_int) < clogoMaxY + 5 as libc::c_int {
            1200 as libc::c_int
        } else {
            clogoMaxY + 5 as libc::c_int
        })
    {
        x = if 0 as libc::c_int > clogoMinX - 5 as libc::c_int {
            0 as libc::c_int
        } else {
            clogoMinX - 5 as libc::c_int
        };
        while x
            < (if (3840 as libc::c_int) < clogoMaxX + 5 as libc::c_int {
                3840 as libc::c_int
            } else {
                clogoMaxX + 5 as libc::c_int
            })
        {
            haslogo[(y * width + x) as usize] = 1 as libc::c_int as libc::c_char;
            x += 1;
        }
        y += 1;
    }
}
#[no_mangle]
pub static mut oheight: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut owidth: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut divider: libc::c_double = 1 as libc::c_int as libc::c_double;
#[no_mangle]
pub static mut oldfrm: libc::c_int = -(1 as libc::c_int);
#[no_mangle]
pub static mut zstart: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut zfactor: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut show_XDS: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut show_silence: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub unsafe extern "C" fn OutputDebugWindow(
    mut showVideo: bool,
    mut frm: libc::c_int,
    mut grf: libc::c_int,
) {
}
static mut shift: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub unsafe extern "C" fn Recalc() {
    BuildBlocks(1 as libc::c_int != 0);
    if commDetectMethod & 2 as libc::c_int != 0 {
        PrintLogoFrameGroups();
    }
    WeighBlocks();
    OutputBlocks();
}
#[no_mangle]
pub unsafe extern "C" fn ReviewResult() -> bool {
    let mut review_file: *mut FILE = 0 as *mut FILE;
    let mut curframe: libc::c_int = 1 as libc::c_int;
    let mut lastcurframe: libc::c_int = -(1 as libc::c_int);
    let mut bartop: libc::c_int = 0 as libc::c_int;
    let mut grf: libc::c_int = 2 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut prev: libc::c_long = 0;
    let mut tsfilename: [libc::c_char; 1024] = [0; 1024];
    if !framearray {
        grf = 0 as libc::c_int;
    }
    output_demux = 0 as libc::c_int != 0;
    output_data = 0 as libc::c_int != 0;
    output_srt = 0 as libc::c_int != 0;
    output_smi = 0 as libc::c_int != 0;
    if review_file.is_null() && mpegfilename[0 as libc::c_int as usize] as libc::c_int != 0 {
        review_file = myfopen(
            mpegfilename.as_mut_ptr(),
            b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if review_file.is_null() {
        strcpy(tsfilename.as_mut_ptr(), mpegfilename.as_mut_ptr());
        i = strlen(tsfilename.as_mut_ptr()) as libc::c_int;
        while i > 0 as libc::c_int
            && tsfilename[(i - 1 as libc::c_int) as usize] as libc::c_int != '.' as i32
        {
            i -= 1;
        }
        tsfilename[i as usize] = 't' as i32 as libc::c_char;
        tsfilename[(i + 1 as libc::c_int) as usize] = 's' as i32 as libc::c_char;
        tsfilename[(i + 2 as libc::c_int) as usize] = 0 as libc::c_int as libc::c_char;
        review_file = myfopen(
            tsfilename.as_mut_ptr(),
            b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !review_file.is_null() {
            demux_pid = 1 as libc::c_int;
            strcpy(mpegfilename.as_mut_ptr(), tsfilename.as_mut_ptr());
        }
    }
    if review_file.is_null() {
        strcpy(tsfilename.as_mut_ptr(), mpegfilename.as_mut_ptr());
        i = strlen(tsfilename.as_mut_ptr()) as libc::c_int;
        while i > 0 as libc::c_int
            && tsfilename[(i - 1 as libc::c_int) as usize] as libc::c_int != '.' as i32
        {
            i -= 1;
        }
        strcpy(
            &mut *tsfilename.as_mut_ptr().offset(i as isize),
            b"dvr-ms\0" as *const u8 as *const libc::c_char,
        );
        review_file = myfopen(
            tsfilename.as_mut_ptr(),
            b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !review_file.is_null() {
            demux_asf = 1 as libc::c_int;
            strcpy(mpegfilename.as_mut_ptr(), tsfilename.as_mut_ptr());
        }
    }
    loop {
        if key != 0 as libc::c_int {
            if key == 27 as libc::c_int {
                if helpflag == 0 {
                    exit(0 as libc::c_int);
                }
            }
            if key == 112 as libc::c_int {
                helpflag = 1 as libc::c_int;
                oldfrm = -(1 as libc::c_int);
            } else if helpflag == 1 as libc::c_int {
                helpflag = 0 as libc::c_int;
                oldfrm = -(1 as libc::c_int);
            }
            if key == 16 as libc::c_int {
                shift = 1 as libc::c_int;
            }
            if key == 37 as libc::c_int {
                curframe -= 1 as libc::c_int;
            }
            if key == 39 as libc::c_int {
                curframe += 1 as libc::c_int;
            }
            if key == 38 as libc::c_int {
                curframe -= fps as libc::c_int;
            }
            if key == 40 as libc::c_int {
                curframe += fps as libc::c_int;
            }
            if key == 33 as libc::c_int {
                curframe -= (20 as libc::c_int as libc::c_double * fps) as libc::c_int;
            }
            if key == 34 as libc::c_int {
                curframe += (20 as libc::c_int as libc::c_double * fps) as libc::c_int;
            }
            if key == 78 as libc::c_int || key == 39 as libc::c_int && shift != 0 {
                curframe += 5 as libc::c_int;
                if framearray {
                    i = 0 as libc::c_int;
                    while i <= commercial_count
                        && curframe as libc::c_long > commercial[i as usize].end_frame
                    {
                        i += 1;
                    }
                    curframe = (commercial[i as usize].end_frame + 5 as libc::c_int as libc::c_long)
                        as libc::c_int;
                } else {
                    i = 0 as libc::c_int;
                    while i <= reffer_count
                        && curframe as libc::c_long > reffer[i as usize].end_frame
                    {
                        i += 1;
                    }
                    curframe = (reffer[i as usize].end_frame + 5 as libc::c_int as libc::c_long)
                        as libc::c_int;
                }
                curframe -= 5 as libc::c_int;
            }
            if key == 80 as libc::c_int || key == 37 as libc::c_int && shift != 0 {
                curframe -= 5 as libc::c_int;
                if framearray {
                    i = commercial_count;
                    while i >= 0 as libc::c_int
                        && (curframe as libc::c_long) < commercial[i as usize].start_frame
                    {
                        i -= 1;
                    }
                    curframe = (commercial[i as usize].start_frame
                        - 5 as libc::c_int as libc::c_long)
                        as libc::c_int;
                } else {
                    i = reffer_count;
                    while i >= 0 as libc::c_int
                        && (curframe as libc::c_long) < reffer[i as usize].start_frame
                    {
                        i -= 1;
                    }
                    curframe = (reffer[i as usize].start_frame - 5 as libc::c_int as libc::c_long)
                        as libc::c_int;
                }
                curframe += 5 as libc::c_int;
            }
            if key == 'S' as i32 {
                if framearray {
                    curframe = 0 as libc::c_int;
                } else {
                    curframe = 0 as libc::c_int;
                }
            }
            if key == 'F' as i32 {
                if framearray {
                    curframe = frame_count as libc::c_int;
                } else {
                    curframe = frame_count as libc::c_int;
                }
            }
            if key == 'E' as i32 {
                if framearray {
                    curframe += 10 as libc::c_int;
                    i = 0 as libc::c_int;
                    while (i as libc::c_long) < block_count
                        && curframe as libc::c_long > cblock[i as usize].f_end
                    {
                        i += 1;
                    }
                    curframe = (cblock[i as usize].f_end + 5 as libc::c_int as libc::c_long)
                        as libc::c_int;
                    curframe -= 10 as libc::c_int;
                } else {
                    i = reffer_count;
                    while i >= 0 as libc::c_int
                        && (curframe as libc::c_long) < reffer[i as usize].start_frame
                    {
                        i -= 1;
                    }
                    if i >= 0 as libc::c_int {
                        reffer[i as usize].end_frame = curframe as libc::c_long;
                    }
                    oldfrm = -(1 as libc::c_int);
                }
            }
            if key == 'B' as i32 {
                if framearray {
                    curframe -= 10 as libc::c_int;
                    i = (block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
                    while i > 0 as libc::c_int
                        && (curframe as libc::c_long) < cblock[i as usize].f_start
                    {
                        i -= 1;
                    }
                    curframe = (cblock[i as usize].f_start - 5 as libc::c_int as libc::c_long)
                        as libc::c_int;
                    curframe += 10 as libc::c_int;
                } else {
                    i = 0 as libc::c_int;
                    while i <= reffer_count
                        && curframe as libc::c_long > reffer[i as usize].end_frame
                    {
                        i += 1;
                    }
                    if i <= reffer_count {
                        reffer[i as usize].start_frame = curframe as libc::c_long;
                    }
                    oldfrm = -(1 as libc::c_int);
                }
            }
            if key == 'T' as i32 {
                if framearray {
                    i = 0 as libc::c_int;
                    while (i as libc::c_long) < block_count
                        && curframe as libc::c_long > cblock[i as usize].f_end
                    {
                        i += 1;
                    }
                    if (i as libc::c_long) < block_count {
                        if cblock[i as usize].score < global_threshold {
                            cblock[i as usize].score = 99.99f64;
                        } else {
                            cblock[i as usize].score = 0.01f64;
                        }
                        cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 27 as libc::c_int)
                            as libc::c_int;
                        oldfrm = -(1 as libc::c_int);
                        BuildCommercial();
                        key = 'W' as i32;
                    }
                }
            }
            if key == 68 as libc::c_int {
                if framearray {
                    i = 0 as libc::c_int;
                    while (i as libc::c_long) < block_count
                        && curframe as libc::c_long > cblock[i as usize].f_end
                    {
                        i += 1;
                    }
                    if (i as libc::c_long) < block_count {
                        cblock[i as usize].score = 99.99f64;
                        cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 27 as libc::c_int)
                            as libc::c_int;
                        oldfrm = -(1 as libc::c_int);
                        BuildCommercial();
                    }
                } else {
                    i = reffer_count;
                    while i >= 0 as libc::c_int
                        && (curframe as libc::c_long) < reffer[i as usize].start_frame
                    {
                        i -= 1;
                    }
                    if i >= 0 as libc::c_int
                        && reffer[i as usize].start_frame <= curframe as libc::c_long
                        && curframe as libc::c_long <= reffer[i as usize].end_frame
                    {
                        while i < reffer_count {
                            reffer[i as usize] = reffer[(i + 1 as libc::c_int) as usize];
                            i += 1;
                        }
                        reffer_count -= 1;
                        oldfrm = -(1 as libc::c_int);
                    }
                }
            }
            if key == 73 as libc::c_int {
                if framearray {
                    i = 0 as libc::c_int;
                    while (i as libc::c_long) < block_count
                        && curframe as libc::c_long > cblock[i as usize].f_end
                    {
                        i += 1;
                    }
                    if (i as libc::c_long) < block_count {
                        cblock[i as usize].score = 0.01f64;
                        cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 27 as libc::c_int)
                            as libc::c_int;
                        oldfrm = -(1 as libc::c_int);
                        BuildCommercial();
                    }
                } else {
                    i = reffer_count;
                    while i >= 0 as libc::c_int
                        && (curframe as libc::c_long) < reffer[i as usize].start_frame
                    {
                        i -= 1;
                    }
                    if i == -(1 as libc::c_int)
                        || curframe as libc::c_long > reffer[i as usize].end_frame
                    {
                        j = reffer_count;
                        while j > i {
                            reffer[(j + 1 as libc::c_int) as usize] = reffer[j as usize];
                            j -= 1;
                        }
                        reffer[(i + 1 as libc::c_int) as usize].start_frame =
                            max(curframe - 1000 as libc::c_int, 1 as libc::c_int) as libc::c_long;
                        reffer[(i + 1 as libc::c_int) as usize].end_frame =
                            min(curframe + 1000 as libc::c_int, frame_count as libc::c_int)
                                as libc::c_long;
                        reffer_count += 1;
                        oldfrm = -(1 as libc::c_int);
                    }
                }
            }
            if key == 'W' as i32 {
                output_default = 1 as libc::c_int != 0;
                OpenOutputFiles();
                if framearray {
                    prev = -(1 as libc::c_int) as libc::c_long;
                    i = 0 as libc::c_int;
                    while i <= commercial_count {
                        OutputCommercialBlock(
                            i,
                            prev,
                            commercial[i as usize].start_frame,
                            commercial[i as usize].end_frame,
                            if commercial[i as usize].end_frame
                                < frame_count - 2 as libc::c_int as libc::c_long
                            {
                                0 as libc::c_int
                            } else {
                                1 as libc::c_int
                            } != 0,
                        );
                        prev = commercial[i as usize].end_frame;
                        i += 1;
                    }
                    if commercial[commercial_count as usize].end_frame
                        < frame_count - 2 as libc::c_int as libc::c_long
                    {
                        OutputCommercialBlock(
                            commercial_count,
                            prev,
                            frame_count - 2 as libc::c_int as libc::c_long,
                            frame_count - 1 as libc::c_int as libc::c_long,
                            1 as libc::c_int != 0,
                        );
                    }
                } else {
                    prev = -(1 as libc::c_int) as libc::c_long;
                    i = 0 as libc::c_int;
                    while i <= reffer_count {
                        OutputCommercialBlock(
                            i,
                            prev,
                            reffer[i as usize].start_frame,
                            reffer[i as usize].end_frame,
                            if reffer[i as usize].end_frame
                                < frame_count - 2 as libc::c_int as libc::c_long
                            {
                                0 as libc::c_int
                            } else {
                                1 as libc::c_int
                            } != 0,
                        );
                        prev = reffer[i as usize].end_frame;
                        i += 1;
                    }
                    if reffer[reffer_count as usize].end_frame
                        < frame_count - 2 as libc::c_int as libc::c_long
                    {
                        OutputCommercialBlock(
                            reffer_count,
                            prev,
                            frame_count - 2 as libc::c_int as libc::c_long,
                            frame_count - 1 as libc::c_int as libc::c_long,
                            1 as libc::c_int != 0,
                        );
                    }
                }
                output_default = 0 as libc::c_int != 0;
                oldfrm = -(1 as libc::c_int);
            }
            if key == 'Z' as i32 {
                if zfactor < 256 as libc::c_int
                    && frame_count / zfactor as libc::c_long > owidth as libc::c_long
                {
                    zfactor = zfactor << 1 as libc::c_int;
                    zstart = (curframe + zstart) / 2 as libc::c_int;
                    oldfrm = -(1 as libc::c_int);
                }
            }
            if key == 'U' as i32 {
                if zfactor > 1 as libc::c_int {
                    zfactor = zfactor >> 1 as libc::c_int;
                    zstart = zstart - (curframe - zstart);
                    if zstart < 0 as libc::c_int {
                        zstart = 0 as libc::c_int;
                    }
                    oldfrm = -(1 as libc::c_int);
                }
            }
            if key == 'C' as i32 {
                RecordCutScene(curframe, (*frame.offset(curframe as isize)).brightness);
            }
            if key == 'X' as i32 {
                show_XDS = (show_XDS == 0) as libc::c_int;
                oldfrm = -(1 as libc::c_int);
            }
            if key == 'V' as i32 {
                show_silence = (show_silence == 0) as libc::c_int;
                oldfrm = -(1 as libc::c_int);
            }
            if key == 'G' as i32 {
                grf += 1;
                if grf > 2 as libc::c_int {
                    grf = 0 as libc::c_int;
                }
                oldfrm = -(1 as libc::c_int);
            }
            if key == 113 as libc::c_int {
                max_volume = (max_volume as libc::c_double / 1.1f64) as libc::c_int;
                Recalc();
                oldfrm = -(1 as libc::c_int);
            }
            if key == 114 as libc::c_int {
                non_uniformity = (non_uniformity as libc::c_double / 1.1f64) as libc::c_int;
                Recalc();
                oldfrm = -(1 as libc::c_int);
            }
            if key == 115 as libc::c_int {
                max_avg_brightness = (max_avg_brightness as libc::c_double / 1.1f64) as libc::c_int;
                Recalc();
                oldfrm = -(1 as libc::c_int);
            }
            if key == 116 as libc::c_int {
                timeflag += 1;
                if timeflag > 2 as libc::c_int {
                    timeflag = 0 as libc::c_int;
                }
                oldfrm = -(1 as libc::c_int);
            }
            if key == '.' as i32 {
                oldfrm = -(1 as libc::c_int);
            }
            if key == 82 as libc::c_int {
                return 1 as libc::c_int != 0;
            }
            if key != 16 as libc::c_int {
                shift = 0 as libc::c_int;
            }
            key = 0 as libc::c_int;
        }
        if lMouseDown != 0 {
            if yPos >= bartop && yPos < bartop + 30 as libc::c_int {
                curframe = (zstart as libc::c_long
                    + frame_count * xPos as libc::c_long
                        / owidth as libc::c_long
                        / zfactor as libc::c_long
                    + 1 as libc::c_int as libc::c_long) as libc::c_int;
            }
            lMouseDown = 0 as libc::c_int;
        }
        if curframe < 1 as libc::c_int {
            curframe = 1 as libc::c_int;
        }
        if frame_count > 0 as libc::c_int as libc::c_long {
            if curframe as libc::c_long >= frame_count {
                curframe = (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
            }
        }
        if frame_count > 0 as libc::c_int as libc::c_long && !review_file.is_null() {
            if curframe != lastcurframe {
                DecodeOnePicture(
                    review_file,
                    if framearray as libc::c_int != 0 {
                        if !frame.is_null() {
                            if curframe <= 0 as libc::c_int {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else if curframe >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(curframe as isize)).pts
                            }
                        } else {
                            curframe as libc::c_double / fps
                        }
                    } else {
                        curframe as libc::c_double / fps
                    },
                );
                lastcurframe = curframe;
            }
        }
        OutputDebugWindow(
            if !review_file.is_null() {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            } != 0,
            curframe,
            grf,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn DetectCommercials(
    mut f: libc::c_int,
    mut pts: libc::c_double,
) -> libc::c_int {
    let mut isBlack: bool = 0 as libc::c_int != 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut oldBlack_count: libc::c_long = 0;
    if loadingTXT {
        return 0 as libc::c_int;
    }
    if loadingCSV {
        return 0 as libc::c_int;
    }
    if !initialized {
        InitComSkip();
    }
    framenum_real = framenum + 1 as libc::c_int;
    frame_count = framenum_real as libc::c_long;
    avg_fps = 1.0f64 / (pts / frame_count as libc::c_double);
    if framenum_real < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if play_nice {
        usleep((play_nice_sleep * 1000 as libc::c_long) as useconds_t);
    }
    if framearray {
        InitializeFrameArray(framenum_real as libc::c_long);
    }
    if pts < 0.0f64 {
        pts = 0.0f64;
    }
    (*frame.offset(frame_count as isize)).pts = pts;
    (*frame.offset(frame_count as isize)).pict_type = pict_type;
    if frame_count == 1 as libc::c_int as libc::c_long {
        (*frame.offset(0 as libc::c_int as isize)).pts = pts;
    }
    (*frame.offset(frame_count as isize)).volume = -(1 as libc::c_int);
    backfill_frame_volumes();
    curvolume = (*frame.offset(frame_count as isize)).volume;
    if framearray {
        (*frame.offset(frame_count as isize)).volume = curvolume;
        (*frame.offset(frame_count as isize)).goppos = headerpos;
        (*frame.offset(frame_count as isize)).cur_segment = debug_cur_segment;
        (*frame.offset(frame_count as isize)).audio_channels = audio_channels;
    }
    if curvolume > 0 as libc::c_int {
        volumeHistogram[(if curvolume / volumeScale < 255 as libc::c_int {
            curvolume / volumeScale
        } else {
            255 as libc::c_int
        }) as usize] += 1;
    }
    if ticker_tape_percentage > 0 as libc::c_int {
        ticker_tape = ticker_tape_percentage * height / 100 as libc::c_int;
    }
    if ticker_tape != 0 {
        memset(
            &mut *frame_ptr.offset((width * (height - ticker_tape)) as isize) as *mut libc::c_uchar
                as *mut libc::c_void,
            0 as libc::c_int,
            (width * ticker_tape) as libc::c_ulong,
        );
    }
    if ignore_side != 0 {
        i = 0 as libc::c_int;
        while i < height {
            j = 0 as libc::c_int;
            while j < ignore_side {
                *frame_ptr.offset((width * i + j) as isize) = 0 as libc::c_int as libc::c_uchar;
                *frame_ptr.offset((width * i + (width - 1 as libc::c_int) - j) as isize) =
                    0 as libc::c_int as libc::c_uchar;
                j += 1;
            }
            i += 1;
        }
    }
    if ignore_left_side != 0 {
        i = 0 as libc::c_int;
        while i < height {
            j = 0 as libc::c_int;
            while j < ignore_left_side {
                *frame_ptr.offset((width * i + j) as isize) = 0 as libc::c_int as libc::c_uchar;
                j += 1;
            }
            i += 1;
        }
    }
    if ignore_right_side != 0 {
        i = 0 as libc::c_int;
        while i < height {
            j = 0 as libc::c_int;
            while j < ignore_right_side {
                *frame_ptr.offset((width * i + (width - 1 as libc::c_int) - j) as isize) =
                    0 as libc::c_int as libc::c_uchar;
                j += 1;
            }
            i += 1;
        }
    }
    oldBlack_count = black_count;
    CheckSceneHasChanged();
    isBlack = oldBlack_count != black_count;
    if commDetectMethod & 2 as libc::c_int != 0
        && frame_count % (fps * logoFreq) as libc::c_int as libc::c_long
            == 0 as libc::c_int as libc::c_long
    {
        if !logoInfoAvailable || !lastLogoTest && !startOverAfterLogoInfoAvail {
            if delay_logo_search == 0 as libc::c_int
                || delay_logo_search == 1 as libc::c_int
                    && (if !frame.is_null() {
                        (if frame_count <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if frame_count >= framenum_real as libc::c_long {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(frame_count as isize)).pts
                            })
                        })
                    } else {
                        frame_count as libc::c_double / fps
                    }) > (added_recording * 60 as libc::c_int) as libc::c_double
                || (if !frame.is_null() {
                    (if frame_count <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if frame_count >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(frame_count as isize)).pts
                        })
                    })
                } else {
                    frame_count as libc::c_double / fps
                }) > delay_logo_search as libc::c_double
            {
                FillLogoBuffer();
                if logoBuffersFull {
                    Debug(
                        6 as libc::c_int,
                        b"\nLooking For Logo in frames %i to %i.\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        *logoFrameNum.offset(oldestLogoBuffer as isize),
                        frame_count,
                    );
                    if !SearchForLogoEdges() {
                        InitComSkip();
                        return 1 as libc::c_int;
                    }
                }
                logoInfoAvailable;
            }
        }
        if logoInfoAvailable {
            currentGoodEdge = CheckStationLogoEdge(frame_ptr);
            curLogoTest = currentGoodEdge > logo_threshold;
            lastLogoTest = ProcessLogoTest(
                frame_count as libc::c_int,
                curLogoTest as libc::c_int,
                0 as libc::c_int,
            );
            if !lastLogoTest && !startOverAfterLogoInfoAvail && logoBuffersFull as libc::c_int != 0
            {
                logoBuffersFull = 0 as libc::c_int != 0;
                InitLogoBuffers();
                newestLogoBuffer = -(1 as libc::c_int);
            }
            if startOverAfterLogoInfoAvail as libc::c_int != 0
                && !loadingCSV
                && !secondLogoSearch
                && logo_block_count > 0 as libc::c_int as libc::c_long
                && !lastLogoTest
                && (if !frame.is_null() {
                    (if frame_count <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if frame_count >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(frame_count as isize)).pts
                        })
                    })
                } else {
                    frame_count as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if (*logo_block
                        .offset((logo_block_count - 1 as libc::c_int as libc::c_long) as isize))
                    .end <= 0 as libc::c_int
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*logo_block
                            .offset((logo_block_count - 1 as libc::c_int as libc::c_long) as isize))
                        .end >= framenum_real
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                (*logo_block.offset(
                                    (logo_block_count - 1 as libc::c_int as libc::c_long) as isize,
                                ))
                                .end as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    (*logo_block
                        .offset((logo_block_count - 1 as libc::c_int as libc::c_long) as isize))
                    .end as libc::c_double
                        / fps
                }) > max_commercialbreak * 1.2f64
                && (frames_with_logo as libc::c_double / frame_count as libc::c_double) < 0.5f64
            {
                Debug(
                    6 as libc::c_int,
                    b"\nNo Logo in frames %i to %i, restarting Logo search.\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    (*logo_block
                        .offset((logo_block_count - 1 as libc::c_int as libc::c_long) as isize))
                    .end,
                    frame_count,
                );
                logoInfoAvailable = 0 as libc::c_int != 0;
                secondLogoSearch = 1 as libc::c_int != 0;
                logoBuffersFull = 0 as libc::c_int != 0;
                InitLogoBuffers();
                newestLogoBuffer = -(1 as libc::c_int);
            }
        }
    }
    if logoInfoAvailable as libc::c_int != 0 && framearray as libc::c_int != 0 {
        (*frame.offset(frame_count as isize)).logo_present = lastLogoTest;
    } else if framearray {
        (*frame.offset(frame_count as isize)).logo_present = 0.0f64 != 0.;
    }
    if lastLogoTest {
        frames_with_logo += 1;
    }
    if framearray {
        (*frame.offset(frame_count as isize)).currentGoodEdge = currentGoodEdge;
    }
    if frame_count & subsample_video as libc::c_long == 0 as libc::c_int as libc::c_long {
        OutputDebugWindow(
            1 as libc::c_int != 0,
            frame_count as libc::c_int,
            1 as libc::c_int,
        );
    }
    framesprocessed += 1;
    scr += 1 as libc::c_int;
    if live_tv as libc::c_int != 0 && !isBlack {
        BuildCommListAsYouGo();
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Max(mut i: libc::c_int, mut j: libc::c_int) -> libc::c_int {
    return if i > j { i } else { j };
}
#[no_mangle]
pub unsafe extern "C" fn Min(mut i: libc::c_int, mut j: libc::c_int) -> libc::c_int {
    return if i < j { i } else { j };
}
#[no_mangle]
pub unsafe extern "C" fn AverageARForBlock(
    mut start: libc::c_int,
    mut end: libc::c_int,
) -> libc::c_double {
    let mut i: libc::c_int = 0;
    let mut maxSize: libc::c_int = 0;
    let mut Ar: libc::c_double = 0.;
    let mut f: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    maxSize = 0 as libc::c_int;
    Ar = 0.0f64;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < ar_block_count {
        f = max((*ar_block.offset(i as isize)).start, start);
        t = min((*ar_block.offset(i as isize)).end, end);
        if maxSize < t - f + 1 as libc::c_int {
            Ar = (*ar_block.offset(i as isize)).ar_ratio;
            maxSize = t - f + 1 as libc::c_int;
        }
        if (*ar_block.offset(i as isize)).start > end {
            break;
        }
        i += 1;
    }
    return Ar;
}
#[no_mangle]
pub unsafe extern "C" fn AverageACForBlock(
    mut start: libc::c_int,
    mut end: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut maxSize: libc::c_int = 0;
    let mut Ac: libc::c_int = 0;
    let mut f: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    maxSize = 0 as libc::c_int;
    Ac = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < ac_block_count {
        f = max((*ac_block.offset(i as isize)).start, start);
        t = min((*ac_block.offset(i as isize)).end, end);
        if maxSize < t - f + 1 as libc::c_int {
            Ac = (*ac_block.offset(i as isize)).audio_channels;
            maxSize = t - f + 1 as libc::c_int;
        }
        if (*ac_block.offset(i as isize)).start > end {
            break;
        }
        i += 1;
    }
    return Ac;
}
#[no_mangle]
pub unsafe extern "C" fn FindARFromHistogram(mut ar_ratio: libc::c_double) -> libc::c_double {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 1000 as libc::c_int {
        if ar_ratio > ar_histogram[i as usize].ar_ratio - ar_delta
            && ar_ratio < ar_histogram[i as usize].ar_ratio + ar_delta
        {
            return ar_histogram[i as usize].ar_ratio;
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < 1000 as libc::c_int {
        if ar_ratio
            > ar_histogram[i as usize].ar_ratio - 2 as libc::c_int as libc::c_double * ar_delta
            && ar_ratio
                < ar_histogram[i as usize].ar_ratio + 2 as libc::c_int as libc::c_double * ar_delta
        {
            return ar_histogram[i as usize].ar_ratio;
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < 1000 as libc::c_int {
        if ar_ratio
            > ar_histogram[i as usize].ar_ratio - 4 as libc::c_int as libc::c_double * ar_delta
            && ar_ratio
                < ar_histogram[i as usize].ar_ratio + 4 as libc::c_int as libc::c_double * ar_delta
        {
            return ar_histogram[i as usize].ar_ratio;
        }
        i += 1;
    }
    return 0.0f64;
}
#[no_mangle]
pub unsafe extern "C" fn FillARHistogram(mut refill: bool) {
    let mut i: libc::c_int = 0;
    let mut hadToSwap: bool = false;
    let mut tempFrames: libc::c_long = 0;
    let mut tempRatio: libc::c_double = 0.;
    let mut totalFrames: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut tempCount: libc::c_long = 0;
    let mut counter: libc::c_long = 0;
    let mut hi: libc::c_int = 0;
    if refill {
        i = 0 as libc::c_int;
        while i < 1000 as libc::c_int {
            ar_histogram[i as usize].frames = 0 as libc::c_int as libc::c_long;
            ar_histogram[i as usize].ar_ratio = 0.0f64;
            i += 1;
        }
        i = 0 as libc::c_int;
        while (i as libc::c_long) < ar_block_count {
            hi = (((*ar_block.offset(i as isize)).ar_ratio - 0.5f64)
                * 100 as libc::c_int as libc::c_double) as libc::c_int;
            if hi >= 0 as libc::c_int && hi < 1000 as libc::c_int {
                ar_histogram[hi as usize].frames +=
                    ((*ar_block.offset(i as isize)).end - (*ar_block.offset(i as isize)).start
                        + 1 as libc::c_int) as libc::c_long;
                ar_histogram[hi as usize].ar_ratio = (*ar_block.offset(i as isize)).ar_ratio;
            }
            i += 1;
        }
    }
    counter = 0 as libc::c_int as libc::c_long;
    loop {
        hadToSwap = 0 as libc::c_int != 0;
        counter += 1;
        i = 0 as libc::c_int;
        while i < 1000 as libc::c_int - 1 as libc::c_int {
            if ar_histogram[i as usize].frames
                < ar_histogram[(i + 1 as libc::c_int) as usize].frames
            {
                hadToSwap = 1 as libc::c_int != 0;
                tempFrames = ar_histogram[i as usize].frames;
                tempRatio = ar_histogram[i as usize].ar_ratio;
                ar_histogram[i as usize] = ar_histogram[(i + 1 as libc::c_int) as usize];
                ar_histogram[(i + 1 as libc::c_int) as usize].frames = tempFrames;
                ar_histogram[(i + 1 as libc::c_int) as usize].ar_ratio = tempRatio;
            }
            i += 1;
        }
        if !hadToSwap {
            break;
        }
    }
    i = 0 as libc::c_int;
    while i < 1000 as libc::c_int {
        totalFrames += ar_histogram[i as usize].frames;
        i += 1;
    }
    tempCount = 0 as libc::c_int as libc::c_long;
    Debug(
        10 as libc::c_int,
        b"\n\nAfter Sorting - %i\n--------------\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        counter,
    );
    i = 0 as libc::c_int;
    while i < 1000 as libc::c_int
        && ar_histogram[i as usize].frames > 0 as libc::c_int as libc::c_long
    {
        tempCount += ar_histogram[i as usize].frames;
        Debug(
            10 as libc::c_int,
            b"Aspect Ratio  %5.2f found on %6i frames totalling \t%3.1f%c\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            ar_histogram[i as usize].ar_ratio,
            ar_histogram[i as usize].frames,
            tempCount as libc::c_double / totalFrames as libc::c_double
                * 100 as libc::c_int as libc::c_double,
            '%' as i32,
        );
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn FillACHistogram(mut refill: bool) {
    let mut i: libc::c_int = 0;
    let mut hadToSwap: bool = false;
    let mut tempFrames: libc::c_long = 0;
    let mut tempAC: libc::c_int = 0;
    let mut totalFrames: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut tempCount: libc::c_long = 0;
    let mut counter: libc::c_long = 0;
    let mut hi: libc::c_int = 0;
    if refill {
        i = 0 as libc::c_int;
        while i < 12 as libc::c_int {
            ac_histogram[i as usize].frames = 0 as libc::c_int as libc::c_long;
            ac_histogram[i as usize].audio_channels = 0.0f64 as libc::c_int;
            i += 1;
        }
        i = 0 as libc::c_int;
        while (i as libc::c_long) < ac_block_count {
            hi = (*ac_block.offset(i as isize)).audio_channels;
            if hi >= 0 as libc::c_int && hi < 12 as libc::c_int {
                ac_histogram[hi as usize].frames +=
                    ((*ac_block.offset(i as isize)).end - (*ac_block.offset(i as isize)).start
                        + 1 as libc::c_int) as libc::c_long;
                ac_histogram[hi as usize].audio_channels =
                    (*ac_block.offset(i as isize)).audio_channels;
            }
            i += 1;
        }
    }
    counter = 0 as libc::c_int as libc::c_long;
    loop {
        hadToSwap = 0 as libc::c_int != 0;
        counter += 1;
        i = 0 as libc::c_int;
        while i < 12 as libc::c_int - 1 as libc::c_int {
            if ac_histogram[i as usize].frames
                < ac_histogram[(i + 1 as libc::c_int) as usize].frames
            {
                hadToSwap = 1 as libc::c_int != 0;
                tempFrames = ac_histogram[i as usize].frames;
                tempAC = ac_histogram[i as usize].audio_channels;
                ac_histogram[i as usize] = ac_histogram[(i + 1 as libc::c_int) as usize];
                ac_histogram[(i + 1 as libc::c_int) as usize].frames = tempFrames;
                ac_histogram[(i + 1 as libc::c_int) as usize].audio_channels = tempAC;
            }
            i += 1;
        }
        if !hadToSwap {
            break;
        }
    }
    i = 0 as libc::c_int;
    while i < 12 as libc::c_int {
        totalFrames += ac_histogram[i as usize].frames;
        i += 1;
    }
    tempCount = 0 as libc::c_int as libc::c_long;
    Debug(
        10 as libc::c_int,
        b"\n\nAfter Sorting - %i\n--------------\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        counter,
    );
    i = 0 as libc::c_int;
    while i < 12 as libc::c_int
        && ac_histogram[i as usize].frames > 0 as libc::c_int as libc::c_long
    {
        tempCount += ac_histogram[i as usize].frames;
        Debug(
            10 as libc::c_int,
            b"Audio channels %3i found on %6i frames totalling \t%3.1f%c\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            ac_histogram[i as usize].audio_channels,
            ac_histogram[i as usize].frames,
            tempCount as libc::c_double / totalFrames as libc::c_double
                * 100 as libc::c_int as libc::c_double,
            '%' as i32,
        );
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn InsertBlackFrame(
    mut f: libc::c_int,
    mut b: libc::c_int,
    mut u: libc::c_int,
    mut v: libc::c_int,
    mut c: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < black_count
        && (*black.offset(i as isize)).frame != f as libc::c_long
    {
        i += 1;
    }
    if (i as libc::c_long) < black_count && (*black.offset(i as isize)).frame == f as libc::c_long {
        (*black.offset(i as isize)).cause |= c;
    } else {
        if black_count >= max_black_count {
            max_black_count += 500 as libc::c_int as libc::c_long;
            black = realloc(
                black as *mut libc::c_void,
                ((max_black_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<black_frame_info>() as libc::c_ulong),
            ) as *mut black_frame_info;
            Debug(
                9 as libc::c_int,
                b"Resizing black frame array to accomodate %i frames.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                max_black_count,
            );
        }
        black_count += 1;
        i = (black_count - 2 as libc::c_int as libc::c_long) as libc::c_int;
        while i >= 0 as libc::c_int && (*black.offset(i as isize)).frame > f as libc::c_long {
            *black.offset((i + 1 as libc::c_int) as isize) = *black.offset(i as isize);
            i -= 1;
        }
        i += 1;
        (*black.offset(i as isize)).frame = f as libc::c_long;
        (*black.offset(i as isize)).brightness = b;
        (*black.offset(i as isize)).uniform = u as libc::c_long;
        (*black.offset(i as isize)).volume = v;
        (*black.offset(i as isize)).cause = c;
    };
}
#[no_mangle]
pub unsafe extern "C" fn BuildMasterCommList() -> bool {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut a: libc::c_int = 0 as libc::c_int;
    let mut k: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut cp: libc::c_int = 0 as libc::c_int;
    let mut cpf: libc::c_int = 0;
    let mut maxsc: libc::c_int = 0;
    let mut rsc: libc::c_int = 0;
    let mut silence_count: libc::c_int = 0 as libc::c_int;
    let mut silence_start: libc::c_int = 0 as libc::c_int;
    let mut summed_volume1: libc::c_int = 0 as libc::c_int;
    let mut summed_volume2: libc::c_int = 0 as libc::c_int;
    let mut schange_found: libc::c_int = 0 as libc::c_int;
    let mut schange_frame: libc::c_int = 0;
    let mut low_volume_count: libc::c_int = 0;
    let mut very_low_volume_count: libc::c_int = 0;
    let mut schange_max: libc::c_int = 0;
    let mut mv: libc::c_int = 0 as libc::c_int;
    let mut ms: libc::c_int = 0 as libc::c_int;
    let mut volume_delta: libc::c_int = 0;
    let mut p_vol: libc::c_int = 0;
    let mut n_vol: libc::c_int = 0;
    let mut plataus: libc::c_int = 0 as libc::c_int;
    let mut platauHistogram: [libc::c_int; 256] = [0; 256];
    let mut length: libc::c_double = 0.;
    let mut new_ar_ratio: libc::c_double = 0.;
    let mut logo_file: *mut FILE = 0 as *mut FILE;
    let mut foundCommercials: bool = 0 as libc::c_int != 0;
    let mut ltime: time_t = 0;
    if frame_count == 0 as libc::c_int as libc::c_long {
        Debug(
            1 as libc::c_int,
            b"No video found\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as libc::c_int != 0;
    }
    Debug(
        7 as libc::c_int,
        b"Finished scanning file.  Starting to build Commercial List.\n\0" as *const u8
            as *const libc::c_char as *mut libc::c_char,
    );
    length = (if !frame.is_null() {
        (if frame_count - 1 as libc::c_int as libc::c_long <= 0 as libc::c_int as libc::c_long {
            (*frame.offset(1 as libc::c_int as isize)).pts
        } else {
            (if frame_count - 1 as libc::c_int as libc::c_long >= framenum_real as libc::c_long {
                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
            } else {
                (*frame.offset((frame_count - 1 as libc::c_int as libc::c_long) as isize)).pts
            })
        })
    } else {
        (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_double / fps
    }) - (if !frame.is_null() {
        (if 1 as libc::c_int <= 0 as libc::c_int {
            (*frame.offset(1 as libc::c_int as isize)).pts
        } else {
            (if 1 as libc::c_int >= framenum_real {
                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
            } else {
                (*frame.offset(1 as libc::c_int as isize)).pts
            })
        })
    } else {
        1 as libc::c_int as libc::c_double / fps
    });
    if fabs(length - (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_double / fps)
        > 0.5f64
    {
        if fabs(avg_fps - fps) > 1 as libc::c_int as libc::c_double {
            Debug(
                1 as libc::c_int,
                b"WARNING: Actual framerate (%6.3f) different from specified framerate (%6.3f)\nInternal frame numbers will be different from .txt frame numbers\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                avg_fps,
                fps,
            );
        }
        Debug(
            1 as libc::c_int,
            b"WARNING: Complex timeline or errors in the recording!!!!\nResults may be wrong, .ref input will be misaligned. .txt editing will produce wrong results\nUse .edl output if possible\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    (*frame.offset(frame_count as isize)).pts = (*frame
        .offset((frame_count - 1 as libc::c_int as libc::c_long) as isize))
    .pts + 1.0f64 / fps;
    i = 1 as libc::c_int;
    while i < 255 as libc::c_int {
        if volumeHistogram[i as usize] > 10 as libc::c_int {
            min_volume = (i - 1 as libc::c_int) * volumeScale;
            break;
        } else {
            i += 1;
        }
    }
    k = 1 as libc::c_int;
    while k < 255 as libc::c_int {
        if uniformHistogram[k as usize] > 10 as libc::c_int {
            min_uniform = (k - 1 as libc::c_int) * 100 as libc::c_int;
            break;
        } else {
            k += 1;
        }
    }
    i = 0 as libc::c_int;
    while i < 255 as libc::c_int {
        if brightHistogram[i as usize] > 1 as libc::c_int {
            min_brightness_found = i;
            break;
        } else {
            i += 1;
        }
    }
    logoPercentage = frames_with_logo as libc::c_double / framenum_real as libc::c_double;
    volume_delta = 10 as libc::c_int;
    loop {
        if framearray {
            i = 0 as libc::c_int;
            while i < 255 as libc::c_int {
                platauHistogram[i as usize] = 0 as libc::c_int;
                i += 1;
            }
            plataus = 0 as libc::c_int;
            j = 1 as libc::c_int;
            i = 6 as libc::c_int;
            while (i as libc::c_long) < frame_count - 6 as libc::c_int as libc::c_long {
                if (*frame.offset(i as isize)).volume > 300 as libc::c_int
                    || (*frame.offset(i as isize)).volume < 0 as libc::c_int
                {
                    i += 1;
                } else {
                    while ((i + 1 as libc::c_int) as libc::c_long)
                        < frame_count - 6 as libc::c_int as libc::c_long
                        && (*frame.offset((i + 1 as libc::c_int) as isize)).volume
                            < (*frame.offset(i as isize)).volume
                    {
                        i += 1;
                    }
                    k = 1 as libc::c_int;
                    while i - k - 6 as libc::c_int > 1 as libc::c_int
                        && abs((*frame.offset((i - k) as isize)).volume
                            - (*frame.offset(i as isize)).volume)
                            < volume_delta
                    {
                        k += 1;
                    }
                    if (*frame.offset((i - k) as isize)).volume < (*frame.offset(i as isize)).volume
                    {
                        i += 1;
                    } else {
                        a = 1 as libc::c_int;
                        while ((i + a + 6 as libc::c_int) as libc::c_long) < frame_count
                            && abs((*frame.offset((i + a) as isize)).volume
                                - (*frame.offset(i as isize)).volume)
                                < volume_delta
                        {
                            a += 1;
                        }
                        if (*frame.offset((i + a) as isize)).volume
                            < (*frame.offset(i as isize)).volume
                        {
                            i = i + a;
                        } else {
                            if a + k > 6 as libc::c_int
                                && i - k - 6 as libc::c_int > 0 as libc::c_int
                                && ((i + a + 6 as libc::c_int) as libc::c_long) < frame_count
                            {
                                p_vol = ((*frame.offset((i - k - 4 as libc::c_int) as isize))
                                    .volume
                                    + (*frame.offset(
                                        (i - k - 6 as libc::c_int + 3 as libc::c_int) as isize,
                                    ))
                                    .volume
                                    + (*frame.offset(
                                        (i - k - 6 as libc::c_int + 2 as libc::c_int) as isize,
                                    ))
                                    .volume
                                    + (*frame.offset(
                                        (i - k - 6 as libc::c_int + 1 as libc::c_int) as isize,
                                    ))
                                    .volume
                                    + (*frame.offset((i - k - 6 as libc::c_int) as isize)).volume)
                                    / 5 as libc::c_int;
                                n_vol = ((*frame.offset((i + a + 4 as libc::c_int) as isize))
                                    .volume
                                    + (*frame.offset(
                                        (i + a + 6 as libc::c_int - 3 as libc::c_int) as isize,
                                    ))
                                    .volume
                                    + (*frame.offset(
                                        (i + a + 6 as libc::c_int - 2 as libc::c_int) as isize,
                                    ))
                                    .volume
                                    + (*frame.offset(
                                        (i + a + 6 as libc::c_int - 1 as libc::c_int) as isize,
                                    ))
                                    .volume
                                    + (*frame.offset((i + a + 6 as libc::c_int) as isize)).volume)
                                    / 5 as libc::c_int;
                                if p_vol > (*frame.offset(i as isize)).volume + 220 as libc::c_int
                                    || n_vol
                                        > (*frame.offset(i as isize)).volume + 220 as libc::c_int
                                {
                                    Debug(
                                        8 as libc::c_int,
                                        b"Platau@[%d] frames %d, volume %d, distance %d seconds\n\0"
                                            as *const u8
                                            as *const libc::c_char
                                            as *mut libc::c_char,
                                        i,
                                        k + a,
                                        (*frame.offset(i as isize)).volume,
                                        ((if !frame.is_null() {
                                            (if i <= 0 as libc::c_int {
                                                (*frame.offset(1 as libc::c_int as isize)).pts
                                            } else {
                                                (if i >= framenum_real {
                                                    (*frame.offset(
                                                        (framenum_real - 1 as libc::c_int) as isize,
                                                    ))
                                                    .pts
                                                } else {
                                                    (*frame.offset(i as isize)).pts
                                                })
                                            })
                                        } else {
                                            i as libc::c_double / fps
                                        }) - (if !frame.is_null() {
                                            (if j <= 0 as libc::c_int {
                                                (*frame.offset(1 as libc::c_int as isize)).pts
                                            } else {
                                                (if j >= framenum_real {
                                                    (*frame.offset(
                                                        (framenum_real - 1 as libc::c_int) as isize,
                                                    ))
                                                    .pts
                                                } else {
                                                    (*frame.offset(j as isize)).pts
                                                })
                                            })
                                        } else {
                                            j as libc::c_double / fps
                                        })) as libc::c_int,
                                    );
                                    j = i;
                                    plataus += 1;
                                    platauHistogram[((*frame.offset(i as isize)).volume
                                        / 10 as libc::c_int)
                                        as usize] += 1;
                                }
                            }
                            i += a;
                        }
                    }
                }
            }
            a = 0 as libc::c_int;
            Debug(
                9 as libc::c_int,
                b"Vol : #Frames\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            i = 0 as libc::c_int;
            while i < 255 as libc::c_int {
                a += platauHistogram[i as usize];
                if platauHistogram[i as usize] > 0 as libc::c_int {
                    Debug(
                        9 as libc::c_int,
                        b"%3d : %d\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i * 10 as libc::c_int,
                        platauHistogram[i as usize],
                    );
                }
                i += 1;
            }
            a = a * 6 as libc::c_int / 10 as libc::c_int;
            j = 0 as libc::c_int;
            i = 0 as libc::c_int;
            while j < a {
                let fresh30 = i;
                i = i + 1;
                j += platauHistogram[fresh30 as usize];
            }
            ms = i * 10 as libc::c_int;
            Debug(
                7 as libc::c_int,
                b"Calculated silence level = %d\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                ms,
            );
            if ms > 0 as libc::c_int && ms < 10 as libc::c_int {
                ms = 10 as libc::c_int;
            }
            if ms < 50 as libc::c_int {
                mv = (1.5f64 * ms as libc::c_double) as libc::c_int;
            } else if ms < 100 as libc::c_int {
                mv = 2 as libc::c_int * ms;
            } else if ms < 200 as libc::c_int {
                mv = 2 as libc::c_int * ms;
            } else {
                mv = 2 as libc::c_int * ms;
            }
        }
        if !(mv == 0 as libc::c_int || plataus < 5 as libc::c_int) {
            break;
        }
        volume_delta *= 2 as libc::c_int;
        if !(volume_delta < 300 as libc::c_int) {
            break;
        }
    }
    if max_volume == 0 as libc::c_int {
        max_volume = mv;
        max_silence = ms;
    }
    if max_volume == 0 as libc::c_int {
        let mut current_block_113: u64;
        if framearray {
            count = 21 as libc::c_int;
            current_block_113 = 14169744126884478827;
        } else {
            current_block_113 = 15460309861373144675;
        }
        loop {
            match current_block_113 {
                14169744126884478827 => {
                    a = 500 as libc::c_int;
                    k = 0 as libc::c_int;
                    if (*frame.offset(i as isize)).volume > 0 as libc::c_int {
                        j = (*frame.offset(i as isize)).volume;
                    } else {
                        j = 0 as libc::c_int;
                    }
                    i = 1 as libc::c_int;
                    while (i as libc::c_long) < frame_count {
                        if (*frame.offset(i as isize)).volume > 0 as libc::c_int
                            && (*frame.offset(i as isize)).volume < a
                        {
                            if (*frame.offset(i as isize)).volume < j {
                                j = (*frame.offset(i as isize)).volume;
                            }
                            k += 1;
                            if k > count
                                && a > (*frame.offset((i - count) as isize)).volume
                                    + 20 as libc::c_int
                                && j > a - 250 as libc::c_int
                            {
                                i = i - count;
                                a = (*frame.offset(i as isize)).volume;
                                j = (*frame.offset(i as isize)).volume;
                                k = 0 as libc::c_int;
                            }
                        } else {
                            k = 0 as libc::c_int;
                            if (*frame.offset(i as isize)).volume > 0 as libc::c_int {
                                j = (*frame.offset(i as isize)).volume;
                            }
                        }
                        i += 1;
                    }
                    current_block_113 = 15460309861373144675;
                }
                _ => {
                    if !(a > 500 as libc::c_int - 100 as libc::c_int && count > 7 as libc::c_int) {
                        break;
                    }
                    count = count - 7 as libc::c_int;
                    current_block_113 = 14169744126884478827;
                }
            }
        }
        max_silence = a + 10 as libc::c_int;
        max_volume = a + 150 as libc::c_int;
    }
    if max_volume == 0 as libc::c_int {
        k = 2 as libc::c_int;
        while k < 255 as libc::c_int {
            if volumeHistogram[k as usize] > 10 as libc::c_int {
                max_volume = k * volumeScale + 200 as libc::c_int;
                max_silence = k * volumeScale + 20 as libc::c_int;
                break;
            } else {
                k += 1;
            }
        }
        Debug(
            1 as libc::c_int,
            b"Setting max_volume to %i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            max_volume,
        );
    }
    if commDetectMethod & 2 as libc::c_int != 0 {
        ProcessLogoTest(
            frame_count as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
        );
        if logo_quality == 0.0f64 {
            FindLogoThreshold();
        }
        i = (logo_block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        while i >= 0 as libc::c_int {
            if (if !frame.is_null() {
                (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*logo_block.offset(i as isize)).end >= framenum_real {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((*logo_block.offset(i as isize)).end as isize)).pts
                    })
                })
            } else {
                (*logo_block.offset(i as isize)).end as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if (*logo_block.offset(i as isize)).start <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*logo_block.offset(i as isize)).start >= framenum_real {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((*logo_block.offset(i as isize)).start as isize)).pts
                    })
                })
            } else {
                (*logo_block.offset(i as isize)).start as libc::c_double / fps
            }) < min_commercial_size - 2 as libc::c_int as libc::c_double * shrink_logo
            {
                Debug(
                    1 as libc::c_int,
                    b"Logo cblock %d deleted because too short (%i s)\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    i,
                    ((if !frame.is_null() {
                        (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*logo_block.offset(i as isize)).end >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((*logo_block.offset(i as isize)).end as isize)).pts
                            })
                        })
                    } else {
                        (*logo_block.offset(i as isize)).end as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if (*logo_block.offset(i as isize)).start <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*logo_block.offset(i as isize)).start >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((*logo_block.offset(i as isize)).start as isize)).pts
                            })
                        })
                    } else {
                        (*logo_block.offset(i as isize)).start as libc::c_double / fps
                    })) as libc::c_int,
                );
                t = i;
                while ((t + 1 as libc::c_int) as libc::c_long) < logo_block_count {
                    *logo_block.offset(t as isize) =
                        *logo_block.offset((t + 1 as libc::c_int) as isize);
                    t += 1;
                }
                logo_block_count -= 1;
            }
            i -= 1;
        }
        if logoPercentage > logo_fraction
            && after_logo > 0 as libc::c_int
            && framearray as libc::c_int != 0
            && logo_block_count > 0 as libc::c_int as libc::c_long
        {
            i = 0 as libc::c_int;
            while (i as libc::c_long) < logo_block_count {
                if !((i as libc::c_long) < logo_block_count - 1 as libc::c_int as libc::c_long
                    && (if !frame.is_null() {
                        (if (*logo_block.offset((i + 1 as libc::c_int) as isize)).start
                            <= 0 as libc::c_int
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*logo_block.offset((i + 1 as libc::c_int) as isize)).start
                                >= framenum_real
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(
                                    (*logo_block.offset((i + 1 as libc::c_int) as isize)).start
                                        as isize,
                                ))
                                .pts
                            })
                        })
                    } else {
                        (*logo_block.offset((i + 1 as libc::c_int) as isize)).start
                            as libc::c_double
                            / fps
                    }) - (if !frame.is_null() {
                        (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*logo_block.offset(i as isize)).end >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((*logo_block.offset(i as isize)).end as isize)).pts
                            })
                        })
                    } else {
                        (*logo_block.offset(i as isize)).end as libc::c_double / fps
                    }) < max_commercialbreak / 4 as libc::c_int as libc::c_double)
                {
                    if !(i as libc::c_long == logo_block_count - 1 as libc::c_int as libc::c_long
                        && (if !frame.is_null() {
                            (if frame_count <= 0 as libc::c_int as libc::c_long {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if frame_count >= framenum_real as libc::c_long {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                                } else {
                                    (*frame.offset(frame_count as isize)).pts
                                })
                            })
                        } else {
                            frame_count as libc::c_double / fps
                        }) - (if !frame.is_null() {
                            (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if (*logo_block.offset(i as isize)).end >= framenum_real {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                                } else {
                                    (*frame.offset((*logo_block.offset(i as isize)).end as isize))
                                        .pts
                                })
                            })
                        } else {
                            (*logo_block.offset(i as isize)).end as libc::c_double / fps
                        }) < max_commercialbreak / 4 as libc::c_int as libc::c_double)
                    {
                        if after_logo == 999 as libc::c_int {
                            j = (*logo_block.offset(i as isize)).end;
                            InsertBlackFrame(
                                j,
                                (*frame.offset(j as isize)).brightness,
                                (*frame.offset(j as isize)).uniform,
                                0 as libc::c_int,
                                (1 as libc::c_int) << 0 as libc::c_int,
                            );
                            Debug(
                                3 as libc::c_int,
                                b"Frame %6i (%.3fs) - Cutpoint added when Logo disappears\n\0"
                                    as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                get_frame_pts(j),
                                j,
                            );
                        } else {
                            j = (*logo_block.offset(i as isize)).end
                                + (after_logo as libc::c_double * fps) as libc::c_int;
                            if j as libc::c_long >= frame_count {
                                j = (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
                            }
                            t = j + (30 as libc::c_int as libc::c_double * fps) as libc::c_int;
                            if t as libc::c_long >= frame_count {
                                t = (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
                            }
                            maxsc = 255 as libc::c_int;
                            cp = 0 as libc::c_int;
                            cpf = 0 as libc::c_int;
                            while j < t {
                                rsc = 255 as libc::c_int;
                                while (*frame.offset(j as isize)).volume >= max_volume && j < t {
                                    j += 1;
                                }
                                if j == t {
                                    break;
                                }
                                c = 10 as libc::c_int;
                                j = j - 10 as libc::c_int;
                                if j < 1 as libc::c_int {
                                    j = j - 1 as libc::c_int;
                                    c = c + j;
                                    j = 1 as libc::c_int;
                                }
                                loop {
                                    let fresh31 = c;
                                    c = c - 1;
                                    if !(fresh31 != 0 && j < t) {
                                        break;
                                    }
                                    if rsc > (*frame.offset(j as isize)).schange_percent {
                                        rsc = (*frame.offset(j as isize)).schange_percent;
                                        cpf = j;
                                    }
                                    j += 1;
                                }
                                if j == t {
                                    break;
                                }
                                while (*frame.offset(j as isize)).volume < max_volume && j < t {
                                    if rsc > (*frame.offset(j as isize)).schange_percent {
                                        rsc = (*frame.offset(j as isize)).schange_percent;
                                        cpf = j;
                                    }
                                    j += 1;
                                }
                                if j == t {
                                    break;
                                }
                                c = 10 as libc::c_int;
                                loop {
                                    let fresh32 = c;
                                    c = c - 1;
                                    if !(fresh32 != 0 && j < t) {
                                        break;
                                    }
                                    if rsc > (*frame.offset(j as isize)).schange_percent {
                                        rsc = (*frame.offset(j as isize)).schange_percent;
                                        cpf = j;
                                    }
                                    j += 1;
                                }
                                if j == t {
                                    break;
                                }
                                if maxsc > rsc {
                                    maxsc = rsc;
                                    cp = cpf;
                                }
                                j = t;
                            }
                            if cp != 0 as libc::c_int {
                                InsertBlackFrame(
                                    cp,
                                    (*frame.offset(cp as isize)).brightness,
                                    (*frame.offset(cp as isize)).uniform,
                                    (*frame.offset(cp as isize)).volume,
                                    (1 as libc::c_int) << 0 as libc::c_int,
                                );
                                Debug(
                                    3 as libc::c_int,
                                    b"Frame %6i (%.3fs) - Cutpoint added %i seconds after Logo disappears at change percentage of %d\n\0"
                                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                                    cp,
                                    get_frame_pts(cp),
                                    ((if !frame.is_null() {
                                        (if cp <= 0 as libc::c_int {
                                            (*frame.offset(1 as libc::c_int as isize)).pts
                                        } else {
                                            (if cp >= framenum_real {
                                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                                    .pts
                                            } else {
                                                (*frame.offset(cp as isize)).pts
                                            })
                                        })
                                    } else {
                                        cp as libc::c_double / fps
                                    })
                                        - (if !frame.is_null() {
                                            (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int
                                            {
                                                (*frame.offset(1 as libc::c_int as isize)).pts
                                            } else {
                                                (if (*logo_block.offset(i as isize)).end >= framenum_real {
                                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                                        .pts
                                                } else {
                                                    (*frame
                                                        .offset((*logo_block.offset(i as isize)).end as isize))
                                                        .pts
                                                })
                                            })
                                        } else {
                                            (*logo_block.offset(i as isize)).end as libc::c_double / fps
                                        })) as libc::c_int,
                                    maxsc,
                                );
                            }
                        }
                    }
                }
                i += 1;
            }
        }
        if logoPercentage > logo_fraction
            && before_logo > 0 as libc::c_int
            && framearray as libc::c_int != 0
            && logo_block_count > 0 as libc::c_int as libc::c_long
        {
            i = 0 as libc::c_int;
            while (i as libc::c_long) < logo_block_count {
                if !(i > 0 as libc::c_int
                    && (if !frame.is_null() {
                        (if (*logo_block.offset(i as isize)).start <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*logo_block.offset(i as isize)).start >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((*logo_block.offset(i as isize)).start as isize)).pts
                            })
                        })
                    } else {
                        (*logo_block.offset(i as isize)).start as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if (*logo_block.offset((i - 1 as libc::c_int) as isize)).end
                            <= 0 as libc::c_int
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*logo_block.offset((i - 1 as libc::c_int) as isize)).end
                                >= framenum_real
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(
                                    (*logo_block.offset((i - 1 as libc::c_int) as isize)).end
                                        as isize,
                                ))
                                .pts
                            })
                        })
                    } else {
                        (*logo_block.offset((i - 1 as libc::c_int) as isize)).end as libc::c_double
                            / fps
                    }) < max_commercialbreak / 4 as libc::c_int as libc::c_double)
                {
                    if !(i == 0 as libc::c_int
                        && (if !frame.is_null() {
                            (if (*logo_block.offset(i as isize)).start <= 0 as libc::c_int {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if (*logo_block.offset(i as isize)).start >= framenum_real {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                                } else {
                                    (*frame.offset((*logo_block.offset(i as isize)).start as isize))
                                        .pts
                                })
                            })
                        } else {
                            (*logo_block.offset(i as isize)).start as libc::c_double / fps
                        }) < max_commercialbreak / 4 as libc::c_int as libc::c_double)
                    {
                        if before_logo == 999 as libc::c_int {
                            j = (*logo_block.offset(i as isize)).start;
                            InsertBlackFrame(
                                j,
                                (*frame.offset(j as isize)).brightness,
                                (*frame.offset(j as isize)).uniform,
                                0 as libc::c_int,
                                (1 as libc::c_int) << 0 as libc::c_int,
                            );
                            Debug(
                                3 as libc::c_int,
                                b"Frame %6i (%.3fs) - Cutpoint added when Logo appears\n\0"
                                    as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                j,
                                get_frame_pts(j),
                            );
                        } else {
                            j = (*logo_block.offset(i as isize)).start
                                - (before_logo as libc::c_double * fps) as libc::c_int;
                            if j < 1 as libc::c_int {
                                j = 1 as libc::c_int;
                            }
                            t = j - (30 as libc::c_int as libc::c_double * fps) as libc::c_int;
                            if t < 1 as libc::c_int {
                                t = 1 as libc::c_int;
                            }
                            maxsc = 255 as libc::c_int;
                            cp = 0 as libc::c_int;
                            cpf = 0 as libc::c_int;
                            while j > t {
                                rsc = 255 as libc::c_int;
                                while (*frame.offset(j as isize)).volume >= max_volume && j > t {
                                    j -= 1;
                                }
                                if j == t {
                                    break;
                                }
                                c = 10 as libc::c_int;
                                j = j + 10 as libc::c_int;
                                if j as libc::c_long >= frame_count {
                                    j = (j as libc::c_long - frame_count) as libc::c_int;
                                    c = c - j;
                                    j = (frame_count - 1 as libc::c_int as libc::c_long)
                                        as libc::c_int;
                                }
                                loop {
                                    let fresh33 = c;
                                    c = c - 1;
                                    if !(fresh33 != 0 && j > t) {
                                        break;
                                    }
                                    if rsc > (*frame.offset(j as isize)).schange_percent {
                                        rsc = (*frame.offset(j as isize)).schange_percent;
                                        cpf = j;
                                    }
                                    j -= 1;
                                }
                                if j == t {
                                    break;
                                }
                                while (*frame.offset(j as isize)).volume < max_volume && j > t {
                                    if rsc > (*frame.offset(j as isize)).schange_percent {
                                        rsc = (*frame.offset(j as isize)).schange_percent;
                                        cpf = j;
                                    }
                                    j -= 1;
                                }
                                if j == t {
                                    break;
                                }
                                c = 10 as libc::c_int;
                                loop {
                                    let fresh34 = c;
                                    c = c - 1;
                                    if !(fresh34 != 0 && j > t) {
                                        break;
                                    }
                                    if rsc > (*frame.offset(j as isize)).schange_percent {
                                        rsc = (*frame.offset(j as isize)).schange_percent;
                                        cpf = j;
                                    }
                                    j -= 1;
                                }
                                if j == t {
                                    break;
                                }
                                if maxsc > rsc {
                                    maxsc = rsc;
                                    cp = cpf;
                                }
                                j = t;
                            }
                            if cp != 0 as libc::c_int {
                                InsertBlackFrame(
                                    cp,
                                    (*frame.offset(cp as isize)).brightness,
                                    (*frame.offset(cp as isize)).uniform,
                                    (*frame.offset(cp as isize)).volume,
                                    (1 as libc::c_int) << 0 as libc::c_int,
                                );
                                Debug(
                                    3 as libc::c_int,
                                    b"Frame %6i (%.3fs) - Cutpoint added %i seconds before Logo appears at change percentage of %d\n\0"
                                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                                    cp,
                                    get_frame_pts(cp),
                                    ((if !frame.is_null() {
                                        (if (*logo_block.offset(i as isize)).start
                                            <= 0 as libc::c_int
                                        {
                                            (*frame.offset(1 as libc::c_int as isize)).pts
                                        } else {
                                            (if (*logo_block.offset(i as isize)).start >= framenum_real
                                            {
                                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                                    .pts
                                            } else {
                                                (*frame
                                                    .offset((*logo_block.offset(i as isize)).start as isize))
                                                    .pts
                                            })
                                        })
                                    } else {
                                        (*logo_block.offset(i as isize)).start as libc::c_double
                                            / fps
                                    })
                                        - (if !frame.is_null() {
                                            (if cp <= 0 as libc::c_int {
                                                (*frame.offset(1 as libc::c_int as isize)).pts
                                            } else {
                                                (if cp >= framenum_real {
                                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                                        .pts
                                                } else {
                                                    (*frame.offset(cp as isize)).pts
                                                })
                                            })
                                        } else {
                                            cp as libc::c_double / fps
                                        })) as libc::c_int,
                                    maxsc,
                                );
                            }
                        }
                    }
                }
                i += 1;
            }
        }
        if logoPercentage < logo_fraction - 0.05f64 || logoPercentage > logo_percentile {
            Debug(
                1 as libc::c_int,
                b"\nNot enough or too much logo's found (%.2f), disabling the use of Logo detection\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                logoPercentage,
            );
            commDetectMethod -= 2 as libc::c_int;
        }
    }
    if remove_silent_segments != 0 {
        i = 1 as libc::c_int;
        j = 1 as libc::c_int;
        i = 1 as libc::c_int;
        while (i as libc::c_long) < frame_count {
            if (*frame.offset(i as isize)).volume < 5 as libc::c_int {
                j = i + 1 as libc::c_int;
                while (j as libc::c_long) < frame_count
                    && (*frame.offset(j as isize)).volume < 10 as libc::c_int
                {
                    j += 1;
                }
                if (*frame.offset((j - 1 as libc::c_int) as isize)).pts
                    - (*frame.offset(i as isize)).pts
                    > remove_silent_segments as libc::c_double
                {
                    Debug(
                        4 as libc::c_int,
                        b"\nDetected a long silent segment from frames %d till %d\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        i,
                        j - 1 as libc::c_int,
                    );
                    InsertBlackFrame(
                        i,
                        (*frame.offset(i as isize)).brightness,
                        (*frame.offset(i as isize)).uniform,
                        (*frame.offset(i as isize)).volume,
                        ((1 as libc::c_int as libc::c_long) << 18 as libc::c_int) as libc::c_int,
                    );
                    InsertBlackFrame(
                        j - 1 as libc::c_int,
                        (*frame.offset((j - 1 as libc::c_int) as isize)).brightness,
                        (*frame.offset((j - 1 as libc::c_int) as isize)).uniform,
                        (*frame.offset(j as isize)).volume,
                        ((1 as libc::c_int as libc::c_long) << 18 as libc::c_int) as libc::c_int,
                    );
                }
                i = j + 1 as libc::c_int;
            }
            i += 1;
        }
    }
    if commDetectMethod & 64 as libc::c_int != 0 {
        silence_count = 0 as libc::c_int;
        schange_found = 0 as libc::c_int;
        schange_frame = 0 as libc::c_int;
        schange_max = 100 as libc::c_int;
        low_volume_count = 0 as libc::c_int;
        very_low_volume_count = 0 as libc::c_int;
        i = 1 as libc::c_int;
        while (i as libc::c_long) < frame_count {
            if (*frame.offset(i as isize)).volume < 6 as libc::c_int {
                InsertBlackFrame(
                    i,
                    (*frame.offset(i as isize)).brightness,
                    (*frame.offset(i as isize)).uniform,
                    (*frame.offset(i as isize)).volume,
                    ((1 as libc::c_int as libc::c_long) << 18 as libc::c_int) as libc::c_int,
                );
            } else if min_silence > 0 as libc::c_int {
                if 0 as libc::c_int <= (*frame.offset(i as isize)).volume
                    && (*frame.offset(i as isize)).volume < max_silence
                {
                    if silence_start == 0 as libc::c_int {
                        silence_start = i;
                    }
                    silence_count += 1;
                    if (*frame.offset(i as isize)).schange_percent < schange_threshold {
                        schange_found = 1 as libc::c_int;
                        if schange_max > (*frame.offset(i as isize)).schange_percent {
                            schange_frame = i;
                            schange_max = (*frame.offset(i as isize)).schange_percent;
                        }
                    }
                    if (*frame.offset(i as isize)).uniform < non_uniformity {
                        schange_found = 1 as libc::c_int;
                        schange_frame = i;
                    }
                    if (*frame.offset(i as isize)).volume < max_silence {
                        low_volume_count += 1;
                    }
                    if (*frame.offset(i as isize)).volume < 9 as libc::c_int {
                        very_low_volume_count += 1;
                    }
                } else {
                    if silence_count > min_silence
                        && (silence_count as libc::c_double)
                            < 5 as libc::c_int as libc::c_double * fps
                    {
                        if very_low_volume_count
                            > (silence_count as libc::c_double * 0.7f64) as libc::c_int
                            || schange_found != 0
                            || (*frame.offset(i as isize)).schange_percent < schange_threshold
                        {
                            summed_volume1 = 0 as libc::c_int;
                            j = max(
                                silence_start - (2.5f64 * fps) as libc::c_int,
                                1 as libc::c_int,
                            );
                            while j < silence_start {
                                summed_volume1 += (*frame.offset(j as isize)).volume;
                                j += 1;
                            }
                            summed_volume1 /= min(
                                (2.5f64 * fps) as libc::c_int,
                                silence_start + 1 as libc::c_int,
                            );
                            summed_volume2 = 0 as libc::c_int;
                            j = i;
                            while j < min(
                                i + (2.5f64 * fps) as libc::c_int,
                                frame_count as libc::c_int,
                            ) {
                                summed_volume2 += (*frame.offset(j as isize)).volume;
                                j += 1;
                            }
                            summed_volume2 /= min(
                                (2.5f64 * fps) as libc::c_int,
                                (frame_count - i as libc::c_long + 1 as libc::c_int as libc::c_long)
                                    as libc::c_int,
                            );
                            if summed_volume1 as libc::c_double
                                > 0.9f64 * max_volume as libc::c_double
                                && summed_volume2 as libc::c_double
                                    > 0.9f64 * max_volume as libc::c_double
                                && low_volume_count > min_silence
                                || summed_volume1 > 2 as libc::c_int * max_volume
                                    && summed_volume2 > 2 as libc::c_int * max_volume
                                || (summed_volume1 > 4 as libc::c_int * max_volume
                                    || summed_volume2 > 4 as libc::c_int * max_volume)
                                || very_low_volume_count > min_silence
                            {
                                if schange_frame == 0 as libc::c_int {
                                    schange_frame = i;
                                }
                                j = silence_start;
                                while j < i {
                                    let ref mut fresh35 = (*frame.offset(j as isize)).isblack;
                                    *fresh35 = (*fresh35 as libc::c_long
                                        | (1 as libc::c_int as libc::c_long) << 18 as libc::c_int)
                                        != 0;
                                    InsertBlackFrame(
                                        j,
                                        (*frame.offset(j as isize)).brightness,
                                        (*frame.offset(j as isize)).uniform,
                                        (*frame.offset(j as isize)).volume,
                                        ((1 as libc::c_int as libc::c_long) << 18 as libc::c_int)
                                            as libc::c_int,
                                    );
                                    j += 1;
                                }
                            }
                        }
                    }
                    silence_start = 0 as libc::c_int;
                    silence_count = 0 as libc::c_int;
                    schange_found = 0 as libc::c_int;
                    schange_frame = 0 as libc::c_int;
                    schange_max = 100 as libc::c_int;
                    low_volume_count = 0 as libc::c_int;
                    very_low_volume_count = 0 as libc::c_int;
                }
            }
            i += 1;
        }
    }
    after_start = (added_recording as libc::c_double * fps * 60 as libc::c_int as libc::c_double)
        as libc::c_int;
    before_end = (frame_count as libc::c_double
        - added_recording as libc::c_double * fps * 60 as libc::c_int as libc::c_double)
        as libc::c_int;
    (*frame.offset(frame_count as isize)).dimCount = 0 as libc::c_int;
    (*frame.offset(frame_count as isize)).hasBright = 0 as libc::c_int;
    InsertBlackFrame(
        frame_count as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        (1 as libc::c_int) << 4 as libc::c_int,
    );
    if cut_on_ac_change != 0 {
        if (*ac_block.offset(ac_block_count as isize)).start > 0 as libc::c_int {
            Debug(
                5 as libc::c_int,
                b"The last ar cblock wasn't closed.  Now closing.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            (*ac_block.offset(ac_block_count as isize)).end = frame_count as libc::c_int;
            ac_block_count += 1;
        }
        FillACHistogram(1 as libc::c_int != 0);
        dominant_ac = ac_histogram[0 as libc::c_int as usize].audio_channels;
        Debug(
            4 as libc::c_int,
            b"\nPrinting AC cblock list\n-----------------------------------------\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        i = 0 as libc::c_int;
        while (i as libc::c_long) < ac_block_count {
            Debug(
                4 as libc::c_int,
                b"Block: %i\tStart: %6i\tEnd: %6i\taudio channels: %2i\tLength: %s\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                i,
                (*ac_block.offset(i as isize)).start,
                (*ac_block.offset(i as isize)).end,
                (*ac_block.offset(i as isize)).audio_channels,
                dblSecondsToStrMinutes(
                    (if !frame.is_null() {
                        (if (*ac_block.offset(i as isize)).end <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*ac_block.offset(i as isize)).end >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((*ac_block.offset(i as isize)).end as isize)).pts
                            })
                        })
                    } else {
                        (*ac_block.offset(i as isize)).end as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if (*ac_block.offset(i as isize)).start <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*ac_block.offset(i as isize)).start >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((*ac_block.offset(i as isize)).start as isize)).pts
                            })
                        })
                    } else {
                        (*ac_block.offset(i as isize)).start as libc::c_double / fps
                    }),
                ),
            );
            i += 1;
        }
    }
    if commDetectMethod & 32 as libc::c_int != 0 {
        if (*ar_block.offset(ar_block_count as isize)).start > 0 as libc::c_int {
            Debug(
                5 as libc::c_int,
                b"The last ar cblock wasn't closed.  Now closing.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            (*ar_block.offset(ar_block_count as isize)).end = frame_count as libc::c_int;
            ar_block_count += 1;
        }
        Debug(
            9 as libc::c_int,
            b"\nPrinting AR cblock list before cleaning\n-----------------------------------------\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        i = 0 as libc::c_int;
        while (i as libc::c_long) < ar_block_count {
            Debug(
                9 as libc::c_int,
                b"Block: %i\tStart: %6i\tEnd: %6i\tAR_R: %.2f\tLength: %s, [%4dx%4d] minX=%3d, minY=%3d, maxX=%3d, maxY=%3d\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
                (*ar_block.offset(i as isize)).start,
                (*ar_block.offset(i as isize)).end,
                (*ar_block.offset(i as isize)).ar_ratio,
                dblSecondsToStrMinutes(
                    (if !frame.is_null() {
                        (if (*ar_block.offset(i as isize)).end <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*ar_block.offset(i as isize)).end >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                    .pts
                            } else {
                                (*frame.offset((*ar_block.offset(i as isize)).end as isize))
                                    .pts
                            })
                        })
                    } else {
                        (*ar_block.offset(i as isize)).end as libc::c_double / fps
                    })
                        - (if !frame.is_null() {
                            (if (*ar_block.offset(i as isize)).start <= 0 as libc::c_int
                            {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if (*ar_block.offset(i as isize)).start >= framenum_real {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                        .pts
                                } else {
                                    (*frame
                                        .offset((*ar_block.offset(i as isize)).start as isize))
                                        .pts
                                })
                            })
                        } else {
                            (*ar_block.offset(i as isize)).start as libc::c_double / fps
                        }),
                ),
                (*ar_block.offset(i as isize)).width,
                (*ar_block.offset(i as isize)).height,
                (*ar_block.offset(i as isize)).minX,
                (*ar_block.offset(i as isize)).minY,
                (*ar_block.offset(i as isize)).maxX,
                (*ar_block.offset(i as isize)).maxY,
            );
            i += 1;
        }
        FillARHistogram(0 as libc::c_int != 0);
        i = 0 as libc::c_int;
        while i < 1000 as libc::c_int {
            j = i + 1 as libc::c_int;
            while j < 1000 as libc::c_int {
                if ar_histogram[j as usize].ar_ratio < ar_histogram[i as usize].ar_ratio + ar_delta
                    && ar_histogram[j as usize].ar_ratio
                        > ar_histogram[i as usize].ar_ratio - ar_delta
                {
                    ar_histogram[j as usize].ar_ratio = ar_histogram[i as usize].ar_ratio;
                }
                j += 1;
            }
            i += 1;
        }
        i = 0 as libc::c_int;
        while (i as libc::c_long) < ar_block_count {
            new_ar_ratio = FindARFromHistogram((*ar_block.offset(i as isize)).ar_ratio);
            (*ar_block.offset(i as isize)).ar_ratio = new_ar_ratio;
            i += 1;
        }
        FillARHistogram(1 as libc::c_int != 0);
        dominant_ar = ar_histogram[0 as libc::c_int as usize].ar_ratio;
        's_2105: loop {
            i = (ar_block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
            loop {
                if !(i > 0 as libc::c_int) {
                    break 's_2105;
                }
                length = ((*ar_block.offset(i as isize)).end - (*ar_block.offset(i as isize)).start)
                    as libc::c_double;
                if cut_on_ar_change > 2 as libc::c_int
                    && length < (cut_on_ar_change * fps as libc::c_int) as libc::c_double
                    && (*ar_block.offset(i as isize)).ar_ratio != 0.0f64
                {
                    Debug(
                        6 as libc::c_int,
                        b"Undefining AR cblock %i because it is too short\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        i,
                        dblSecondsToStrMinutes(length / fps),
                    );
                    (*ar_block.offset(i as isize)).ar_ratio = 0.0f64;
                    break;
                } else if commDetectMethod & 2 as libc::c_int != 0
                    && (*ar_block.offset((i - 1 as libc::c_int) as isize)).ar_ratio != 0.0f64
                    && (*ar_block.offset(i as isize)).ar_ratio
                        > (*ar_block.offset((i - 1 as libc::c_int) as isize)).ar_ratio
                    && CheckFrameForLogo((*ar_block.offset((i - 1 as libc::c_int) as isize)).end)
                        as libc::c_int
                        != 0
                    && CheckFrameForLogo((*ar_block.offset(i as isize)).start) as libc::c_int != 0
                {
                    if (*ar_block.offset(i as isize)).end - (*ar_block.offset(i as isize)).start
                        > (*ar_block.offset((i - 1 as libc::c_int) as isize)).end
                            - (*ar_block.offset((i - 1 as libc::c_int) as isize)).start
                    {
                        j = (*ar_block.offset((i - 1 as libc::c_int) as isize)).start;
                        *ar_block.offset((i - 1 as libc::c_int) as isize) =
                            *ar_block.offset(i as isize);
                        (*ar_block.offset((i - 1 as libc::c_int) as isize)).start = j;
                    } else {
                        (*ar_block.offset((i - 1 as libc::c_int) as isize)).end =
                            (*ar_block.offset(i as isize)).end;
                    }
                    ar_block_count -= 1;
                    Debug(
                        6 as libc::c_int,
                        b"Joining AR blocks %i and %i because both have logo\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        i - 1 as libc::c_int,
                        i,
                        i,
                        dblSecondsToStrMinutes(length / fps),
                    );
                    j = i;
                    while (j as libc::c_long) < ar_block_count {
                        *ar_block.offset(j as isize) =
                            *ar_block.offset((j + 1 as libc::c_int) as isize);
                        j += 1;
                    }
                    break;
                } else if i == 1 as libc::c_int
                    && (*ar_block.offset((i - 1 as libc::c_int) as isize)).ar_ratio == 0.0f64
                {
                    j = (*ar_block.offset((i - 1 as libc::c_int) as isize)).start;
                    *ar_block.offset((i - 1 as libc::c_int) as isize) =
                        *ar_block.offset(i as isize);
                    (*ar_block.offset((i - 1 as libc::c_int) as isize)).start = j;
                    ar_block_count -= 1;
                    Debug(
                        6 as libc::c_int,
                        b"Joining AR blocks %i and %i because cblock 0 has an AR ratio of 0.0\n\0"
                            as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        i - 1 as libc::c_int,
                        i,
                        (*ar_block.offset((i - 1 as libc::c_int) as isize)).ar_ratio,
                    );
                    j = i;
                    while (j as libc::c_long) < ar_block_count {
                        *ar_block.offset(j as isize) =
                            *ar_block.offset((j + 1 as libc::c_int) as isize);
                        j += 1;
                    }
                    break;
                } else if (*ar_block.offset(i as isize)).ar_ratio
                    - (*ar_block.offset((i - 1 as libc::c_int) as isize)).ar_ratio
                    < ar_delta
                    && (*ar_block.offset(i as isize)).ar_ratio
                        - (*ar_block.offset((i - 1 as libc::c_int) as isize)).ar_ratio
                        > -ar_delta
                {
                    (*ar_block.offset((i - 1 as libc::c_int) as isize)).end =
                        (*ar_block.offset(i as isize)).end;
                    ar_block_count -= 1;
                    Debug(
                        6 as libc::c_int,
                        b"Joining AR blocks %i and %i because both have an AR ratio of %.2f\n\0"
                            as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        i - 1 as libc::c_int,
                        i,
                        (*ar_block.offset(i as isize)).ar_ratio,
                    );
                    j = i;
                    while (j as libc::c_long) < ar_block_count {
                        *ar_block.offset(j as isize) =
                            *ar_block.offset((j + 1 as libc::c_int) as isize);
                        j += 1;
                    }
                    break;
                } else if (*ar_block.offset((i - 1 as libc::c_int) as isize)).ar_ratio == 0.0f64
                    && i > 1 as libc::c_int
                    && (*ar_block.offset(i as isize)).ar_ratio
                        - (*ar_block.offset((i - 2 as libc::c_int) as isize)).ar_ratio
                        < ar_delta
                    && (*ar_block.offset(i as isize)).ar_ratio
                        - (*ar_block.offset((i - 2 as libc::c_int) as isize)).ar_ratio
                        > -ar_delta
                {
                    (*ar_block.offset((i - 2 as libc::c_int) as isize)).end =
                        (*ar_block.offset(i as isize)).end;
                    ar_block_count -= 2 as libc::c_int as libc::c_long;
                    Debug(
                        6 as libc::c_int,
                        b"Joining AR blocks %i and %i because they have a dummy cblock inbetween\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i - 2 as libc::c_int,
                        i,
                    );
                    j = i - 1 as libc::c_int;
                    while (j as libc::c_long) < ar_block_count {
                        *ar_block.offset(j as isize) =
                            *ar_block.offset((j + 2 as libc::c_int) as isize);
                        j += 1;
                    }
                    break;
                } else {
                    i -= 1;
                }
            }
        }
        Debug(
            4 as libc::c_int,
            b"\nPrinting AR cblock list\n-----------------------------------------\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        i = 0 as libc::c_int;
        while (i as libc::c_long) < ar_block_count {
            Debug(
                4 as libc::c_int,
                b"Block: %i\tStart: %6i\tEnd: %6i\tAR_R: %.2f\tLength: %s, [%4dx%4d] minX=%3d, minY=%3d, maxX=%3d, maxY=%3d\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
                (*ar_block.offset(i as isize)).start,
                (*ar_block.offset(i as isize)).end,
                (*ar_block.offset(i as isize)).ar_ratio,
                dblSecondsToStrMinutes(
                    (if !frame.is_null() {
                        (if (*ar_block.offset(i as isize)).end <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*ar_block.offset(i as isize)).end >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                    .pts
                            } else {
                                (*frame.offset((*ar_block.offset(i as isize)).end as isize))
                                    .pts
                            })
                        })
                    } else {
                        (*ar_block.offset(i as isize)).end as libc::c_double / fps
                    })
                        - (if !frame.is_null() {
                            (if (*ar_block.offset(i as isize)).start <= 0 as libc::c_int
                            {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if (*ar_block.offset(i as isize)).start >= framenum_real {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                        .pts
                                } else {
                                    (*frame
                                        .offset((*ar_block.offset(i as isize)).start as isize))
                                        .pts
                                })
                            })
                        } else {
                            (*ar_block.offset(i as isize)).start as libc::c_double / fps
                        }),
                ),
                (*ar_block.offset(i as isize)).width,
                (*ar_block.offset(i as isize)).height,
                (*ar_block.offset(i as isize)).minX,
                (*ar_block.offset(i as isize)).minY,
                (*ar_block.offset(i as isize)).maxX,
                (*ar_block.offset(i as isize)).maxY,
            );
            i += 1;
        }
    }
    if processCC {
        (*cc_block.offset(cc_block_count as isize)).end_frame = frame_count;
        cc_block_count += 1;
        (*cc_text.offset(cc_text_count as isize)).end_frame = frame_count;
        cc_text_count += 1;
        i = (cc_text_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        while i > 0 as libc::c_int {
            if (*cc_text.offset(i as isize)).text_len == 0 as libc::c_int as libc::c_long {
                j = i;
                while (j as libc::c_long) < cc_text_count {
                    (*cc_text.offset(j as isize)).start_frame =
                        (*cc_text.offset((j + 1 as libc::c_int) as isize)).start_frame;
                    (*cc_text.offset(j as isize)).end_frame =
                        (*cc_text.offset((j + 1 as libc::c_int) as isize)).end_frame;
                    (*cc_text.offset(j as isize)).text_len =
                        (*cc_text.offset((j + 1 as libc::c_int) as isize)).text_len;
                    strncpy(
                        ((*cc_text.offset(j as isize)).text).as_mut_ptr() as *mut libc::c_char,
                        ((*cc_text.offset((j + 1 as libc::c_int) as isize)).text).as_mut_ptr()
                            as *mut libc::c_char,
                        ::std::mem::size_of::<[libc::c_uchar; 256]>() as libc::c_ulong,
                    );
                    j += 1;
                }
                cc_text_count -= 1;
            }
            i -= 1;
        }
        Debug(
            2 as libc::c_int,
            b"Closed caption transcript\n--------------------\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        i = 0 as libc::c_int;
        while (i as libc::c_long) < cc_text_count {
            Debug(
                2 as libc::c_int,
                b"%i) S:%6i E:%6i L:%4i %s\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                (*cc_text.offset(i as isize)).start_frame,
                (*cc_text.offset(i as isize)).end_frame,
                (*cc_text.offset(i as isize)).text_len,
                ((*cc_text.offset(i as isize)).text).as_mut_ptr(),
            );
            i += 1;
        }
    }
    if output_framearray {
        OutputFrameArray(0 as libc::c_int != 0);
    }
    if output_framearray {
        OutputBlackArray();
    }
    BuildBlocks(0 as libc::c_int != 0);
    if commDetectMethod & 2 as libc::c_int != 0 {
        PrintLogoFrameGroups();
    }
    WeighBlocks();
    foundCommercials = OutputBlocks();
    if verbose != 0 {
        Debug(
            1 as libc::c_int,
            b"\n%i Frames Processed\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            framesprocessed,
        );
        log_file = myfopen(
            logfilename.as_mut_ptr(),
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        fprintf(
            log_file,
            b"################################################################\n\0" as *const u8
                as *const libc::c_char,
        );
        time(&mut ltime);
        fprintf(
            log_file,
            b"Time at end of run:\n%s\0" as *const u8 as *const libc::c_char,
            ctime(&mut ltime),
        );
        fprintf(
            log_file,
            b"################################################################\n\0" as *const u8
                as *const libc::c_char,
        );
        fclose(log_file);
        log_file = 0 as *mut FILE;
    }
    if ccCheck as libc::c_int != 0 && processCC as libc::c_int != 0 {
        let mut temp: [libc::c_char; 1024] = [0; 1024];
        let mut tempFile: *mut FILE = 0 as *mut FILE;
        if most_cc_type == 3 as libc::c_int
            || most_cc_type == 1 as libc::c_int
            || most_cc_type == 2 as libc::c_int
        {
            sprintf(
                temp.as_mut_ptr(),
                b"%s.ccyes\0" as *const u8 as *const libc::c_char,
                workbasename.as_mut_ptr(),
            );
            tempFile = myfopen(
                temp.as_mut_ptr(),
                b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            fclose(tempFile);
            sprintf(
                temp.as_mut_ptr(),
                b"%s.ccno\0" as *const u8 as *const libc::c_char,
                workbasename.as_mut_ptr(),
            );
            myremove(temp.as_mut_ptr());
        } else {
            sprintf(
                temp.as_mut_ptr(),
                b"%s.ccno\0" as *const u8 as *const libc::c_char,
                workbasename.as_mut_ptr(),
            );
            tempFile = myfopen(
                temp.as_mut_ptr(),
                b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            fclose(tempFile);
            sprintf(
                temp.as_mut_ptr(),
                b"%s.ccyes\0" as *const u8 as *const libc::c_char,
                workbasename.as_mut_ptr(),
            );
            myremove(temp.as_mut_ptr());
        }
    }
    if deleteLogoFile {
        logo_file = myfopen(
            logofilename.as_mut_ptr(),
            b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !logo_file.is_null() {
            fclose(logo_file);
            myremove(logofilename.as_mut_ptr());
        }
    }
    return foundCommercials;
}
#[no_mangle]
pub unsafe extern "C" fn WithinDivisibleTolerance(
    mut test_number: libc::c_double,
    mut divisor: libc::c_double,
    mut tolerance: libc::c_double,
) -> bool {
    let mut added: libc::c_double = 0.;
    let mut remainder: libc::c_double = 0.;
    added = test_number + tolerance;
    remainder = added - divisor * (added / divisor) as libc::c_int as libc::c_double;
    return remainder >= 0 as libc::c_int as libc::c_double
        && remainder <= 2 as libc::c_int as libc::c_double * tolerance;
}
#[no_mangle]
pub static mut beforeblocks: [libc::c_int; 100] = [0; 100];
#[no_mangle]
pub static mut afterblocks: [libc::c_int; 100] = [0; 100];
#[no_mangle]
pub static mut length_order: [libc::c_int; 2000] = [0; 2000];
#[no_mangle]
pub static mut length_sorted: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut min_val: [libc::c_int; 10] = [0; 10];
#[no_mangle]
pub static mut max_val: [libc::c_int; 10] = [0; 10];
#[no_mangle]
pub static mut delta_val: [libc::c_int; 10] = [0; 10];
#[no_mangle]
pub unsafe extern "C" fn BuildPunish() {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    if length_sorted == 0 {
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count {
            length_order[i as usize] = i;
            i += 1;
        }
        's_33: loop {
            j = 0 as libc::c_int;
            's_34: loop {
                if !((j as libc::c_long) < block_count) {
                    break 's_33;
                }
                i = j;
                while (i as libc::c_long) < block_count {
                    if cblock[length_order[i as usize] as usize].length
                        > cblock[length_order[j as usize] as usize].length
                    {
                        t = length_order[j as usize];
                        length_order[j as usize] = length_order[i as usize];
                        length_order[i as usize] = t;
                        break 's_34;
                    } else {
                        i += 1;
                    }
                }
                j += 1;
            }
        }
        length_sorted = 1 as libc::c_int;
    }
    min_val[0 as libc::c_int as usize] =
        cblock[length_order[0 as libc::c_int as usize] as usize].brightness;
    max_val[0 as libc::c_int as usize] = min_val[0 as libc::c_int as usize];
    min_val[1 as libc::c_int as usize] =
        cblock[length_order[0 as libc::c_int as usize] as usize].volume;
    max_val[1 as libc::c_int as usize] = min_val[1 as libc::c_int as usize];
    min_val[2 as libc::c_int as usize] =
        cblock[length_order[0 as libc::c_int as usize] as usize].silence;
    max_val[2 as libc::c_int as usize] = min_val[2 as libc::c_int as usize];
    min_val[3 as libc::c_int as usize] =
        cblock[length_order[0 as libc::c_int as usize] as usize].uniform;
    max_val[3 as libc::c_int as usize] = min_val[3 as libc::c_int as usize];
    min_val[4 as libc::c_int as usize] =
        cblock[length_order[0 as libc::c_int as usize] as usize].ar_ratio as libc::c_int;
    max_val[4 as libc::c_int as usize] = min_val[4 as libc::c_int as usize];
    min_val[5 as libc::c_int as usize] =
        cblock[length_order[0 as libc::c_int as usize] as usize].schange_rate as libc::c_int;
    max_val[5 as libc::c_int as usize] = min_val[5 as libc::c_int as usize];
    l = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        l = (l as libc::c_double + cblock[length_order[i as usize] as usize].length * fps)
            as libc::c_int;
        if min_val[0 as libc::c_int as usize] > cblock[length_order[i as usize] as usize].brightness
        {
            min_val[0 as libc::c_int as usize] =
                cblock[length_order[i as usize] as usize].brightness;
        }
        if max_val[0 as libc::c_int as usize] < cblock[length_order[i as usize] as usize].brightness
        {
            max_val[0 as libc::c_int as usize] =
                cblock[length_order[i as usize] as usize].brightness;
        }
        if min_val[1 as libc::c_int as usize] > cblock[length_order[i as usize] as usize].volume {
            min_val[1 as libc::c_int as usize] = cblock[length_order[i as usize] as usize].volume;
        }
        if max_val[1 as libc::c_int as usize] < cblock[length_order[i as usize] as usize].volume {
            max_val[1 as libc::c_int as usize] = cblock[length_order[i as usize] as usize].volume;
        }
        if min_val[2 as libc::c_int as usize] > cblock[length_order[i as usize] as usize].silence {
            min_val[2 as libc::c_int as usize] = cblock[length_order[i as usize] as usize].silence;
        }
        if max_val[2 as libc::c_int as usize] < cblock[length_order[i as usize] as usize].silence {
            max_val[2 as libc::c_int as usize] = cblock[length_order[i as usize] as usize].silence;
        }
        if min_val[3 as libc::c_int as usize] > cblock[length_order[i as usize] as usize].uniform {
            min_val[3 as libc::c_int as usize] = cblock[length_order[i as usize] as usize].uniform;
        }
        if max_val[3 as libc::c_int as usize] < cblock[length_order[i as usize] as usize].uniform {
            max_val[3 as libc::c_int as usize] = cblock[length_order[i as usize] as usize].uniform;
        }
        if min_val[4 as libc::c_int as usize] as libc::c_double
            > cblock[length_order[i as usize] as usize].ar_ratio
        {
            min_val[4 as libc::c_int as usize] =
                cblock[length_order[i as usize] as usize].ar_ratio as libc::c_int;
        }
        if (max_val[4 as libc::c_int as usize] as libc::c_double)
            < cblock[length_order[i as usize] as usize].ar_ratio
        {
            max_val[4 as libc::c_int as usize] =
                cblock[length_order[i as usize] as usize].ar_ratio as libc::c_int;
        }
        if min_val[5 as libc::c_int as usize] as libc::c_double
            > cblock[length_order[i as usize] as usize].schange_rate
        {
            min_val[5 as libc::c_int as usize] =
                cblock[length_order[i as usize] as usize].schange_rate as libc::c_int;
        }
        if (max_val[5 as libc::c_int as usize] as libc::c_double)
            < cblock[length_order[i as usize] as usize].schange_rate
        {
            max_val[5 as libc::c_int as usize] =
                cblock[length_order[i as usize] as usize].schange_rate as libc::c_int;
        }
        if l as libc::c_long
            > cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                * 70 as libc::c_int as libc::c_long
                / 100 as libc::c_int as libc::c_long
        {
            break;
        }
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn WeighBlocks() {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut cl: libc::c_double = 0.;
    let mut combined_length: libc::c_double = 0.;
    let mut tolerance: libc::c_double = 0.;
    let mut wscore: libc::c_double = 0.0f64;
    let mut lscore: libc::c_double = 0.0f64;
    let mut max_score: libc::c_double = 99.99f64;
    let mut max_combined_count: libc::c_int = 25 as libc::c_int;
    let mut breakforcombine: bool = 0 as libc::c_int != 0;
    if commDetectMethod & 32 as libc::c_int != 0 {
        SetARofBlocks();
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count - 2 as libc::c_int as libc::c_long {
        if cblock[i as usize].cause as libc::c_long
            & (((1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int
                | (1 as libc::c_int) << 2 as libc::c_int
                | (1 as libc::c_int) << 5 as libc::c_int
                | (1 as libc::c_int) << 3 as libc::c_int
                | (1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
            == ((1 as libc::c_int) << 5 as libc::c_int) as libc::c_long
            && cblock[(i + 1 as libc::c_int) as usize].cause as libc::c_long
                & (((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 5 as libc::c_int
                    | (1 as libc::c_int) << 3 as libc::c_int
                    | (1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                    | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                    | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                == ((1 as libc::c_int) << 5 as libc::c_int) as libc::c_long
            && cblock[(i + 1 as libc::c_int) as usize].length < 3.0f64
            && fabs(cblock[i as usize].ar_ratio - cblock[(i + 2 as libc::c_int) as usize].ar_ratio)
                < ar_delta
        {
            Debug(
                2 as libc::c_int,
                b"Deleting cblock %d starting at frame %d because too short and same AR before and after\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i + 1 as libc::c_int,
                cblock[(i + 1 as libc::c_int) as usize].f_start,
            );
            cblock[i as usize].b_tail = cblock[(i + 2 as libc::c_int) as usize].b_tail;
            cblock[i as usize].f_end = cblock[(i + 2 as libc::c_int) as usize].f_end;
            cblock[i as usize].length += cblock[(i + 1 as libc::c_int) as usize].length
                + cblock[(i + 2 as libc::c_int) as usize].length;
            j = i + 1 as libc::c_int;
            while (j as libc::c_long) < block_count - 2 as libc::c_int as libc::c_long {
                cblock[j as usize] = cblock[(j + 2 as libc::c_int) as usize];
                j += 1;
            }
            block_count = block_count - 2 as libc::c_int as libc::c_long;
        }
        i += 1;
    }
    if processCC {
        PrintCCBlocks();
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count {
            cblock[i as usize].cc_type =
                DetermineCCTypeForBlock(cblock[i as usize].f_start, cblock[i as usize].f_end);
            i += 1;
        }
    }
    if commDetectMethod & 2 as libc::c_int != 0 {
        if logoPercentage < logo_fraction - 0.05f64 || logoPercentage > logo_percentile {
            Debug(
                1 as libc::c_int,
                b"Not enough or too much logo's found, disabling the use of Logo detection\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
            );
            commDetectMethod -= 2 as libc::c_int;
            max_score = 10000 as libc::c_int as libc::c_double;
        }
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        if commDetectMethod & 2 as libc::c_int != 0 {
            cblock[i as usize].logo = CalculateLogoFraction(
                cblock[i as usize].f_start as libc::c_int,
                cblock[i as usize].f_end as libc::c_int,
            );
        } else {
            cblock[i as usize].logo = 0 as libc::c_int as libc::c_double;
        }
        i += 1;
    }
    CleanLogoBlocks();
    if commDetectMethod & 4 as libc::c_int != 0 {
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count {
            Debug(
                5 as libc::c_int,
                b"Block %.3i\tschange_rate - %.2f\t average - %.2f\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                i,
                cblock[i as usize].schange_rate,
                avg_schange,
            );
            i += 1;
        }
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        if commDetectMethod & 2 as libc::c_int != 0 {
            cblock[i as usize].logo = CalculateLogoFraction(
                cblock[i as usize].f_start as libc::c_int,
                cblock[i as usize].f_end as libc::c_int,
            );
        } else {
            cblock[i as usize].logo = 0 as libc::c_int as libc::c_double;
        }
        i += 1;
    }
    if commDetectMethod & 2 as libc::c_int != 0 && logoPercentage > 0.4f64 {
        if score_percentile + logoPercentage < 1.0f64 {
            score_percentile = logoPercentage + score_percentile;
        }
    } else if score_percentile < 0.5f64 {
        score_percentile = 0.71f64;
    }
    Debug(
        5 as libc::c_int,
        b"\nFuzzy scoring of the blocks\n---------------------------\n\0" as *const u8
            as *const libc::c_char as *mut libc::c_char,
    );
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        if i == 0 as libc::c_int || 1 as libc::c_int != 0 {
            j = i;
            combined_length = cblock[i as usize].length;
            k = j;
            if i > 0 as libc::c_int
                && (cblock[(i - 1 as libc::c_int) as usize].cause as libc::c_long
                    & (((1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int
                        | (1 as libc::c_int) << 5 as libc::c_int
                        | (1 as libc::c_int) << 3 as libc::c_int
                        | (1 as libc::c_int) << 4 as libc::c_int)
                        as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                        | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                    == ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                    || cblock[(i - 1 as libc::c_int) as usize].cause as libc::c_long
                        & (((1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int
                            | (1 as libc::c_int) << 5 as libc::c_int
                            | (1 as libc::c_int) << 3 as libc::c_int
                            | (1 as libc::c_int) << 4 as libc::c_int)
                            as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                            | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                        == ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_long)
            {
                combined_length -= cblock[i as usize].b_head as libc::c_double
                    / fps
                    / 4 as libc::c_int as libc::c_double;
            }
            if cblock[i as usize].cause as libc::c_long
                & (((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 5 as libc::c_int
                    | (1 as libc::c_int) << 3 as libc::c_int
                    | (1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                    | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                    | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                == ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                || cblock[i as usize].cause as libc::c_long
                    & (((1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 0 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int
                        | (1 as libc::c_int) << 5 as libc::c_int
                        | (1 as libc::c_int) << 3 as libc::c_int
                        | (1 as libc::c_int) << 4 as libc::c_int)
                        as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                        | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                    == ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_long
            {
                combined_length -= cblock[(j + 1 as libc::c_int) as usize].b_head as libc::c_double
                    / fps
                    / 4 as libc::c_int as libc::c_double;
            }
            combined_length -= (cblock[i as usize].b_head)
                .wrapping_add(cblock[(j + 1 as libc::c_int) as usize].b_head)
                as libc::c_double
                / fps
                / 4 as libc::c_int as libc::c_double;
            tolerance = (cblock[i as usize].b_head)
                .wrapping_add(cblock[(j + 1 as libc::c_int) as usize].b_head)
                .wrapping_add(4 as libc::c_int as libc::c_uint)
                as libc::c_double
                / fps;
            if IsStandardCommercialLength(combined_length, tolerance, 1 as libc::c_int != 0) {
                while j >= i {
                    cblock[j as usize].strict = 2 as libc::c_int;
                    Debug(
                        2 as libc::c_int,
                        b"Block %i has strict standard length for a commercial.\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        j,
                    );
                    Debug(
                        3 as libc::c_int,
                        b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        j,
                        cblock[j as usize].score,
                    );
                    cblock[j as usize].score *= length_strict_modifier;
                    Debug(
                        3 as libc::c_int,
                        b"After - %.2f\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        cblock[j as usize].score,
                    );
                    cblock[j as usize].cause |= (1 as libc::c_int) << 6 as libc::c_int;
                    cblock[j as usize].more |= (1 as libc::c_int) << 6 as libc::c_int;
                    j -= 1;
                }
            } else if IsStandardCommercialLength(combined_length, tolerance, 0 as libc::c_int != 0)
            {
                while j >= i {
                    cblock[j as usize].strict = 1 as libc::c_int;
                    Debug(
                        2 as libc::c_int,
                        b"Block %i has non-strict standard length for a commercial.\n\0"
                            as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        j,
                    );
                    Debug(
                        3 as libc::c_int,
                        b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        j,
                        cblock[j as usize].score,
                    );
                    cblock[j as usize].score *= length_nonstrict_modifier;
                    cblock[j as usize].score = if cblock[j as usize].score > max_score {
                        max_score
                    } else {
                        cblock[j as usize].score
                    };
                    Debug(
                        3 as libc::c_int,
                        b"After - %.2f\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        cblock[j as usize].score,
                    );
                    cblock[j as usize].cause |= (1 as libc::c_int) << 7 as libc::c_int;
                    cblock[j as usize].more |= (1 as libc::c_int) << 7 as libc::c_int;
                    j -= 1;
                }
            } else {
                while j >= i {
                    cblock[j as usize].strict = 0 as libc::c_int;
                    j -= 1;
                }
            }
            j = k;
        }
        if cblock[i as usize].combined_count < max_combined_count {
            combined_length = cblock[i as usize].length;
            j = 1 as libc::c_int;
            while (j as libc::c_long) < block_count - i as libc::c_long {
                IsStandardCommercialLength(
                    cblock[(i + j) as usize].length
                        - (cblock[(i + j) as usize].b_head)
                            .wrapping_add(cblock[(i + j + 1 as libc::c_int) as usize].b_head)
                            as libc::c_double
                            / fps,
                    (cblock[(i + j) as usize].bframe_count)
                        .wrapping_add(cblock[(i + j + 1 as libc::c_int) as usize].bframe_count)
                        .wrapping_add(2 as libc::c_int as libc::c_uint)
                        as libc::c_double
                        / fps,
                    1 as libc::c_int != 0,
                );
                if cblock[(i + j) as usize].combined_count > max_combined_count
                    || cblock[i as usize].combined_count > max_combined_count
                {
                    Debug(
                        3 as libc::c_int,
                        b"Not attempting to forward combine blocks %i to %i because cblock %i has already been combined %i times.\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i,
                        i + j,
                        i + j,
                        cblock[(i + j) as usize].combined_count,
                    );
                    breakforcombine = 1 as libc::c_int != 0;
                    break;
                } else {
                    tolerance = (cblock[i as usize].bframe_count)
                        .wrapping_add(cblock[(i + j + 1 as libc::c_int) as usize].bframe_count)
                        .wrapping_add(2 as libc::c_int as libc::c_uint)
                        as libc::c_double
                        / fps;
                    combined_length += cblock[(i + j) as usize].length;
                    if combined_length > max_commercial_size + tolerance {
                        break;
                    }
                    if IsStandardCommercialLength(
                        combined_length
                            - (cblock[i as usize].b_head)
                                .wrapping_add(cblock[(i + j + 1 as libc::c_int) as usize].b_head)
                                as libc::c_double
                                / fps,
                        tolerance,
                        1 as libc::c_int != 0,
                    ) as libc::c_int
                        != 0
                        && combined_length_strict_modifier != 1.0f64
                    {
                        Debug(
                            2 as libc::c_int,
                            b"Combining Blocks %i thru %i result in strict standard commercial length of %.2f with a tolerance of %f.\n\0"
                                as *const u8 as *const libc::c_char as *mut libc::c_char,
                            i,
                            i + j,
                            combined_length,
                            tolerance,
                        );
                        k = 0 as libc::c_int;
                        while k <= j {
                            Debug(
                                3 as libc::c_int,
                                b"Block %i score:\tBefore - %.2f\t\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                i + k,
                                cblock[(i + k) as usize].score,
                            );
                            cblock[(i + k) as usize].score *= 1 as libc::c_int as libc::c_double
                                + combined_length_strict_modifier
                                    / (j + 1 as libc::c_int) as libc::c_double
                                    / 2 as libc::c_int as libc::c_double;
                            cblock[(i + k) as usize].score =
                                if cblock[(i + k) as usize].score > max_score {
                                    max_score
                                } else {
                                    cblock[(i + k) as usize].score
                                };
                            cblock[(i + k) as usize].combined_count += 1 as libc::c_int;
                            Debug(
                                3 as libc::c_int,
                                b"After - %.2f\tCombined count - %i\n\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                cblock[(i + k) as usize].score,
                                cblock[(i + k) as usize].combined_count,
                            );
                            cblock[(i + k) as usize].cause |=
                                (1 as libc::c_int) << 8 as libc::c_int;
                            cblock[(i + k) as usize].more |= (1 as libc::c_int) << 8 as libc::c_int;
                            k += 1;
                        }
                    } else if IsStandardCommercialLength(
                        combined_length
                            - (cblock[i as usize].b_head)
                                .wrapping_add(cblock[(i + j + 1 as libc::c_int) as usize].b_head)
                                as libc::c_double
                                / fps,
                        tolerance,
                        0 as libc::c_int != 0,
                    ) as libc::c_int
                        != 0
                        && combined_length_nonstrict_modifier != 1.0f64
                    {
                        Debug(
                            2 as libc::c_int,
                            b"Combining Blocks %i thru %i result in non-strict standard commercial length of %.2f with a tolerance of %f.\n\0"
                                as *const u8 as *const libc::c_char as *mut libc::c_char,
                            i,
                            i + j,
                            combined_length,
                            tolerance,
                        );
                        k = 0 as libc::c_int;
                        while k <= j {
                            Debug(
                                3 as libc::c_int,
                                b"Block %i score:\tBefore - %.2f\t\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                i + k,
                                cblock[(i + k) as usize].score,
                            );
                            cblock[(i + k) as usize].score *= 1 as libc::c_int as libc::c_double
                                + combined_length_nonstrict_modifier
                                    / (j + 1 as libc::c_int) as libc::c_double
                                    / 2 as libc::c_int as libc::c_double;
                            cblock[(i + k) as usize].score =
                                if cblock[(i + k) as usize].score > max_score {
                                    max_score
                                } else {
                                    cblock[(i + k) as usize].score
                                };
                            cblock[(i + k) as usize].combined_count += 1 as libc::c_int;
                            Debug(
                                3 as libc::c_int,
                                b"After - %.2f\tCombined count - %i\n\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                cblock[(i + k) as usize].score,
                                cblock[(i + k) as usize].combined_count,
                            );
                            cblock[(i + k) as usize].cause |=
                                (1 as libc::c_int) << 8 as libc::c_int;
                            cblock[(i + k) as usize].more |= (1 as libc::c_int) << 8 as libc::c_int;
                            k += 1;
                        }
                    }
                    j += 1;
                }
            }
            if breakforcombine {
                breakforcombine = 0 as libc::c_int != 0;
            }
            combined_length = cblock[i as usize].length;
            j = 1 as libc::c_int;
            while j < i {
                if IsStandardCommercialLength(
                    cblock[(i - j) as usize].length
                        - (cblock[(i - j) as usize].b_head)
                            .wrapping_add(cblock[(i - j + 1 as libc::c_int) as usize].b_head)
                            as libc::c_double
                            / fps,
                    (cblock[(i - j) as usize].bframe_count)
                        .wrapping_add(cblock[(i - j + 1 as libc::c_int) as usize].bframe_count)
                        .wrapping_add(2 as libc::c_int as libc::c_uint)
                        as libc::c_double
                        / fps,
                    1 as libc::c_int != 0,
                ) {
                    break;
                } else if cblock[(i - j) as usize].combined_count > max_combined_count
                    || cblock[i as usize].combined_count > max_combined_count
                {
                    Debug(
                        3 as libc::c_int,
                        b"Not attempting to backward combine blocks %i to %i because cblock %i has already been combined %i times.\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i - j,
                        i,
                        i - j,
                        cblock[(i - j) as usize].combined_count,
                    );
                    breakforcombine = 1 as libc::c_int != 0;
                    break;
                } else {
                    tolerance = (cblock[(i + 1 as libc::c_int) as usize].bframe_count)
                        .wrapping_add(cblock[(i - j) as usize].bframe_count)
                        .wrapping_add(2 as libc::c_int as libc::c_uint)
                        as libc::c_double
                        / fps;
                    combined_length += cblock[(i - j) as usize].length;
                    if combined_length >= max_commercial_size {
                        break;
                    }
                    if IsStandardCommercialLength(
                        combined_length
                            - (cblock[(i + 1 as libc::c_int) as usize].b_head)
                                .wrapping_add(cblock[(i - j) as usize].b_head)
                                as libc::c_double
                                / fps,
                        tolerance,
                        1 as libc::c_int != 0,
                    ) as libc::c_int
                        != 0
                        && combined_length_strict_modifier != 1.0f64
                    {
                        Debug(
                            2 as libc::c_int,
                            b"Combining Blocks %i thru %i result in strict standard commercial length of %.2f with a tolerance of %f.\n\0"
                                as *const u8 as *const libc::c_char as *mut libc::c_char,
                            i - j,
                            i,
                            combined_length,
                            tolerance,
                        );
                        k = 0 as libc::c_int;
                        while k <= j {
                            Debug(
                                3 as libc::c_int,
                                b"Block %i score:\tBefore - %.2f\t\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                i - k,
                                cblock[(i - k) as usize].score,
                            );
                            cblock[(i - k) as usize].score *= 1 as libc::c_int as libc::c_double
                                + combined_length_strict_modifier
                                    / (j + 1 as libc::c_int) as libc::c_double
                                    / 2 as libc::c_int as libc::c_double;
                            cblock[(i - k) as usize].score =
                                if cblock[(i - k) as usize].score > max_score {
                                    max_score
                                } else {
                                    cblock[(i - k) as usize].score
                                };
                            cblock[(i - k) as usize].combined_count += 1 as libc::c_int;
                            Debug(
                                3 as libc::c_int,
                                b"After - %.2f\tCombined count - %i\n\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                cblock[(i - k) as usize].score,
                                cblock[(i - k) as usize].combined_count,
                            );
                            cblock[(i - k) as usize].cause |=
                                (1 as libc::c_int) << 8 as libc::c_int;
                            cblock[(i - k) as usize].more |= (1 as libc::c_int) << 8 as libc::c_int;
                            k += 1;
                        }
                    } else if IsStandardCommercialLength(
                        combined_length
                            - (cblock[(i + 1 as libc::c_int) as usize].b_head)
                                .wrapping_add(cblock[(i - j) as usize].b_head)
                                as libc::c_double
                                / fps,
                        tolerance,
                        0 as libc::c_int != 0,
                    ) as libc::c_int
                        != 0
                        && combined_length_nonstrict_modifier != 1.0f64
                    {
                        Debug(
                            2 as libc::c_int,
                            b"Combining Blocks %i thru %i result in non-strict standard commercial length of %.2f with a tolerance of %f.\n\0"
                                as *const u8 as *const libc::c_char as *mut libc::c_char,
                            i - j,
                            i,
                            combined_length,
                            tolerance,
                        );
                        k = 0 as libc::c_int;
                        while k <= j {
                            Debug(
                                3 as libc::c_int,
                                b"Block %i score:\tBefore - %.2f\t\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                i - k,
                                cblock[(i - k) as usize].score,
                            );
                            cblock[(i - k) as usize].score *= 1 as libc::c_int as libc::c_double
                                + combined_length_nonstrict_modifier
                                    / (j + 1 as libc::c_int) as libc::c_double
                                    / 2 as libc::c_int as libc::c_double;
                            cblock[(i - k) as usize].score =
                                if cblock[(i - k) as usize].score > max_score {
                                    max_score
                                } else {
                                    cblock[(i - k) as usize].score
                                };
                            cblock[(i - k) as usize].combined_count += 1 as libc::c_int;
                            Debug(
                                3 as libc::c_int,
                                b"After - %.2f\tCombined count - %i\n\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                cblock[(i - k) as usize].score,
                                cblock[(i - k) as usize].combined_count,
                            );
                            cblock[(i - k) as usize].cause |=
                                (1 as libc::c_int) << 8 as libc::c_int;
                            cblock[(i - k) as usize].more |= (1 as libc::c_int) << 8 as libc::c_int;
                            k += 1;
                        }
                    }
                    j += 1;
                }
            }
            if breakforcombine {
                breakforcombine = 0 as libc::c_int != 0;
            }
        }
        if commDetectMethod & 2 as libc::c_int != 0 {
            if cblock[i as usize].logo > logo_percentage_threshold {
                Debug(
                    2 as libc::c_int,
                    b"Block %i has logo.\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    i,
                );
                Debug(
                    3 as libc::c_int,
                    b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    i,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score *= logo_present_modifier;
                cblock[i as usize].score = if cblock[i as usize].score > max_score {
                    max_score
                } else {
                    cblock[i as usize].score
                };
                Debug(
                    3 as libc::c_int,
                    b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    cblock[i as usize].score,
                );
                cblock[i as usize].cause |= (1 as libc::c_int) << 9 as libc::c_int;
                cblock[i as usize].less |= (1 as libc::c_int) << 9 as libc::c_int;
            } else if punish_no_logo != 0
                && cblock[i as usize].logo < logo_percentage_threshold
                && logoPercentage > logo_fraction
            {
                Debug(
                    2 as libc::c_int,
                    b"Block %i has no logo.\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    i,
                );
                Debug(
                    3 as libc::c_int,
                    b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    i,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score *= 2 as libc::c_int as libc::c_double;
                cblock[i as usize].score = if cblock[i as usize].score > max_score {
                    max_score
                } else {
                    cblock[i as usize].score
                };
                Debug(
                    3 as libc::c_int,
                    b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    cblock[i as usize].score,
                );
                cblock[i as usize].cause |= (1 as libc::c_int) << 9 as libc::c_int;
                cblock[i as usize].more |= (1 as libc::c_int) << 9 as libc::c_int;
            }
        }
        BuildPunish();
        if punish & 1 as libc::c_int != 0
            && cblock[i as usize].brightness as libc::c_double
                > avg_brightness as libc::c_double * punish_threshold
        {
            Debug(
                2 as libc::c_int,
                b"Block %i is much brighter than average.\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= punish_modifier;
            cblock[i as usize].score = if cblock[i as usize].score > max_score {
                max_score
            } else {
                cblock[i as usize].score
            };
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 23 as libc::c_int)
                as libc::c_int;
            cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 23 as libc::c_int)
                as libc::c_int;
        }
        if punish & 2 as libc::c_int != 0
            && cblock[i as usize].uniform as libc::c_double
                > avg_uniform as libc::c_double * punish_threshold
        {
            Debug(
                2 as libc::c_int,
                b"Block %i is less uniform than average.\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= punish_modifier;
            cblock[i as usize].score = if cblock[i as usize].score > max_score {
                max_score
            } else {
                cblock[i as usize].score
            };
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 24 as libc::c_int)
                as libc::c_int;
            cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 24 as libc::c_int)
                as libc::c_int;
        }
        if punish & 4 as libc::c_int != 0
            && cblock[i as usize].volume as libc::c_double
                > avg_volume as libc::c_double * punish_threshold
        {
            Debug(
                2 as libc::c_int,
                b"Block %i is much louder than average.\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= punish_modifier;
            cblock[i as usize].score = if cblock[i as usize].score > max_score {
                max_score
            } else {
                cblock[i as usize].score
            };
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 25 as libc::c_int)
                as libc::c_int;
            cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 25 as libc::c_int)
                as libc::c_int;
        }
        if punish & 8 as libc::c_int != 0
            && cblock[i as usize].silence as libc::c_double
                > avg_silence as libc::c_double * punish_threshold
        {
            Debug(
                2 as libc::c_int,
                b"Block %i has less silence than average.\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= punish_modifier;
            cblock[i as usize].score = if cblock[i as usize].score > max_score {
                max_score
            } else {
                cblock[i as usize].score
            };
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 26 as libc::c_int)
                as libc::c_int;
            cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 26 as libc::c_int)
                as libc::c_int;
        }
        if punish & 16 as libc::c_int != 0
            && cblock[i as usize].schange_count > 2 as libc::c_int as libc::c_uint
            && cblock[i as usize].schange_rate > avg_schange * punish_threshold
        {
            Debug(
                2 as libc::c_int,
                b"Block %i has more scene change than average.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                i,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= punish_modifier;
            cblock[i as usize].score = if cblock[i as usize].score > max_score {
                max_score
            } else {
                cblock[i as usize].score
            };
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 26 as libc::c_int)
                as libc::c_int;
            cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 26 as libc::c_int)
                as libc::c_int;
        }
        if cblock[i as usize].length > 2 as libc::c_int as libc::c_double * min_show_segment_length
        {
            Debug(
                2 as libc::c_int,
                b"Block %i has twice excess length.\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= excessive_length_modifier * excessive_length_modifier;
            cblock[i as usize].score = if cblock[i as usize].score > max_score {
                max_score
            } else {
                cblock[i as usize].score
            };
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause |= (1 as libc::c_int) << 10 as libc::c_int;
            cblock[i as usize].less |= (1 as libc::c_int) << 10 as libc::c_int;
        } else if cblock[i as usize].length > min_show_segment_length {
            Debug(
                2 as libc::c_int,
                b"Block %i has excess length.\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= excessive_length_modifier;
            cblock[i as usize].score = if cblock[i as usize].score > max_score {
                max_score
            } else {
                cblock[i as usize].score
            };
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause |= (1 as libc::c_int) << 10 as libc::c_int;
            cblock[i as usize].less |= (1 as libc::c_int) << 10 as libc::c_int;
        }
        if processCC {
            if most_cc_type == 0 as libc::c_int {
                if cblock[i as usize].cc_type != 0 as libc::c_int {
                    Debug(
                        3 as libc::c_int,
                        b"CC's exist in a non-CC'd show - Block %i score:\tBefore - %.2f\t\0"
                            as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        i,
                        cblock[i as usize].score,
                    );
                    cblock[i as usize].score *=
                        cc_commercial_type_modifier * 2 as libc::c_int as libc::c_double;
                    Debug(
                        3 as libc::c_int,
                        b"After - %.2f\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        cblock[i as usize].score,
                    );
                    cblock[i as usize].score = if cblock[i as usize].score > max_score {
                        max_score
                    } else {
                        cblock[i as usize].score
                    };
                }
            } else if cblock[i as usize].cc_type == most_cc_type {
                Debug(
                    3 as libc::c_int,
                    b"CC's correct type - Block %i score:\tBefore - %.2f\t\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    i,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score *= cc_correct_type_modifier;
                Debug(
                    3 as libc::c_int,
                    b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score = if cblock[i as usize].score > max_score {
                    max_score
                } else {
                    cblock[i as usize].score
                };
            } else if cblock[i as usize].cc_type == 4 as libc::c_int {
                Debug(
                    3 as libc::c_int,
                    b"CC's commercial type - Block %i score:\tBefore - %.2f\t\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    i,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score *= cc_commercial_type_modifier;
                Debug(
                    3 as libc::c_int,
                    b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score = if cblock[i as usize].score > max_score {
                    max_score
                } else {
                    cblock[i as usize].score
                };
            } else if cblock[i as usize].cc_type == 0 as libc::c_int {
                Debug(
                    3 as libc::c_int,
                    b"No CC's - Block %i score:\tBefore - %.2f\t\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    i,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score *=
                    (cc_wrong_type_modifier - 1.0f64) / 2 as libc::c_int as libc::c_double + 1.0f64;
                Debug(
                    3 as libc::c_int,
                    b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score = if cblock[i as usize].score > max_score {
                    max_score
                } else {
                    cblock[i as usize].score
                };
            } else {
                Debug(
                    3 as libc::c_int,
                    b"CC's wrong type - Block %i score:\tBefore - %.2f\t\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    i,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score *= cc_wrong_type_modifier;
                Debug(
                    3 as libc::c_int,
                    b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    cblock[i as usize].score,
                );
                cblock[i as usize].score = if cblock[i as usize].score > max_score {
                    max_score
                } else {
                    cblock[i as usize].score
                };
            }
        }
        cblock[i as usize].ar_ratio = AverageARForBlock(
            cblock[i as usize].f_start as libc::c_int,
            cblock[i as usize].f_end as libc::c_int,
        );
        if dominant_ar - cblock[i as usize].ar_ratio >= ar_delta
            || dominant_ar - cblock[i as usize].ar_ratio <= -ar_delta
        {
            Debug(
                2 as libc::c_int,
                b"Block %i AR (%.2f) is different from dominant AR(%.2f).\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                i,
                cblock[i as usize].ar_ratio,
                dominant_ar,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= ar_wrong_modifier;
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause |= (1 as libc::c_int) << 11 as libc::c_int;
            cblock[i as usize].more |= (1 as libc::c_int) << 11 as libc::c_int;
        }
        cblock[i as usize].audio_channels = AverageACForBlock(
            cblock[i as usize].f_start as libc::c_int,
            cblock[i as usize].f_end as libc::c_int,
        );
        if dominant_ac != cblock[i as usize].audio_channels {
            Debug(
                2 as libc::c_int,
                b"Block %i audio_channels (%i) is different from dominant audio_channels (%i).\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
                cblock[i as usize].audio_channels,
                dominant_ac,
            );
            Debug(
                3 as libc::c_int,
                b"Block %i score:\tBefore - %.2f\t\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                cblock[i as usize].score,
            );
            cblock[i as usize].score *= ac_wrong_modifier;
            Debug(
                3 as libc::c_int,
                b"After - %.2f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cblock[i as usize].score,
            );
            cblock[i as usize].cause |= (1 as libc::c_int) << 11 as libc::c_int;
            cblock[i as usize].more |= (1 as libc::c_int) << 11 as libc::c_int;
        }
        i += 1;
    }
    if processCC {
        if ProcessCCDict() {
            Debug(
                4 as libc::c_int,
                b"Dictionary processed successfully\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
        } else {
            Debug(
                4 as libc::c_int,
                b"Dictionary not processed successfully\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
        }
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        i += 1;
    }
    if disable_heuristics & (1 as libc::c_int) << 2 as libc::c_int - 1 as libc::c_int == 0 {
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count - 2 as libc::c_int as libc::c_long {
            if cblock[i as usize].cause & (1 as libc::c_int) << 6 as libc::c_int != 0
                && cblock[i as usize].cause as libc::c_long
                    & (((1 as libc::c_int) << 4 as libc::c_int
                        | (1 as libc::c_int) << 3 as libc::c_int)
                        as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                        | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                    != 0
                && cblock[(i + 1 as libc::c_int) as usize].score > 1.05f64
                && cblock[(i + 1 as libc::c_int) as usize].length < 4.8f64
                && cblock[(i + 2 as libc::c_int) as usize].score < 1.0f64
                && cblock[(i + 2 as libc::c_int) as usize].length > min_show_segment_length
            {
                cblock[(i + 1 as libc::c_int) as usize].score = 0.5f64;
                Debug(
                    3 as libc::c_int,
                    b"H2 Added cblock %i because short and after strict commercial.\n\0"
                        as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    i + 1 as libc::c_int,
                );
                cblock[(i + 1 as libc::c_int) as usize].cause |=
                    (1 as libc::c_int) << 14 as libc::c_int;
                cblock[(i + 1 as libc::c_int) as usize].less |=
                    (1 as libc::c_int) << 14 as libc::c_int;
            }
            i += 1;
        }
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count - 2 as libc::c_int as libc::c_long {
            if cblock[(i + 2 as libc::c_int) as usize].cause
                & (1 as libc::c_int) << 6 as libc::c_int
                != 0
                && cblock[(i + 1 as libc::c_int) as usize].cause as libc::c_long
                    & (((1 as libc::c_int) << 4 as libc::c_int
                        | (1 as libc::c_int) << 3 as libc::c_int)
                        as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                        | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                    != 0
                && cblock[(i + 1 as libc::c_int) as usize].score > 1.05f64
                && cblock[(i + 1 as libc::c_int) as usize].length < 4.8f64
                && cblock[i as usize].score < 1.0f64
                && cblock[i as usize].length > min_show_segment_length
            {
                cblock[(i + 1 as libc::c_int) as usize].score = 0.5f64;
                Debug(
                    3 as libc::c_int,
                    b"H2 Added cblock %i because after show, short and before strict commercial.\n\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                    i + 1 as libc::c_int,
                );
                cblock[(i + 1 as libc::c_int) as usize].cause |=
                    (1 as libc::c_int) << 14 as libc::c_int;
                cblock[(i + 1 as libc::c_int) as usize].less |=
                    (1 as libc::c_int) << 14 as libc::c_int;
            }
            i += 1;
        }
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count - 2 as libc::c_int as libc::c_long {
            if cblock[i as usize].cause as libc::c_long
                & (((1 as libc::c_int) << 4 as libc::c_int | (1 as libc::c_int) << 3 as libc::c_int)
                    as libc::c_long
                    | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                != 0
                && cblock[(i + 1 as libc::c_int) as usize].cause
                    & (1 as libc::c_int) << 5 as libc::c_int
                    != 0
                && cblock[(i + 1 as libc::c_int) as usize].score > 1.0f64
                && cblock[(i + 1 as libc::c_int) as usize].length < 4.8f64
                && cblock[(i + 2 as libc::c_int) as usize].score < 1.0f64
                && cblock[(i + 2 as libc::c_int) as usize].length > min_show_segment_length
            {
                cblock[(i + 1 as libc::c_int) as usize].score = 0.5f64;
                Debug(
                    3 as libc::c_int,
                    b"H2 Added cblock %i because short and based on aspect ratio change after commercial.\n\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                    i + 1 as libc::c_int,
                );
                cblock[(i + 1 as libc::c_int) as usize].cause |=
                    (1 as libc::c_int) << 14 as libc::c_int;
                cblock[(i + 1 as libc::c_int) as usize].less |=
                    (1 as libc::c_int) << 14 as libc::c_int;
            }
            i += 1;
        }
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count - 2 as libc::c_int as libc::c_long {
            if cblock[(i + 1 as libc::c_int) as usize].cause as libc::c_long
                & (((1 as libc::c_int) << 4 as libc::c_int | (1 as libc::c_int) << 3 as libc::c_int)
                    as libc::c_long
                    | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                != 0
                && cblock[i as usize].cause & (1 as libc::c_int) << 5 as libc::c_int != 0
                && cblock[(i + 1 as libc::c_int) as usize].score > 1.0f64
                && cblock[(i + 1 as libc::c_int) as usize].length < 4.8f64
                && cblock[i as usize].score < 1.0f64
                && cblock[i as usize].length > min_show_segment_length
            {
                cblock[(i + 1 as libc::c_int) as usize].score = 0.5f64;
                Debug(
                    3 as libc::c_int,
                    b"H2 Added cblock %i because short and based on aspect ratio change before commercial.\n\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                    i + 1 as libc::c_int,
                );
                cblock[(i + 1 as libc::c_int) as usize].cause |=
                    (1 as libc::c_int) << 14 as libc::c_int;
                cblock[(i + 1 as libc::c_int) as usize].less |=
                    (1 as libc::c_int) << 14 as libc::c_int;
            }
            i += 1;
        }
    }
    if disable_heuristics & (1 as libc::c_int) << 1 as libc::c_int - 1 as libc::c_int == 0 {
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long {
            if cblock[i as usize].score > 1.4f64
                && cblock[(i + 1 as libc::c_int) as usize].score <= 1.05f64
                && cblock[(i + 1 as libc::c_int) as usize].score > 0.0f64
            {
                combined_length = 0 as libc::c_int as libc::c_double;
                wscore = 0 as libc::c_int as libc::c_double;
                lscore = 0 as libc::c_int as libc::c_double;
                j = i + 1 as libc::c_int;
                while (j as libc::c_long) < block_count
                    && combined_length < min_show_segment_length
                    && cblock[j as usize].score <= 1.05f64
                    && cblock[j as usize].score > 0.0f64
                {
                    combined_length += cblock[j as usize].length;
                    wscore += cblock[j as usize].length * cblock[j as usize].score;
                    lscore += cblock[j as usize].length * cblock[j as usize].logo;
                    j += 1;
                }
                wscore /= combined_length;
                lscore /= combined_length;
                if (combined_length < min_show_segment_length / 2.0f64 && wscore > 0.9f64
                    || combined_length < min_show_segment_length / 3.0f64 && wscore > 0.3f64)
                    && cblock[j as usize].score > 1.4f64
                    && (combined_length
                        < min_show_segment_length / 6 as libc::c_int as libc::c_double
                        || cblock[i as usize].f_start > after_start as libc::c_long
                            && cblock[j as usize].f_end < before_end as libc::c_long)
                {
                    k = i + 1 as libc::c_int;
                    while k < j {
                        cblock[k as usize].score = 99.99f64;
                        Debug(
                            3 as libc::c_int,
                            b"H1 Discarding cblock %i because too short and between two strong commercial blocks.\n\0"
                                as *const u8 as *const libc::c_char as *mut libc::c_char,
                            k,
                        );
                        cblock[k as usize].cause |= (1 as libc::c_int) << 13 as libc::c_int;
                        cblock[k as usize].more |= (1 as libc::c_int) << 13 as libc::c_int;
                        k += 1;
                    }
                }
            }
            i += 1;
        }
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long {
            if cblock[i as usize].score > 1.1f64
                && cblock[(i + 1 as libc::c_int) as usize].score <= 1.05f64
                && cblock[(i + 1 as libc::c_int) as usize].score > 0.0f64
            {
                combined_length = 0.0f64;
                wscore = 0 as libc::c_int as libc::c_double;
                lscore = 0 as libc::c_int as libc::c_double;
                j = i + 1 as libc::c_int;
                while (j as libc::c_long) < block_count
                    && combined_length < min_show_segment_length
                    && cblock[j as usize].score <= 1.05f64
                    && cblock[j as usize].score > 0.0f64
                {
                    combined_length += cblock[j as usize].length;
                    wscore += cblock[j as usize].length * cblock[j as usize].score;
                    lscore += cblock[j as usize].length * cblock[j as usize].logo;
                    j += 1;
                }
                wscore /= combined_length;
                lscore /= combined_length;
                if (combined_length < min_show_segment_length / 4.0f64 && wscore > 0.9f64
                    || combined_length
                        < min_show_segment_length / 6 as libc::c_int as libc::c_double
                        && wscore > 0.3f64)
                    && cblock[j as usize].score > 1.1f64
                    && (combined_length
                        < min_show_segment_length / 12 as libc::c_int as libc::c_double
                        || cblock[i as usize].f_start > after_start as libc::c_long
                            && cblock[j as usize].f_end < before_end as libc::c_long)
                {
                    k = i + 1 as libc::c_int;
                    while k < j {
                        cblock[k as usize].score = 99.99f64;
                        Debug(
                            3 as libc::c_int,
                            b"H1 Discarding cblock %i because too short and between two weak commercial blocks.\n\0"
                                as *const u8 as *const libc::c_char as *mut libc::c_char,
                            k,
                        );
                        cblock[k as usize].cause |= (1 as libc::c_int) << 13 as libc::c_int;
                        cblock[k as usize].more |= (1 as libc::c_int) << 13 as libc::c_int;
                        k += 1;
                    }
                }
            }
            i += 1;
        }
    }
    if disable_heuristics & (1 as libc::c_int) << 8 as libc::c_int - 1 as libc::c_int == 0 {
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count - 2 as libc::c_int as libc::c_long {
            if cblock[i as usize].cause
                & ((1 as libc::c_int) << 4 as libc::c_int | (1 as libc::c_int) << 3 as libc::c_int)
                != 0
                && cblock[i as usize].score > 1.05f64
                && cblock[i as usize].length < min_show_segment_length
                && (i == 0 as libc::c_int
                    || cblock[(i - 1 as libc::c_int) as usize].score
                        < 1 as libc::c_int as libc::c_double)
            {
                j = cblock[i as usize].f_end as libc::c_int;
                k = j;
                while j > 1 as libc::c_int
                    && (*frame.offset(j as isize)).brightness < 16 as libc::c_int
                {
                    j -= 1;
                }
                if k - j > 10 as libc::c_int
                    && (if !frame.is_null() {
                        (if k <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if k >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(k as isize)).pts
                            })
                        })
                    } else {
                        k as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if j <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if j >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(j as isize)).pts
                            })
                        })
                    } else {
                        j as libc::c_double / fps
                    }) > 5.0f64
                {
                    cblock[i as usize].score = 0.5f64;
                    Debug(
                        3 as libc::c_int,
                        b"H8 Added cblock %i because long dark sequence at end.\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        i,
                    );
                    cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 30 as libc::c_int)
                        as libc::c_int;
                    cblock[i as usize].less = (cblock[i as usize].less as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 30 as libc::c_int)
                        as libc::c_int;
                }
            }
            i += 1;
        }
    }
    if delete_show_before_or_after_current != 0
        && logo_block_count >= 80 as libc::c_int as libc::c_long
    {
        Debug(
            10 as libc::c_int,
            b"Too many logo blocks, disabling the delete_show_before_or_after_current processing\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if delete_show_before_or_after_current != 0
        && commDetectMethod & 2 as libc::c_int != 0
        && connect_blocks_with_logo as libc::c_int != 0
        && !reverseLogoLogic
        && logoPercentage > logo_fraction - 0.05f64
        && logo_block_count < 40 as libc::c_int as libc::c_long
    {
        if disable_heuristics & (1 as libc::c_int) << 7 as libc::c_int - 1 as libc::c_int == 0 {
            i = 0 as libc::c_int;
            while (i as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long
                && cblock[i as usize].score < 1.05f64
                && (delete_show_before_or_after_current == 1 as libc::c_int
                    && cblock[i as usize].f_end < after_start as libc::c_long
                    || delete_show_before_or_after_current > 1 as libc::c_int
                        && delete_show_before_or_after_current as libc::c_double
                            > cblock[i as usize].length)
            {
                j = i + 1 as libc::c_int;
                cl = 0 as libc::c_int as libc::c_double;
                combined_length = 0 as libc::c_int as libc::c_double;
                while cblock[j as usize].score > 1.05f64
                    && cl + cblock[j as usize].length < min_commercialbreak
                    && (j as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long
                {
                    combined_length += cblock[j as usize].length;
                    cl += cblock[j as usize].length;
                    j += 1;
                }
                if cblock[j as usize].score < 1.0f64
                    && cblock[j as usize].length
                        > min_show_segment_length / 2 as libc::c_int as libc::c_double
                {
                    cblock[i as usize].score = 99.99f64;
                    Debug(
                        3 as libc::c_int,
                        b"H7 Discarding cblock %i of %i seconds because cblock %i has also logo and small non show gap.\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i,
                        cblock[i as usize].length as libc::c_int,
                        j,
                    );
                    cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                        as libc::c_int;
                    cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                        as libc::c_int;
                    break;
                } else {
                    i += 1;
                }
            }
            i = (block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
            while i > 0 as libc::c_int
                && cblock[i as usize].score < 1.0f64
                && (delete_show_before_or_after_current == 1 as libc::c_int
                    && cblock[i as usize].f_start > before_end as libc::c_long
                    || delete_show_before_or_after_current > 1 as libc::c_int
                        && delete_show_before_or_after_current as libc::c_double
                            > cblock[i as usize].length)
            {
                j = i - 1 as libc::c_int;
                cl = 0 as libc::c_int as libc::c_double;
                combined_length = 0 as libc::c_int as libc::c_double;
                while cblock[j as usize].score > 1.05f64
                    && cl + cblock[j as usize].length < min_commercialbreak
                    && j > 0 as libc::c_int
                {
                    combined_length += cblock[j as usize].length;
                    cl += cblock[j as usize].length;
                    j -= 1;
                }
                if cblock[j as usize].score < 1.0f64 {
                    cblock[i as usize].score = 99.99f64;
                    Debug(
                        3 as libc::c_int,
                        b"H7 Discarding cblock %i of %i seconds because cblock %i has also logo and small non show gap.\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i,
                        cblock[i as usize].length as libc::c_int,
                        j,
                    );
                    cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                        as libc::c_int;
                    cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                        as libc::c_int;
                    break;
                } else {
                    i += 1;
                }
            }
        }
        if disable_heuristics & (1 as libc::c_int) << 3 as libc::c_int - 1 as libc::c_int == 0 {
            i = 0 as libc::c_int;
            while (i as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long {
                if cblock[i as usize].score < 1.0f64
                    && cblock[i as usize].logo < 0.1f64
                    && cblock[i as usize].length > min_show_segment_length
                {
                    if cblock[i as usize].f_end < after_start as libc::c_long {
                        cblock[i as usize].score *= 1.3f64;
                        Debug(
                            3 as libc::c_int,
                            b"H3 Demoting cblock %i because cblock %i has no logo and others do.\n\0"
                                as *const u8 as *const libc::c_char as *mut libc::c_char,
                            i,
                            i,
                        );
                        cblock[i as usize].cause |= (1 as libc::c_int) << 15 as libc::c_int;
                        cblock[i as usize].more |= (1 as libc::c_int) << 15 as libc::c_int;
                    } else if cblock[i as usize].f_start > before_end as libc::c_long {
                        cblock[i as usize].score *= 1.3f64;
                        Debug(
                            3 as libc::c_int,
                            b"Demoting cblock %i because cblock %i has no logo and others do.\n\0"
                                as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            i,
                            i,
                        );
                        cblock[i as usize].cause |= (1 as libc::c_int) << 15 as libc::c_int;
                        cblock[i as usize].more |= (1 as libc::c_int) << 15 as libc::c_int;
                    }
                }
                i += 1;
            }
        }
        i = 1 as libc::c_int;
        while (i as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long {
            if logoPercentage > logo_fraction
                && cblock[i as usize].score > 1.0f64
                && cblock[i as usize].logo < 0.1f64
                && cblock[i as usize].length
                    > min_show_segment_length + 4 as libc::c_int as libc::c_double
            {
                if cblock[i as usize].f_start > after_start as libc::c_long
                    && cblock[i as usize].f_end < before_end as libc::c_long
                    && (cblock[(i - 1 as libc::c_int) as usize].score < 1.0f64
                        || cblock[(i + 1 as libc::c_int) as usize].score < 1.0f64)
                {
                    cblock[i as usize].score *= 0.5f64;
                    Debug(
                        3 as libc::c_int,
                        b"Promoting cblock %i because cblock %i has no logo but long and in the middle of a show.\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i,
                        i,
                    );
                    cblock[i as usize].cause |= (1 as libc::c_int) << 15 as libc::c_int;
                    cblock[i as usize].more |= (1 as libc::c_int) << 15 as libc::c_int;
                }
            }
            i += 1;
        }
    }
    if disable_heuristics & (1 as libc::c_int) << 4 as libc::c_int - 1 as libc::c_int == 0 {
        if commDetectMethod & 2 as libc::c_int != 0
            && !reverseLogoLogic
            && logoPercentage > logo_fraction
        {
            i = 1 as libc::c_int;
            while (i as libc::c_long) < block_count {
                if cblock[i as usize].score < 1 as libc::c_int as libc::c_double
                    && cblock[i as usize].b_head > 7 as libc::c_int as libc::c_uint
                    && cblock[(i - 1 as libc::c_int) as usize].cause as libc::c_long
                        & (((1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int
                            | (1 as libc::c_int) << 5 as libc::c_int
                            | (1 as libc::c_int) << 3 as libc::c_int
                            | (1 as libc::c_int) << 4 as libc::c_int)
                            as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                            | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                        == ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                {
                    j = i - 1 as libc::c_int;
                    k = 0 as libc::c_int;
                    while j >= 0 as libc::c_int
                        && k < 5 as libc::c_int
                        && cblock[j as usize].b_head > 7 as libc::c_int as libc::c_uint
                        && cblock[j as usize].length < 7 as libc::c_int as libc::c_double
                        && cblock[j as usize].cause as libc::c_long
                            & (((1 as libc::c_int) << 1 as libc::c_int
                                | (1 as libc::c_int) << 0 as libc::c_int
                                | (1 as libc::c_int) << 2 as libc::c_int
                                | (1 as libc::c_int) << 5 as libc::c_int
                                | (1 as libc::c_int) << 3 as libc::c_int
                                | (1 as libc::c_int) << 4 as libc::c_int)
                                as libc::c_long
                                | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                                | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                            == ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                    {
                        cblock[j as usize].score *= 0.1f64;
                        Debug(
                            3 as libc::c_int,
                            b"H4 Added cblock %i because of large black gap with cblock %i\n\0"
                                as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            j,
                            i,
                        );
                        k += 1;
                        cblock[j as usize].cause = (cblock[j as usize].cause as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 16 as libc::c_int)
                            as libc::c_int;
                        cblock[j as usize].less = (cblock[j as usize].less as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 16 as libc::c_int)
                            as libc::c_int;
                        j -= 1;
                    }
                }
                i += 1;
            }
        }
        if commDetectMethod & 2 as libc::c_int != 0
            && !reverseLogoLogic
            && logoPercentage > logo_fraction
        {
            i = 0 as libc::c_int;
            while (i as libc::c_long) < block_count {
                if cblock[i as usize].score < 1 as libc::c_int as libc::c_double
                    && cblock[i as usize].b_tail > 7 as libc::c_int as libc::c_uint
                    && cblock[i as usize].cause as libc::c_long
                        & (((1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int
                            | (1 as libc::c_int) << 5 as libc::c_int
                            | (1 as libc::c_int) << 3 as libc::c_int
                            | (1 as libc::c_int) << 4 as libc::c_int)
                            as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                            | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                        == ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                {
                    j = i + 1 as libc::c_int;
                    k = 0 as libc::c_int;
                    while (j as libc::c_long) < block_count
                        && k < 5 as libc::c_int
                        && cblock[j as usize].b_tail > 7 as libc::c_int as libc::c_uint
                        && cblock[j as usize].length < 7 as libc::c_int as libc::c_double
                        && cblock[(j - 1 as libc::c_int) as usize].cause as libc::c_long
                            & (((1 as libc::c_int) << 1 as libc::c_int
                                | (1 as libc::c_int) << 0 as libc::c_int
                                | (1 as libc::c_int) << 2 as libc::c_int
                                | (1 as libc::c_int) << 5 as libc::c_int
                                | (1 as libc::c_int) << 3 as libc::c_int
                                | (1 as libc::c_int) << 4 as libc::c_int)
                                as libc::c_long
                                | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                                | (1 as libc::c_int as libc::c_long) << 29 as libc::c_int)
                            == ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long
                    {
                        cblock[j as usize].score *= 0.1f64;
                        Debug(
                            3 as libc::c_int,
                            b"H4 Added cblock %i because of large black gap with cblock %i\n\0"
                                as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            j,
                            i,
                        );
                        k += 1;
                        cblock[j as usize].cause = (cblock[j as usize].cause as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 16 as libc::c_int)
                            as libc::c_int;
                        cblock[j as usize].less = (cblock[j as usize].less as libc::c_long
                            | (1 as libc::c_int as libc::c_long) << 16 as libc::c_int)
                            as libc::c_int;
                        j += 1;
                    }
                }
                i += 1;
            }
        }
    }
    if remove_silent_segments > 0 as libc::c_int
        && disable_heuristics & (1 as libc::c_int) << 9 as libc::c_int - 1 as libc::c_int == 0
    {
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count {
            if cblock[i as usize].volume < 20 as libc::c_int
                && cblock[i as usize].length > remove_silent_segments as libc::c_double
            {
                cblock[i as usize].score = 5 as libc::c_int as libc::c_double;
                Debug(
                    3 as libc::c_int,
                    b"H9  Demoting cblock %i because is long and has total silence\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    i,
                    i,
                );
                cblock[i as usize].cause |= (1 as libc::c_int) << 15 as libc::c_int;
                cblock[i as usize].more |= (1 as libc::c_int) << 15 as libc::c_int;
            }
            i += 1;
        }
    }
    disable_heuristics & (1 as libc::c_int) << 2 as libc::c_int - 1 as libc::c_int == 0;
}
#[no_mangle]
pub static mut TempXmlFilename: [libc::c_char; 300] = [0; 300];
#[no_mangle]
pub unsafe extern "C" fn EscapeXmlFilename(mut f: *mut libc::c_char) -> *mut libc::c_char {
    let mut o: *mut libc::c_char = TempXmlFilename.as_mut_ptr();
    while *f != 0 {
        if *f as libc::c_int == '&' as i32 {
            let fresh36 = o;
            o = o.offset(1);
            *fresh36 = '&' as i32 as libc::c_char;
            let fresh37 = o;
            o = o.offset(1);
            *fresh37 = 'a' as i32 as libc::c_char;
            let fresh38 = o;
            o = o.offset(1);
            *fresh38 = 'm' as i32 as libc::c_char;
            let fresh39 = o;
            o = o.offset(1);
            *fresh39 = 'p' as i32 as libc::c_char;
            let fresh40 = o;
            o = o.offset(1);
            *fresh40 = ';' as i32 as libc::c_char;
            f = f.offset(1);
        } else if *f as libc::c_int == '<' as i32 {
            let fresh41 = o;
            o = o.offset(1);
            *fresh41 = '&' as i32 as libc::c_char;
            let fresh42 = o;
            o = o.offset(1);
            *fresh42 = 'l' as i32 as libc::c_char;
            let fresh43 = o;
            o = o.offset(1);
            *fresh43 = 't' as i32 as libc::c_char;
            let fresh44 = o;
            o = o.offset(1);
            *fresh44 = ';' as i32 as libc::c_char;
            f = f.offset(1);
        } else if *f as libc::c_int == '>' as i32 {
            let fresh45 = o;
            o = o.offset(1);
            *fresh45 = '&' as i32 as libc::c_char;
            let fresh46 = o;
            o = o.offset(1);
            *fresh46 = 'g' as i32 as libc::c_char;
            let fresh47 = o;
            o = o.offset(1);
            *fresh47 = 't' as i32 as libc::c_char;
            let fresh48 = o;
            o = o.offset(1);
            *fresh48 = ';' as i32 as libc::c_char;
            f = f.offset(1);
        } else if *f as libc::c_int == '%' as i32 {
            let fresh49 = o;
            o = o.offset(1);
            *fresh49 = '&' as i32 as libc::c_char;
            let fresh50 = o;
            o = o.offset(1);
            *fresh50 = '#' as i32 as libc::c_char;
            let fresh51 = o;
            o = o.offset(1);
            *fresh51 = '3' as i32 as libc::c_char;
            let fresh52 = o;
            o = o.offset(1);
            *fresh52 = '7' as i32 as libc::c_char;
            let fresh53 = o;
            o = o.offset(1);
            *fresh53 = ';' as i32 as libc::c_char;
            f = f.offset(1);
        } else {
            let fresh54 = f;
            f = f.offset(1);
            let fresh55 = o;
            o = o.offset(1);
            *fresh55 = *fresh54;
        }
    }
    let fresh56 = o;
    o = o.offset(1);
    *fresh56 = 0 as libc::c_int as libc::c_char;
    return TempXmlFilename.as_mut_ptr();
}
#[no_mangle]
pub unsafe extern "C" fn OpenOutputFiles() {
    let mut tempstr: [libc::c_char; 1024] = [0; 1024];
    let mut cwd: [libc::c_char; 1024] = [0; 1024];
    if output_default {
        out_file = myfopen(
            out_filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if out_file.is_null() {
            usleep((50 as libc::c_long * 1000 as libc::c_long) as useconds_t);
            out_file = myfopen(
                out_filename.as_mut_ptr(),
                b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if out_file.is_null() {
                Debug(
                    0 as libc::c_int,
                    b"ERROR writing to %s\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    out_filename.as_mut_ptr(),
                );
                exit(103 as libc::c_int);
            }
        }
        fprintf(
            out_file,
            b"FILE PROCESSING COMPLETE %6li FRAMES AT %5i\n-------------------\n\0" as *const u8
                as *const libc::c_char,
            ((if !frame.is_null() {
                (if frame_count - 1 as libc::c_int as libc::c_long
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if frame_count - 1 as libc::c_int as libc::c_long
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((frame_count - 1 as libc::c_int as libc::c_long) as isize))
                            .pts
                    })
                })
            } else {
                (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_double / fps
            }) * fps
                + 1.5f64) as libc::c_long,
            (fps * 100 as libc::c_int as libc::c_double) as libc::c_int,
        );
        fclose(out_file);
    }
    if output_chapters {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.chap\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        chapters_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if chapters_file.is_null() {
            usleep((50 as libc::c_long * 1000 as libc::c_long) as useconds_t);
            out_file = myfopen(
                chapters_file as *const libc::c_char,
                b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if chapters_file.is_null() {
                Debug(
                    0 as libc::c_int,
                    b"ERROR writing to %s\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    filename.as_mut_ptr(),
                );
                exit(103 as libc::c_int);
            }
        }
        fprintf(
            chapters_file,
            b"FILE PROCESSING COMPLETE %6li FRAMES AT %5i\n-------------------\n\0" as *const u8
                as *const libc::c_char,
            frame_count - 1 as libc::c_int as libc::c_long,
            (fps * 100 as libc::c_int as libc::c_double) as libc::c_int,
        );
    }
    if output_zoomplayer_cutlist {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.cut\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        zoomplayer_cutlist_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if zoomplayer_cutlist_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_zoomplayer_cutlist = 1 as libc::c_int != 0;
        }
    }
    if output_plist_cutlist {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.plist\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        plist_cutlist_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if plist_cutlist_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_plist_cutlist = 1 as libc::c_int != 0;
            fprintf(
                plist_cutlist_file,
                b"<array>\n\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if output_incommercial {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.incommercial\0" as *const u8 as *const libc::c_char,
            workbasename.as_mut_ptr(),
        );
        incommercial_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if incommercial_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
        fprintf(
            incommercial_file,
            b"0\n\0" as *const u8 as *const libc::c_char,
        );
        fclose(incommercial_file);
    }
    if output_zoomplayer_chapter {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.chp\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        zoomplayer_chapter_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if zoomplayer_chapter_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_zoomplayer_chapter = 1 as libc::c_int != 0;
        }
    }
    if output_scf {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.scf\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        scf_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if scf_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_scf = 1 as libc::c_int != 0;
        }
    }
    if output_edl {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.edl\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        edl_file = myfopen(
            filename.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if edl_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_edl = 1 as libc::c_int != 0;
        }
    }
    if output_ffmeta {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.ffmeta\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        ffmeta_file = myfopen(
            filename.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if ffmeta_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_ffmeta = 1 as libc::c_int != 0;
        }
    }
    if output_ffsplit {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.ffsplit\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        ffsplit_file = myfopen(
            filename.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if ffsplit_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_ffsplit = 1 as libc::c_int != 0;
        }
    }
    if output_ipodchap {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.chap\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        ipodchap_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if ipodchap_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_ipodchap = 1 as libc::c_int != 0;
        }
        fprintf(
            ipodchap_file,
            b"CHAPTER01=00:00:00.000\nCHAPTER01NAME=1\n\0" as *const u8 as *const libc::c_char,
        );
    }
    if output_edlp {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.edlp\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        edlp_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if edlp_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_edlp = 1 as libc::c_int != 0;
        }
    }
    if output_bsplayer {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.bcf\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        bcf_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if bcf_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_bsplayer = 1 as libc::c_int != 0;
        }
    }
    if output_edlx {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.edlx\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        edlx_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if edlx_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            output_edlx = 1 as libc::c_int != 0;
            fprintf(
                edlx_file,
                b"<regionlist units=\"bytes\" mode=\"exclude\"> \n\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if output_videoredo as libc::c_int != 0 && !output_videoredo3 {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.VPrj\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        videoredo_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !videoredo_file.is_null() {
            if mpegfilename[1 as libc::c_int as usize] as libc::c_int == ':' as i32
                || mpegfilename[0 as libc::c_int as usize] as libc::c_int == '/' as i32
            {
                fprintf(
                    videoredo_file,
                    b"<Version>2\n<Filename>%s\n\0" as *const u8 as *const libc::c_char,
                    mpegfilename.as_mut_ptr(),
                );
            } else {
                getcwd(cwd.as_mut_ptr(), 256 as libc::c_int as size_t);
                fprintf(
                    videoredo_file,
                    b"<Version>2\n<Filename>%s%c%s\n\0" as *const u8 as *const libc::c_char,
                    cwd.as_mut_ptr(),
                    '/' as i32,
                    mpegfilename.as_mut_ptr(),
                );
            }
            if is_h264 != 0 {
                fprintf(
                    videoredo_file,
                    b"<MPEG Stream Type>4\n\0" as *const u8 as *const libc::c_char,
                );
            }
            output_videoredo = 1 as libc::c_int != 0;
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_videoredo3 {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.VPrj\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        videoredo3_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !videoredo3_file.is_null() {
            if mpegfilename[1 as libc::c_int as usize] as libc::c_int == ':' as i32
                || mpegfilename[0 as libc::c_int as usize] as libc::c_int == '/' as i32
            {
                fprintf(
                    videoredo3_file,
                    b"<VideoReDoProject Version=\"3\">\n<Filename>%s</Filename><CutList>\n\0"
                        as *const u8 as *const libc::c_char,
                    EscapeXmlFilename(mpegfilename.as_mut_ptr()),
                );
            } else {
                getcwd(cwd.as_mut_ptr(), 256 as libc::c_int as size_t);
                fprintf(
                    videoredo3_file,
                    b"<VideoReDoProject Version=\"3\">\n<Filename>%s%c%s</Filename><CutList>\n\0"
                        as *const u8 as *const libc::c_char,
                    cwd.as_mut_ptr(),
                    '/' as i32,
                    EscapeXmlFilename(mpegfilename.as_mut_ptr()),
                );
            }
            output_videoredo3 = 1 as libc::c_int != 0;
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_btv {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.chapters.xml\0" as *const u8 as *const libc::c_char,
            mpegfilename.as_mut_ptr(),
        );
        btv_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !btv_file.is_null() {
            fprintf(
                btv_file,
                b"<cutlist>\n\0" as *const u8 as *const libc::c_char,
            );
            output_btv = 1 as libc::c_int != 0;
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_cuttermaran {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.cpf\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        cuttermaran_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !cuttermaran_file.is_null() {
            if mpegfilename[1 as libc::c_int as usize] as libc::c_int == ':' as i32
                || mpegfilename[0 as libc::c_int as usize] as libc::c_int == '/' as i32
            {
                strcpy(tempstr.as_mut_ptr(), inbasename.as_mut_ptr());
            } else {
                getcwd(cwd.as_mut_ptr(), 256 as libc::c_int as size_t);
                sprintf(
                    tempstr.as_mut_ptr(),
                    b"%s%c%s\0" as *const u8 as *const libc::c_char,
                    cwd.as_mut_ptr(),
                    '/' as i32,
                    inbasename.as_mut_ptr(),
                );
            }
            fprintf(
                cuttermaran_file,
                b"<?xml version=\"1.0\" standalone=\"yes\"?>\n\0" as *const u8
                    as *const libc::c_char,
            );
            fprintf(
                cuttermaran_file,
                b"<StateData xmlns=\"http://cuttermaran.kickme.to/StateData.xsd\">\n\0" as *const u8
                    as *const libc::c_char,
            );
            fprintf(
                cuttermaran_file,
                b"<usedVideoFiles FileID=\"0\" FileName=\"%s.M2V\" />\n\0" as *const u8
                    as *const libc::c_char,
                inbasename.as_mut_ptr(),
            );
            fprintf(
                cuttermaran_file,
                b"<usedAudioFiles FileID=\"1\" FileName=\"%s.mp2\" StartDelay=\"0\" />\n\0"
                    as *const u8 as *const libc::c_char,
                inbasename.as_mut_ptr(),
            );
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_vcf {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.vcf\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        vcf_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !vcf_file.is_null() {
            if mpegfilename[1 as libc::c_int as usize] as libc::c_int == ':' as i32
                || mpegfilename[0 as libc::c_int as usize] as libc::c_int == '/' as i32
            {
                strcpy(tempstr.as_mut_ptr(), inbasename.as_mut_ptr());
            } else {
                getcwd(cwd.as_mut_ptr(), 256 as libc::c_int as size_t);
                sprintf(
                    tempstr.as_mut_ptr(),
                    b"%s%c%s\0" as *const u8 as *const libc::c_char,
                    cwd.as_mut_ptr(),
                    '/' as i32,
                    inbasename.as_mut_ptr(),
                );
            }
            fprintf(
                vcf_file,
                b"VirtualDub.video.SetMode(0);\nVirtualDub.subset.Clear();\n\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_vdr {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.vdr\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        vdr_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !vdr_file.is_null() {
            if mpegfilename[1 as libc::c_int as usize] as libc::c_int == ':' as i32
                || mpegfilename[0 as libc::c_int as usize] as libc::c_int == '/' as i32
            {
                strcpy(tempstr.as_mut_ptr(), inbasename.as_mut_ptr());
            } else {
                getcwd(cwd.as_mut_ptr(), 256 as libc::c_int as size_t);
                sprintf(
                    tempstr.as_mut_ptr(),
                    b"%s%c%s\0" as *const u8 as *const libc::c_char,
                    cwd.as_mut_ptr(),
                    '/' as i32,
                    inbasename.as_mut_ptr(),
                );
            }
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_projectx {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.Xcl\0" as *const u8 as *const libc::c_char,
            mpegfilename.as_mut_ptr(),
        );
        projectx_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !projectx_file.is_null() {
            fprintf(
                projectx_file,
                b"CollectionPanel.CutMode=2\n\0" as *const u8 as *const libc::c_char,
            );
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_avisynth {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.avs\0" as *const u8 as *const libc::c_char,
            mpegfilename.as_mut_ptr(),
        );
        avisynth_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !avisynth_file.is_null() {
            if avisynth_options[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
                fprintf(
                    avisynth_file,
                    b"LoadPlugin(\"MPEG2Dec3.dll\") \nMPEG2Source(\"%s\")\n\0" as *const u8
                        as *const libc::c_char,
                    mpegfilename.as_mut_ptr(),
                );
            } else {
                fprintf(
                    avisynth_file,
                    avisynth_options.as_mut_ptr(),
                    mpegfilename.as_mut_ptr(),
                );
            }
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_womble {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.wme\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        womble_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !womble_file.is_null() {
            output_womble = 1 as libc::c_int != 0;
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_mls {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.mls\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        mls_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !mls_file.is_null() {
            output_mls = 1 as libc::c_int != 0;
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_mpgtx {
        sprintf(
            filename.as_mut_ptr(),
            b"%s_mpgtx.bat\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        mpgtx_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !mpgtx_file.is_null() {
            output_mpgtx = 1 as libc::c_int != 0;
            fprintf(
                mpgtx_file,
                b"mpgtx.exe -j -f -o \"%s%s\" \"%s\" \0" as *const u8 as *const libc::c_char,
                mpegfilename.as_mut_ptr(),
                b".clean\0" as *const u8 as *const libc::c_char,
                mpegfilename.as_mut_ptr(),
            );
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_dvrcut {
        sprintf(
            filename.as_mut_ptr(),
            b"%s_dvrcut.bat\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        dvrcut_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !dvrcut_file.is_null() {
            if dvrcut_options[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
                fprintf(
                    dvrcut_file,
                    b"dvrcut \"%%1\" \"%%2\" \0" as *const u8 as *const libc::c_char,
                );
            } else {
                fprintf(
                    dvrcut_file,
                    dvrcut_options.as_mut_ptr(),
                    inbasename.as_mut_ptr(),
                    inbasename.as_mut_ptr(),
                    inbasename.as_mut_ptr(),
                );
            }
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_dvrmstb {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.xml\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        dvrmstb_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !dvrmstb_file.is_null() {
            fprintf(
                dvrmstb_file,
                b"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<root>\n\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_mpeg2schnitt {
        sprintf(
            filename.as_mut_ptr(),
            b"%s_mpeg2schnitt.bat\0" as *const u8 as *const libc::c_char,
            inbasename.as_mut_ptr(),
        );
        mpeg2schnitt_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !mpeg2schnitt_file.is_null() {
            output_mpgtx = 1 as libc::c_int != 0;
            if mpeg2schnitt_options[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
                fprintf(
                    mpeg2schnitt_file,
                    b"mpeg2schnitt.exe /S /E /R%5.2f  /Z \"%s\" \"%s\" \0" as *const u8
                        as *const libc::c_char,
                    fps,
                    b"%2\0" as *const u8 as *const libc::c_char,
                    b"%1\0" as *const u8 as *const libc::c_char,
                );
            } else {
                fprintf(
                    mpeg2schnitt_file,
                    b"%s \0" as *const u8 as *const libc::c_char,
                    mpeg2schnitt_options.as_mut_ptr(),
                );
            }
        } else {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        }
    }
    if output_mkvtoolnix > 0 as libc::c_int {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.mkvtoolnix.chapters\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        mkvtoolnix_chapters_file = myfopen(
            filename.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if mkvtoolnix_chapters_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            fprintf(
                mkvtoolnix_chapters_file,
                b"<?xml version=\"1.0\" encoding=\"ISO - 8859 - 1\"?>\n<Chapters>\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if output_mkvtoolnix == 2 as libc::c_int {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.mkvtoolnix.tags\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        mkvtoolnix_tags_file = myfopen(
            filename.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if mkvtoolnix_tags_file.is_null() {
            fprintf(
                __stderrp,
                b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                strerror(*__error()),
                filename.as_mut_ptr(),
            );
            exit(6 as libc::c_int);
        } else {
            fprintf(
                mkvtoolnix_tags_file,
                b"<?xml version=\"1.0\" encoding=\"ISO - 8859 - 1\"?>\n<Tags>\n\t<Tag>\n\t\t<Targets>\n\t\t\t<TargetTypeValue>50</TargetTypeValue>\n\t\t\t<EditionUID>1</EditionUID>\n\t\t</Targets>\n\t\t<Simple>\n\t\t\t<TagLanguage>eng</TagLanguage>\n\t\t\t<Name>TITLE</Name>\n\t\t\t<DefaultLanguage>1</DefaultLanguage>\n\t\t\t<String>With Commercials</String>\n\t\t</Simple>\n\t</Tag>\n\t<Tag>\n\t\t<Targets>\n\t\t\t<TargetTypeValue>50</TargetTypeValue>\n\t\t\t<EditionUID>2</EditionUID>\n\t\t</Targets>\n\t\t<Simple>\n\t\t\t<TagLanguage>eng</TagLanguage>\n\t\t\t<Name>TITLE</Name>\n\t\t\t<DefaultLanguage>1</DefaultLanguage>\n\t\t\t<String>Without Commercials</String>\n\t\t</Simple>\n\t</Tag>\n</Tags>\0"
                    as *const u8 as *const libc::c_char,
            );
            fclose(mkvtoolnix_tags_file);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn OutputCommercialBlock(
    mut i: libc::c_int,
    mut prev: libc::c_long,
    mut start: libc::c_long,
    mut end: libc::c_long,
    mut last: bool,
) {
    let mut s_start: libc::c_int = 0;
    let mut s_end: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut minutes: libc::c_double = (if !frame.is_null() {
        (if frame_count <= 0 as libc::c_int as libc::c_long {
            (*frame.offset(1 as libc::c_int as isize)).pts
        } else {
            (if frame_count >= framenum_real as libc::c_long {
                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
            } else {
                (*frame.offset(frame_count as isize)).pts
            })
        })
    } else {
        frame_count as libc::c_double / fps
    }) / 60 as libc::c_int as libc::c_double;
    let mut scomment: [libc::c_char; 80] = [0; 80];
    let mut ecomment: [libc::c_char; 80] = [0; 80];
    s_start = start as libc::c_int;
    s_end = end as libc::c_int;
    if sage_minute_bug {
        s_start = (start as libc::c_double
            * ((minutes + 0.5f64) as libc::c_int as libc::c_double / minutes))
            as libc::c_int;
        s_end = (end as libc::c_double
            * ((minutes + 0.5f64) as libc::c_int as libc::c_double / minutes))
            as libc::c_int;
    }
    if output_default as libc::c_int != 0 && prev < start {
        out_file = myfopen(
            out_filename.as_mut_ptr(),
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !out_file.is_null() {
            fprintf(
                out_file,
                b"%li\t%li\n\0" as *const u8 as *const libc::c_char,
                ((if !frame.is_null() {
                    (if (if sage_framenumber_bug as libc::c_int != 0 {
                        s_start / 2 as libc::c_int
                    } else {
                        s_start
                    }) <= 0 as libc::c_int
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (if sage_framenumber_bug as libc::c_int != 0 {
                            s_start / 2 as libc::c_int
                        } else {
                            s_start
                        }) >= framenum_real
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                (if sage_framenumber_bug as libc::c_int != 0 {
                                    s_start / 2 as libc::c_int
                                } else {
                                    s_start
                                }) as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    (if sage_framenumber_bug as libc::c_int != 0 {
                        s_start / 2 as libc::c_int
                    } else {
                        s_start
                    }) as libc::c_double
                        / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
                ((if !frame.is_null() {
                    (if (if sage_framenumber_bug as libc::c_int != 0 {
                        s_end / 2 as libc::c_int
                    } else {
                        s_end
                    }) <= 0 as libc::c_int
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (if sage_framenumber_bug as libc::c_int != 0 {
                            s_end / 2 as libc::c_int
                        } else {
                            s_end
                        }) >= framenum_real
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                (if sage_framenumber_bug as libc::c_int != 0 {
                                    s_end / 2 as libc::c_int
                                } else {
                                    s_end
                                }) as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    (if sage_framenumber_bug as libc::c_int != 0 {
                        s_end / 2 as libc::c_int
                    } else {
                        s_end
                    }) as libc::c_double
                        / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
            );
            fclose(out_file);
        } else {
            usleep((50 as libc::c_long * 1000 as libc::c_long) as useconds_t);
            out_file = myfopen(
                out_filename.as_mut_ptr(),
                b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if !out_file.is_null() {
                fprintf(
                    out_file,
                    b"%li\t%li\n\0" as *const u8 as *const libc::c_char,
                    ((if !frame.is_null() {
                        (if (if sage_framenumber_bug as libc::c_int != 0 {
                            s_start / 2 as libc::c_int
                        } else {
                            s_start
                        }) <= 0 as libc::c_int
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (if sage_framenumber_bug as libc::c_int != 0 {
                                s_start / 2 as libc::c_int
                            } else {
                                s_start
                            }) >= framenum_real
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(
                                    (if sage_framenumber_bug as libc::c_int != 0 {
                                        s_start / 2 as libc::c_int
                                    } else {
                                        s_start
                                    }) as isize,
                                ))
                                .pts
                            })
                        })
                    } else {
                        (if sage_framenumber_bug as libc::c_int != 0 {
                            s_start / 2 as libc::c_int
                        } else {
                            s_start
                        }) as libc::c_double
                            / fps
                    }) * fps
                        + 1.5f64) as libc::c_long,
                    ((if !frame.is_null() {
                        (if (if sage_framenumber_bug as libc::c_int != 0 {
                            s_end / 2 as libc::c_int
                        } else {
                            s_end
                        }) <= 0 as libc::c_int
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (if sage_framenumber_bug as libc::c_int != 0 {
                                s_end / 2 as libc::c_int
                            } else {
                                s_end
                            }) >= framenum_real
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(
                                    (if sage_framenumber_bug as libc::c_int != 0 {
                                        s_end / 2 as libc::c_int
                                    } else {
                                        s_end
                                    }) as isize,
                                ))
                                .pts
                            })
                        })
                    } else {
                        (if sage_framenumber_bug as libc::c_int != 0 {
                            s_end / 2 as libc::c_int
                        } else {
                            s_end
                        }) as libc::c_double
                            / fps
                    }) * fps
                        + 1.5f64) as libc::c_long,
                );
                fclose(out_file);
            } else {
                Debug(
                    0 as libc::c_int,
                    b"ERROR writing to %s\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    out_filename.as_mut_ptr(),
                );
                exit(103 as libc::c_int);
            }
        }
    }
    if !zoomplayer_cutlist_file.is_null()
        && prev < start
        && end - start > 2 as libc::c_int as libc::c_long
    {
        fprintf(
            zoomplayer_cutlist_file,
            b"JumpSegment(\"From=%.4f\",\"To=%.4f\")\n\0" as *const u8 as *const libc::c_char,
            get_frame_pts(start as libc::c_int),
            get_frame_pts(end as libc::c_int),
        );
    }
    if !zoomplayer_cutlist_file.is_null() && last as libc::c_int != 0 {
        fclose(zoomplayer_cutlist_file);
    }
    if !plist_cutlist_file.is_null() {
        if prev < start {
            fprintf(
                plist_cutlist_file,
                b"<integer>%ld</integer> <integer>%ld</integer>\n\0" as *const u8
                    as *const libc::c_char,
                (get_frame_pts(start as libc::c_int) * 90000 as libc::c_int as libc::c_double)
                    as libc::c_ulong,
                (get_frame_pts(end as libc::c_int) * 90000 as libc::c_int as libc::c_double)
                    as libc::c_ulong,
            );
        }
        if last {
            fprintf(
                plist_cutlist_file,
                b"</array>\n\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if !plist_cutlist_file.is_null() && last as libc::c_int != 0 {
        fclose(plist_cutlist_file);
    }
    if !zoomplayer_chapter_file.is_null() && prev < start && (end - start) as libc::c_double > fps {
        fprintf(
            zoomplayer_chapter_file,
            b"AddChapterBySecond(%i,Commercial Segment)\nAddChapterBySecond(%i,Show Segment)\n\0"
                as *const u8 as *const libc::c_char,
            get_frame_pts(start as libc::c_int) as libc::c_int,
            get_frame_pts(end as libc::c_int) as libc::c_int,
        );
    }
    if !zoomplayer_chapter_file.is_null() && last as libc::c_int != 0 {
        fclose(zoomplayer_chapter_file);
    }
    if !scf_file.is_null() && prev < start && (end - start) as libc::c_double > fps {
        let mut rounded_fps: libc::c_int = (fps + 0.5f64) as libc::c_int;
        fprintf(
            scf_file,
            b"CHAPTER%02i=%02li:%02li:%02li.%03li\n\0" as *const u8 as *const libc::c_char,
            i * 2 as libc::c_int + 1 as libc::c_int,
            start / (3600 as libc::c_int * rounded_fps) as libc::c_long
                % 60 as libc::c_int as libc::c_long,
            start / (60 as libc::c_int * rounded_fps) as libc::c_long
                % 60 as libc::c_int as libc::c_long,
            start / rounded_fps as libc::c_long % 60 as libc::c_int as libc::c_long,
            start % rounded_fps as libc::c_long,
        );
        fprintf(
            scf_file,
            b"CHAPTER%02iNAME=%s\n\0" as *const u8 as *const libc::c_char,
            i * 2 as libc::c_int + 1 as libc::c_int,
            b"Commercial starts\0" as *const u8 as *const libc::c_char,
        );
        fprintf(
            scf_file,
            b"CHAPTER%02i=%02li:%02li:%02li.%03li\n\0" as *const u8 as *const libc::c_char,
            i * 2 as libc::c_int + 2 as libc::c_int,
            end / (3600 as libc::c_int * rounded_fps) as libc::c_long
                % 60 as libc::c_int as libc::c_long,
            end / (60 as libc::c_int * rounded_fps) as libc::c_long
                % 60 as libc::c_int as libc::c_long,
            end / rounded_fps as libc::c_long % 60 as libc::c_int as libc::c_long,
            end % rounded_fps as libc::c_long,
        );
        fprintf(
            scf_file,
            b"CHAPTER%02iNAME=%s\n\0" as *const u8 as *const libc::c_char,
            i * 2 as libc::c_int + 2 as libc::c_int,
            b"Commercial ends\0" as *const u8 as *const libc::c_char,
        );
    }
    if !scf_file.is_null() && last as libc::c_int != 0 {
        fclose(scf_file);
    }
    if !ffmeta_file.is_null() {
        if prev != -(1 as libc::c_int) as libc::c_long && prev < start {
            fprintf(
                ffmeta_file,
                b"[CHAPTER]\nTIMEBASE=1/100\nSTART=%llu\nEND=%llu\ntitle=Show Segment\n\0"
                    as *const u8 as *const libc::c_char,
                (get_frame_pts((prev + 1 as libc::c_int as libc::c_long) as libc::c_int)
                    * 100 as libc::c_int as libc::c_double) as uint64_t,
                (get_frame_pts(start as libc::c_int) * 100 as libc::c_int as libc::c_double)
                    as uint64_t,
            );
        } else if prev == -(1 as libc::c_int) as libc::c_long
            && start > 5 as libc::c_int as libc::c_long
        {
            fprintf(
                ffmeta_file,
                b"[CHAPTER]\nTIMEBASE=1/100\nSTART=%llu\nEND=%llu\ntitle=Show Segment\n\0"
                    as *const u8 as *const libc::c_char,
                0 as libc::c_int as uint64_t,
                (get_frame_pts(start as libc::c_int) * 100 as libc::c_int as libc::c_double)
                    as uint64_t,
            );
        }
        if start <= 5 as libc::c_int as libc::c_long {
            start = 0 as libc::c_int as libc::c_long;
        }
        if end - start > 2 as libc::c_int as libc::c_long {
            fprintf(
                ffmeta_file,
                b"[CHAPTER]\nTIMEBASE=1/100\nSTART=%llu\nEND=%llu\ntitle=Commercial Segment\n\0"
                    as *const u8 as *const libc::c_char,
                (get_frame_pts(start as libc::c_int) * 100 as libc::c_int as libc::c_double)
                    as uint64_t,
                (get_frame_pts(end as libc::c_int) * 100 as libc::c_int as libc::c_double)
                    as uint64_t,
            );
        }
    }
    if !ffmeta_file.is_null() && last as libc::c_int != 0 {
        fclose(ffmeta_file);
    }
    if !ffsplit_file.is_null() {
        if prev != -(1 as libc::c_int) as libc::c_long && prev < start {
            fprintf(
                ffsplit_file,
                b"-c copy -ss %.3f -t %.3f segment%03d.ts \n\0" as *const u8 as *const libc::c_char,
                get_frame_pts((prev + 1 as libc::c_int as libc::c_long) as libc::c_int),
                get_frame_pts(start as libc::c_int)
                    - get_frame_pts((prev + 1 as libc::c_int as libc::c_long) as libc::c_int),
                i,
            );
        } else if prev == -(1 as libc::c_int) as libc::c_long
            && start > 5 as libc::c_int as libc::c_long
        {
            fprintf(
                ffsplit_file,
                b"-c copy -ss %.3f -t %.3f segment%03d.ts \n\0" as *const u8 as *const libc::c_char,
                0.0f64,
                get_frame_pts(start as libc::c_int),
                i,
            );
        }
    }
    if !ffsplit_file.is_null() && last as libc::c_int != 0 {
        fclose(ffsplit_file);
    }
    if !vcf_file.is_null()
        && prev < start
        && start - prev > 5 as libc::c_int as libc::c_long
        && prev > 0 as libc::c_int as libc::c_long
    {
        fprintf(
            vcf_file,
            b"VirtualDub.subset.AddRange(%li,%li);\n\0" as *const u8 as *const libc::c_char,
            ((if !frame.is_null() {
                (if prev - 1 as libc::c_int as libc::c_long <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if prev - 1 as libc::c_int as libc::c_long >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((prev - 1 as libc::c_int as libc::c_long) as isize)).pts
                    })
                })
            } else {
                (prev - 1 as libc::c_int as libc::c_long) as libc::c_double / fps
            }) * fps
                + 1.5f64) as libc::c_long,
            ((if !frame.is_null() {
                (if start <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if start >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(start as isize)).pts
                    })
                })
            } else {
                start as libc::c_double / fps
            }) * fps
                + 1.5f64) as libc::c_long
                - ((if !frame.is_null() {
                    (if prev <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if prev >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(prev as isize)).pts
                        })
                    })
                } else {
                    prev as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
        );
    }
    if !vcf_file.is_null() && last as libc::c_int != 0 {
        fclose(vcf_file);
    }
    if !vdr_file.is_null() && prev < start && end - start > 2 as libc::c_int as libc::c_long {
        if start < 5 as libc::c_int as libc::c_long {
            start = 0 as libc::c_int as libc::c_long;
        }
        fprintf(
            vdr_file,
            b"%s start\n\0" as *const u8 as *const libc::c_char,
            dblSecondsToStrMinutesFrames(get_frame_pts(start as libc::c_int)),
        );
        fprintf(
            vdr_file,
            b"%s end\n\0" as *const u8 as *const libc::c_char,
            dblSecondsToStrMinutesFrames(get_frame_pts(end as libc::c_int)),
        );
    }
    if !vdr_file.is_null() && last as libc::c_int != 0 {
        fclose(vdr_file);
    }
    if !projectx_file.is_null() && prev < start {
        fprintf(
            projectx_file,
            b"%ld\n\0" as *const u8 as *const libc::c_char,
            ((if !frame.is_null() {
                (if prev + 1 as libc::c_int as libc::c_long <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if prev + 1 as libc::c_int as libc::c_long >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((prev + 1 as libc::c_int as libc::c_long) as isize)).pts
                    })
                })
            } else {
                (prev + 1 as libc::c_int as libc::c_long) as libc::c_double / fps
            }) * fps
                + 1.5f64) as libc::c_long,
        );
        fprintf(
            projectx_file,
            b"%ld\n\0" as *const u8 as *const libc::c_char,
            ((if !frame.is_null() {
                (if start <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if start >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(start as isize)).pts
                    })
                })
            } else {
                start as libc::c_double / fps
            }) * fps
                + 1.5f64) as libc::c_long,
        );
    }
    if !projectx_file.is_null() && last as libc::c_int != 0 {
        fclose(projectx_file);
    }
    if !avisynth_file.is_null() && prev < start {
        fprintf(
            avisynth_file,
            b"%strim(%ld,\0" as *const u8 as *const libc::c_char,
            if prev < 10 as libc::c_int as libc::c_long {
                b"\0" as *const u8 as *const libc::c_char
            } else {
                b" ++ \0" as *const u8 as *const libc::c_char
            },
            ((if !frame.is_null() {
                (if prev + 1 as libc::c_int as libc::c_long <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if prev + 1 as libc::c_int as libc::c_long >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((prev + 1 as libc::c_int as libc::c_long) as isize)).pts
                    })
                })
            } else {
                (prev + 1 as libc::c_int as libc::c_long) as libc::c_double / fps
            }) * fps
                + 1.5f64) as libc::c_long,
        );
        fprintf(
            avisynth_file,
            b"%ld)\0" as *const u8 as *const libc::c_char,
            ((if !frame.is_null() {
                (if start <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if start >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(start as isize)).pts
                    })
                })
            } else {
                start as libc::c_double / fps
            }) * fps
                + 1.5f64) as libc::c_long,
        );
    }
    if !avisynth_file.is_null() && last as libc::c_int != 0 {
        fprintf(avisynth_file, b"\n\0" as *const u8 as *const libc::c_char);
    }
    if !avisynth_file.is_null() && last as libc::c_int != 0 {
        fclose(avisynth_file);
    }
    if !videoredo_file.is_null() && prev < start && end - start > 2 as libc::c_int as libc::c_long {
        if i == 0 as libc::c_int && demux_pid != 0 {
            fprintf(
                videoredo_file,
                b"<VideoStreamPID>%d\n<AudioStreamPID>%d\n<SubtitlePID1>%d\n\0" as *const u8
                    as *const libc::c_char,
                selected_video_pid,
                selected_audio_pid,
                selected_subtitle_pid,
            );
        }
        s_start = max(
            (start - videoredo_offset as libc::c_long - 1 as libc::c_int as libc::c_long)
                as libc::c_int,
            0 as libc::c_int,
        );
        s_end = max(
            (end - videoredo_offset as libc::c_long - 1 as libc::c_int as libc::c_long)
                as libc::c_int,
            0 as libc::c_int,
        );
        fprintf(
            videoredo_file,
            b"<Cut>%.0f:%.0f\n\0" as *const u8 as *const libc::c_char,
            get_frame_pts(s_start) * 10000000 as libc::c_int as libc::c_double,
            get_frame_pts(s_end) * 10000000 as libc::c_int as libc::c_double,
        );
    }
    if !videoredo_file.is_null() && last as libc::c_int != 0 {
        fclose(videoredo_file);
    }
    if !videoredo3_file.is_null() && prev < start && end - start > 2 as libc::c_int as libc::c_long
    {
        if i == 0 as libc::c_int && demux_pid != 0 {
            fprintf(
                videoredo3_file,
                b"<InputPIDList><VideoStreamPID>%d</VideoStreamPID>\n<AudioStreamPID>%d</AudioStreamPID><SubtitlePID1>%d</SubtitlePID1></InputPIDList>\n\0"
                    as *const u8 as *const libc::c_char,
                selected_video_pid,
                selected_audio_pid,
                selected_subtitle_pid,
            );
        }
        s_start = max(
            (start - videoredo_offset as libc::c_long - 1 as libc::c_int as libc::c_long)
                as libc::c_int,
            0 as libc::c_int,
        );
        s_end = max(
            (end - videoredo_offset as libc::c_long - 1 as libc::c_int as libc::c_long)
                as libc::c_int,
            0 as libc::c_int,
        );
        fprintf(
            videoredo3_file,
            b"<Cut><CutTimeStart>%.0f</CutTimeStart> <CutTimeEnd>%.0f</CutTimeEnd> </Cut>\n\0"
                as *const u8 as *const libc::c_char,
            get_frame_pts(s_start) * 10000000 as libc::c_int as libc::c_double,
            get_frame_pts(s_end) * 10000000 as libc::c_int as libc::c_double,
        );
    }
    if !videoredo3_file.is_null() {
        if last {
            fprintf(
                videoredo3_file,
                b"</CutList>\n\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if !videoredo3_file.is_null() && last as libc::c_int != 0 {
        fclose(videoredo3_file);
    }
    if !btv_file.is_null() && prev < start {
        strcpy(
            scomment.as_mut_ptr(),
            dblSecondsToStrMinutes(get_frame_pts(start as libc::c_int)),
        );
        strcpy(
            ecomment.as_mut_ptr(),
            dblSecondsToStrMinutes(get_frame_pts(end as libc::c_int)),
        );
        fprintf(
            btv_file,
            b"<Region><start comment=\"%s\">%.0f</start><end comment=\"%s\">%.0f</end></Region>\n\0"
                as *const u8 as *const libc::c_char,
            scomment.as_mut_ptr(),
            get_frame_pts(start as libc::c_int) * 10000000 as libc::c_int as libc::c_double,
            ecomment.as_mut_ptr(),
            get_frame_pts(end as libc::c_int) * 10000000 as libc::c_int as libc::c_double,
        );
        if last {
            fprintf(
                btv_file,
                b"</cutlist>\n\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if !btv_file.is_null() && last as libc::c_int != 0 {
        fclose(btv_file);
    }
    if !edl_file.is_null() && prev < start && end - start > 2 as libc::c_int as libc::c_long {
        if start < 5 as libc::c_int as libc::c_long {
            start = 0 as libc::c_int as libc::c_long;
        }
        s_start = max(
            (start - edl_offset as libc::c_long) as libc::c_int,
            0 as libc::c_int,
        );
        s_end = max(
            (end - edl_offset as libc::c_long) as libc::c_int,
            0 as libc::c_int,
        );
        if demux_pid != 0 && enable_mencoder_pts as libc::c_int != 0 {
            fprintf(
                edl_file,
                b"%.2f\t%.2f\t%d\n\0" as *const u8 as *const libc::c_char,
                get_frame_pts(s_start)
                    + (if !frame.is_null() {
                        (if 1 as libc::c_int <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if 1 as libc::c_int >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            })
                        })
                    } else {
                        1 as libc::c_int as libc::c_double / fps
                    }),
                get_frame_pts(s_end)
                    + (if !frame.is_null() {
                        (if 1 as libc::c_int <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if 1 as libc::c_int >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            })
                        })
                    } else {
                        1 as libc::c_int as libc::c_double / fps
                    }),
                edl_skip_field,
            );
        } else {
            fprintf(
                edl_file,
                b"%.2f\t%.2f\t%d\n\0" as *const u8 as *const libc::c_char,
                get_frame_pts(s_start),
                get_frame_pts(s_end),
                edl_skip_field,
            );
        }
    }
    if !edl_file.is_null() && last as libc::c_int != 0 {
        fclose(edl_file);
    }
    if !live_file.is_null() && prev < start && end - start > 2 as libc::c_int as libc::c_long {
        if start < 5 as libc::c_int as libc::c_long {
            start = 0 as libc::c_int as libc::c_long;
        }
        s_start = max(
            (start - edl_offset as libc::c_long) as libc::c_int,
            0 as libc::c_int,
        );
        s_end = max(
            (end - edl_offset as libc::c_long) as libc::c_int,
            0 as libc::c_int,
        );
        if demux_pid != 0 && enable_mencoder_pts as libc::c_int != 0 {
            fprintf(
                live_file,
                b"%.2f\t%.2f\t%d\n\0" as *const u8 as *const libc::c_char,
                get_frame_pts(s_start)
                    + (if !frame.is_null() {
                        (if 1 as libc::c_int <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if 1 as libc::c_int >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            })
                        })
                    } else {
                        1 as libc::c_int as libc::c_double / fps
                    }),
                get_frame_pts(s_end)
                    + (if !frame.is_null() {
                        (if 1 as libc::c_int <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if 1 as libc::c_int >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            })
                        })
                    } else {
                        1 as libc::c_int as libc::c_double / fps
                    }),
                edl_skip_field,
            );
        } else {
            fprintf(
                live_file,
                b"%.2f\t%.2f\t%d\n\0" as *const u8 as *const libc::c_char,
                get_frame_pts(s_start),
                get_frame_pts(s_end),
                edl_skip_field,
            );
        }
    }
    if !live_file.is_null() && last as libc::c_int != 0 {
        fclose(live_file);
    }
    if !ipodchap_file.is_null() && prev < start && end - start > 2 as libc::c_int as libc::c_long {
        fprintf(
            ipodchap_file,
            b"CHAPTER%.2i=%s\nCHAPTER%.2iNAME=%d\n\0" as *const u8 as *const libc::c_char,
            i + 2 as libc::c_int,
            dblSecondsToStrMinutes(get_frame_pts(end as libc::c_int)),
            i + 2 as libc::c_int,
            i + 2 as libc::c_int,
        );
    }
    if !ipodchap_file.is_null() && last as libc::c_int != 0 {
        fclose(ipodchap_file);
    }
    if !edlp_file.is_null() && prev < start && end - start > 2 as libc::c_int as libc::c_long {
        if start < 5 as libc::c_int as libc::c_long {
            start = 0 as libc::c_int as libc::c_long;
        }
        fprintf(
            edlp_file,
            b"%.2f\t%.2f\t%d\n\0" as *const u8 as *const libc::c_char,
            get_frame_pts(start as libc::c_int)
                + (if !frame.is_null() {
                    (if 1 as libc::c_int <= 0 as libc::c_int {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if 1 as libc::c_int >= framenum_real {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        })
                    })
                } else {
                    1 as libc::c_int as libc::c_double / fps
                }),
            get_frame_pts(end as libc::c_int)
                + (if !frame.is_null() {
                    (if 1 as libc::c_int <= 0 as libc::c_int {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if 1 as libc::c_int >= framenum_real {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        })
                    })
                } else {
                    1 as libc::c_int as libc::c_double / fps
                }),
            edl_skip_field,
        );
    }
    if !edlp_file.is_null() && last as libc::c_int != 0 {
        fclose(edlp_file);
    }
    if !bcf_file.is_null() && prev < start && end - start > 2 as libc::c_int as libc::c_long {
        fprintf(
            bcf_file,
            b"1,%.0f,%.0f\n\0" as *const u8 as *const libc::c_char,
            get_frame_pts(start as libc::c_int) * 1000.0f64,
            get_frame_pts(end as libc::c_int) * 1000.0f64,
        );
    }
    if !bcf_file.is_null() && last as libc::c_int != 0 {
        fclose(bcf_file);
    }
    if !edlx_file.is_null() && !frame.is_null() {
        if prev < start && end - start > 2 as libc::c_int as libc::c_long {
            fprintf(
                edlx_file,
                b"<region start=\"%lld\" end=\"%lld\"/> \n\0" as *const u8 as *const libc::c_char,
                (*frame.offset(start as isize)).goppos,
                (*frame.offset(end as isize)).goppos,
            );
        }
        if last {
            fprintf(
                edlx_file,
                b"</regionlist>\n\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if !edlx_file.is_null() && last as libc::c_int != 0 {
        fclose(edlx_file);
    }
    if !womble_file.is_null() {
        if !last {
            if (start - prev) as libc::c_double > fps {
                fprintf(
                    womble_file,
                    b"CLIPLIST: #%i show\nCLIP: %s\n6 %li %li\n\0" as *const u8
                        as *const libc::c_char,
                    i + 1 as libc::c_int,
                    mpegfilename.as_mut_ptr(),
                    ((if !frame.is_null() {
                        (if prev + 1 as libc::c_int as libc::c_long
                            <= 0 as libc::c_int as libc::c_long
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if prev + 1 as libc::c_int as libc::c_long
                                >= framenum_real as libc::c_long
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((prev + 1 as libc::c_int as libc::c_long) as isize))
                                    .pts
                            })
                        })
                    } else {
                        (prev + 1 as libc::c_int as libc::c_long) as libc::c_double / fps
                    }) * fps
                        + 1.5f64) as libc::c_long,
                    ((if !frame.is_null() {
                        (if start <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if start >= framenum_real as libc::c_long {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(start as isize)).pts
                            })
                        })
                    } else {
                        start as libc::c_double / fps
                    }) * fps
                        + 1.5f64) as libc::c_long
                        - ((if !frame.is_null() {
                            (if prev <= 0 as libc::c_int as libc::c_long {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if prev >= framenum_real as libc::c_long {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                                } else {
                                    (*frame.offset(prev as isize)).pts
                                })
                            })
                        } else {
                            prev as libc::c_double / fps
                        }) * fps
                            + 1.5f64) as libc::c_long,
                );
            }
            fprintf(
                womble_file,
                b"CLIPLIST: #%i commercial\nCLIP: %s\n6 %li %li\n\0" as *const u8
                    as *const libc::c_char,
                i + 1 as libc::c_int,
                mpegfilename.as_mut_ptr(),
                ((if !frame.is_null() {
                    (if start <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if start >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(start as isize)).pts
                        })
                    })
                } else {
                    start as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
                ((if !frame.is_null() {
                    (if end <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if end >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(end as isize)).pts
                        })
                    })
                } else {
                    end as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long
                    - ((if !frame.is_null() {
                        (if start <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if start >= framenum_real as libc::c_long {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(start as isize)).pts
                            })
                        })
                    } else {
                        start as libc::c_double / fps
                    }) * fps
                        + 1.5f64) as libc::c_long,
            );
        } else if end - prev > 0 as libc::c_int as libc::c_long {
            fprintf(
                womble_file,
                b"CLIPLIST: #%i show\nCLIP: %s\n6 %li %li\n\0" as *const u8 as *const libc::c_char,
                i + 1 as libc::c_int,
                mpegfilename.as_mut_ptr(),
                ((if !frame.is_null() {
                    (if prev + 1 as libc::c_int as libc::c_long <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if prev + 1 as libc::c_int as libc::c_long >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((prev + 1 as libc::c_int as libc::c_long) as isize)).pts
                        })
                    })
                } else {
                    (prev + 1 as libc::c_int as libc::c_long) as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
                ((if !frame.is_null() {
                    (if end <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if end >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(end as isize)).pts
                        })
                    })
                } else {
                    end as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long
                    - ((if !frame.is_null() {
                        (if prev <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if prev >= framenum_real as libc::c_long {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(prev as isize)).pts
                            })
                        })
                    } else {
                        prev as libc::c_double / fps
                    }) * fps
                        + 1.5f64) as libc::c_long,
            );
        }
    }
    if !womble_file.is_null() && last as libc::c_int != 0 {
        fclose(womble_file);
    }
    if !mls_file.is_null() {
        if i == 0 as libc::c_int {
            count = (commercial_count + 1 as libc::c_int) * 2 as libc::c_int + 1 as libc::c_int;
            if (start as libc::c_double) < fps {
                count -= 1 as libc::c_int;
            }
            fprintf(
                mls_file,
                b"[BookmarkList]\nPathName= %s\nVideoStreamID= 0\nFormat= frame\nCount= %d\n\0"
                    as *const u8 as *const libc::c_char,
                mpegfilename.as_mut_ptr(),
                count,
            );
            if start as libc::c_double >= fps {
                fprintf(
                    mls_file,
                    b"%11i 1\n\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int,
                );
            }
        } else {
            fprintf(
                mls_file,
                b"%11li 1\n\0" as *const u8 as *const libc::c_char,
                ((if !frame.is_null() {
                    (if prev <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if prev >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(prev as isize)).pts
                        })
                    })
                } else {
                    prev as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
            );
        }
        if !last {
            fprintf(
                mls_file,
                b"%11li 0\n\0" as *const u8 as *const libc::c_char,
                ((if !frame.is_null() {
                    (if start <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if start >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(start as isize)).pts
                        })
                    })
                } else {
                    start as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
            );
        } else if start < end - 5 as libc::c_int as libc::c_long {
            fprintf(
                mls_file,
                b"%11li 0\n\0" as *const u8 as *const libc::c_char,
                ((if !frame.is_null() {
                    (if start <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if start >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(start as isize)).pts
                        })
                    })
                } else {
                    start as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
            );
            fprintf(
                mls_file,
                b"%11li 1\n\0" as *const u8 as *const libc::c_char,
                ((if !frame.is_null() {
                    (if end <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if end >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(end as isize)).pts
                        })
                    })
                } else {
                    end as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
            );
        }
    }
    if !mls_file.is_null() && last as libc::c_int != 0 {
        fclose(mls_file);
    }
    if !mpgtx_file.is_null() {
        if !last {
            if start - prev > 0 as libc::c_int as libc::c_long {
                fprintf(
                    mpgtx_file,
                    b"[%s-\0" as *const u8 as *const libc::c_char,
                    if (prev as libc::c_double) < fps {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        intSecondsToStrMinutes(get_frame_pts(prev as libc::c_int) as libc::c_int)
                            as *const libc::c_char
                    },
                );
                fprintf(
                    mpgtx_file,
                    b"%s] \0" as *const u8 as *const libc::c_char,
                    intSecondsToStrMinutes(get_frame_pts(start as libc::c_int) as libc::c_int),
                );
            }
        } else {
            if end - prev > 0 as libc::c_int as libc::c_long {
                fprintf(
                    mpgtx_file,
                    b"[%s-]\0" as *const u8 as *const libc::c_char,
                    intSecondsToStrMinutes(get_frame_pts(
                        (prev + 1 as libc::c_int as libc::c_long) as libc::c_int,
                    ) as libc::c_int),
                );
            }
            fprintf(mpgtx_file, b"\n\0" as *const u8 as *const libc::c_char);
        }
    }
    if !mpgtx_file.is_null() && last as libc::c_int != 0 {
        fclose(mpgtx_file);
    }
    if !dvrcut_file.is_null() {
        if start - prev > fps as libc::c_int as libc::c_long {
            fprintf(
                dvrcut_file,
                b"%s \0" as *const u8 as *const libc::c_char,
                intSecondsToStrMinutes(get_frame_pts(prev as libc::c_int) as libc::c_int),
            );
            fprintf(
                dvrcut_file,
                b"%s \0" as *const u8 as *const libc::c_char,
                intSecondsToStrMinutes(get_frame_pts(start as libc::c_int) as libc::c_int),
            );
        }
        if last {
            fprintf(dvrcut_file, b"\n\0" as *const u8 as *const libc::c_char);
        }
    }
    if !dvrcut_file.is_null() && last as libc::c_int != 0 {
        fclose(dvrcut_file);
    }
    if !dvrmstb_file.is_null() {
        if end - start > 1 as libc::c_int as libc::c_long {
            if start == 1 as libc::c_int as libc::c_long {
                start = 0 as libc::c_int as libc::c_long;
            }
            fprintf(
                dvrmstb_file,
                b"  <commercial start=\"%f\" end=\"%f\" />\n\0" as *const u8 as *const libc::c_char,
                get_frame_pts(start as libc::c_int),
                get_frame_pts(end as libc::c_int),
            );
        }
        if last {
            fprintf(
                dvrmstb_file,
                b" </root>\n\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if !dvrmstb_file.is_null() && last as libc::c_int != 0 {
        fclose(dvrmstb_file);
    }
    if !mpeg2schnitt_file.is_null() {
        if end - start > 1 as libc::c_int as libc::c_long {
            fprintf(
                mpeg2schnitt_file,
                b"/o%ld \0" as *const u8 as *const libc::c_char,
                ((if !frame.is_null() {
                    (if start <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if start >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(start as isize)).pts
                        })
                    })
                } else {
                    start as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
            );
            fprintf(
                mpeg2schnitt_file,
                b"/i%ld \0" as *const u8 as *const libc::c_char,
                ((if !frame.is_null() {
                    (if end <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if end >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(end as isize)).pts
                        })
                    })
                } else {
                    end as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
            );
        }
        if last {
            fprintf(
                mpeg2schnitt_file,
                b"\n\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if !mpeg2schnitt_file.is_null() && last as libc::c_int != 0 {
        fclose(mpeg2schnitt_file);
    }
    if !cuttermaran_file.is_null() {
        if (prev + 1 as libc::c_int as libc::c_long) < start {
            fprintf(
                cuttermaran_file,
                b"<CutElements refVideoFile=\"0\" StartPosition=\"%li\" EndPosition=\"%li\">\n\0"
                    as *const u8 as *const libc::c_char,
                ((if !frame.is_null() {
                    (if prev + 1 as libc::c_int as libc::c_long <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if prev + 1 as libc::c_int as libc::c_long >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((prev + 1 as libc::c_int as libc::c_long) as isize)).pts
                        })
                    })
                } else {
                    (prev + 1 as libc::c_int as libc::c_long) as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
                ((if !frame.is_null() {
                    (if start - 1 as libc::c_int as libc::c_long <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if start - 1 as libc::c_int as libc::c_long
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((start - 1 as libc::c_int as libc::c_long) as isize)).pts
                        })
                    })
                } else {
                    (start - 1 as libc::c_int as libc::c_long) as libc::c_double / fps
                }) * fps
                    + 1.5f64) as libc::c_long,
            );
            fprintf(
                cuttermaran_file,
                b"<CurrentFiles refVideoFiles=\"0\" /> <cutAudioFiles refAudioFile=\"1\" /></CutElements>\n\0"
                    as *const u8 as *const libc::c_char,
            );
        }
        if last {
            if cuttermaran_options[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
                fprintf(
                    cuttermaran_file,
                    b"<CmdArgs OutFile=\"%s_clean.m2v\" cut=\"true\" unattended=\"true\" snapToCutPoints=\"true\" closeApp=\"true\" />\n</StateData>\n\0"
                        as *const u8 as *const libc::c_char,
                    inbasename.as_mut_ptr(),
                );
            } else {
                fprintf(
                    cuttermaran_file,
                    b"<CmdArgs OutFile=\"%s_clean.m2v\" %s />\n</StateData>\n\0" as *const u8
                        as *const libc::c_char,
                    inbasename.as_mut_ptr(),
                    cuttermaran_options.as_mut_ptr(),
                );
            }
        }
    }
    if !cuttermaran_file.is_null() && last as libc::c_int != 0 {
        fclose(cuttermaran_file);
    }
}
#[no_mangle]
pub unsafe extern "C" fn CompareLetter(
    mut value: libc::c_int,
    mut average: libc::c_int,
    mut i: libc::c_int,
) -> libc::c_char {
    if cblock[i as usize].reffer as libc::c_int == '+' as i32
        || cblock[i as usize].reffer as libc::c_int == '-' as i32
    {
        if value as libc::c_double > 1.2f64 * average as libc::c_double {
            if cblock[i as usize].reffer as libc::c_int == '-' as i32 {
                return '=' as i32 as libc::c_char;
            } else {
                return '!' as i32 as libc::c_char;
            }
        }
        if (value as libc::c_double) < 0.8f64 * average as libc::c_double {
            if cblock[i as usize].reffer as libc::c_int == '-' as i32 {
                return '!' as i32 as libc::c_char;
            } else {
                return '=' as i32 as libc::c_char;
            }
        }
    }
    if value > average {
        return '+' as i32 as libc::c_char;
    }
    if value < average {
        return '-' as i32 as libc::c_char;
    }
    return '0' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn BuildCommercial() {
    let mut i: libc::c_int = 0;
    commercial_count = -(1 as libc::c_int);
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        if cblock[i as usize].score > global_threshold {
            commercial_count += 1;
            commercial[commercial_count as usize].start_frame = cblock[i as usize].f_start;
            commercial[commercial_count as usize].end_frame = cblock[i as usize].f_end;
            commercial[commercial_count as usize].length = (if !frame.is_null() {
                (if commercial[commercial_count as usize].end_frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[commercial_count as usize].end_frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[commercial_count as usize].end_frame as isize))
                            .pts
                    })
                })
            } else {
                commercial[commercial_count as usize].end_frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if commercial[commercial_count as usize].start_frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[commercial_count as usize].start_frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[commercial_count as usize].start_frame as isize))
                            .pts
                    })
                })
            } else {
                commercial[commercial_count as usize].start_frame as libc::c_double / fps
            });
            commercial[commercial_count as usize].start_block = i;
            commercial[commercial_count as usize].end_block = i;
            cblock[i as usize].iscommercial = 1 as libc::c_int;
            i += 1;
            while (i as libc::c_long) < block_count && cblock[i as usize].score > global_threshold {
                commercial[commercial_count as usize].end_frame = cblock[i as usize].f_end;
                commercial[commercial_count as usize].length = (if !frame.is_null() {
                    (if commercial[commercial_count as usize].end_frame
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if commercial[commercial_count as usize].end_frame
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame
                                .offset(commercial[commercial_count as usize].end_frame as isize))
                            .pts
                        })
                    })
                } else {
                    commercial[commercial_count as usize].end_frame as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if commercial[commercial_count as usize].start_frame
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if commercial[commercial_count as usize].start_frame
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame
                                .offset(commercial[commercial_count as usize].start_frame as isize))
                            .pts
                        })
                    })
                } else {
                    commercial[commercial_count as usize].start_frame as libc::c_double / fps
                });
                commercial[commercial_count as usize].end_block = i;
                cblock[i as usize].iscommercial = 1 as libc::c_int;
                i += 1;
            }
        } else {
            cblock[i as usize].iscommercial = 0 as libc::c_int;
        }
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OutputBlocks() -> bool {
    let mut i: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut prev: libc::c_long = 0;
    let mut comlength: libc::c_double = 0.;
    let mut threshold: libc::c_double = 0.;
    let mut foundCommercials: bool = 0 as libc::c_int != 0;
    let mut deleted: bool = 0 as libc::c_int != 0;
    if global_threshold >= 0.0f64 {
        threshold = global_threshold;
    } else {
        threshold = FindScoreThreshold(score_percentile);
    }
    OpenOutputFiles();
    Debug(
        1 as libc::c_int,
        b"Threshold used - %.4f\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        threshold,
    );
    threshold = ceil(threshold * 100 as libc::c_int as libc::c_double) / 100.0f64;
    Debug(
        1 as libc::c_int,
        b"\tAfter rounding - %.4f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        threshold,
    );
    BuildCommercial();
    if disable_heuristics & (1 as libc::c_int) << 5 as libc::c_int - 1 as libc::c_int == 0 {
        if delete_block_after_commercial > 0 as libc::c_int {
            k = commercial_count;
            while k >= 0 as libc::c_int {
                i = commercial[k as usize].end_block + 1 as libc::c_int;
                if (i as libc::c_long) < block_count
                    && cblock[i as usize].length < delete_block_after_commercial as libc::c_double
                    && cblock[i as usize].score < threshold
                {
                    Debug(
                        3 as libc::c_int,
                        b"H5 Deleting cblock %i because it is short and comes after a commercial.\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i,
                    );
                    commercial[k as usize].end_frame = cblock[i as usize].f_end;
                    commercial[k as usize].length = (if !frame.is_null() {
                        (if commercial[k as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if commercial[k as usize].end_frame >= framenum_real as libc::c_long {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(commercial[k as usize].end_frame as isize)).pts
                            })
                        })
                    } else {
                        commercial[k as usize].end_frame as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if commercial[k as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if commercial[k as usize].start_frame >= framenum_real as libc::c_long
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(commercial[k as usize].start_frame as isize)).pts
                            })
                        })
                    } else {
                        commercial[k as usize].start_frame as libc::c_double / fps
                    });
                    commercial[k as usize].end_block = i;
                    cblock[i as usize].iscommercial = 1 as libc::c_int;
                    cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
                        as libc::c_int;
                    cblock[i as usize].score = 99.99f64;
                    cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
                        as libc::c_int;
                }
                k -= 1;
            }
        }
        if commercial_count > -(1 as libc::c_int)
            && (commercial[commercial_count as usize].end_block as libc::c_long)
                < block_count - 1 as libc::c_int as libc::c_long
            && (if !frame.is_null() {
                (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(
                            cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                                as isize,
                        ))
                        .pts
                    })
                })
            } else {
                cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                    as libc::c_double
                    / fps
            }) - (if !frame.is_null() {
                (if cblock[commercial[commercial_count as usize].end_block as usize].f_end
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[commercial[commercial_count as usize].end_block as usize].f_end
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(
                            cblock[commercial[commercial_count as usize].end_block as usize].f_end
                                as isize,
                        ))
                        .pts
                    })
                })
            } else {
                cblock[commercial[commercial_count as usize].end_block as usize].f_end
                    as libc::c_double
                    / fps
            }) < min_show_segment_length / 2.0f64
        {
            commercial[commercial_count as usize].end_block =
                (block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
            commercial[commercial_count as usize].end_frame =
                cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end;
            commercial[commercial_count as usize].length = (if !frame.is_null() {
                (if commercial[commercial_count as usize].end_frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[commercial_count as usize].end_frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[commercial_count as usize].end_frame as isize))
                            .pts
                    })
                })
            } else {
                commercial[commercial_count as usize].end_frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if commercial[commercial_count as usize].start_frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[commercial_count as usize].start_frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[commercial_count as usize].start_frame as isize))
                            .pts
                    })
                })
            } else {
                commercial[commercial_count as usize].start_frame as libc::c_double / fps
            });
            Debug(
                3 as libc::c_int,
                b"H5 Deleting cblock %i of %i seconds because it comes after the last commercial and its too short.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                block_count - 1 as libc::c_int as libc::c_long,
                cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].length
                    as libc::c_int,
            );
            cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].cause =
                (cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].cause
                    as libc::c_long
                    | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
                    as libc::c_int;
            cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].score = 99.99f64;
            cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].more =
                (cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].more
                    as libc::c_long
                    | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
                    as libc::c_int;
        }
        if commercial_count > -(1 as libc::c_int)
            && commercial[0 as libc::c_int as usize].start_block == 1 as libc::c_int
            && (if !frame.is_null() {
                (if cblock[0 as libc::c_int as usize].f_end <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[0 as libc::c_int as usize].f_end >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[0 as libc::c_int as usize].f_end as isize)).pts
                    })
                })
            } else {
                cblock[0 as libc::c_int as usize].f_end as libc::c_double / fps
            }) < min_commercialbreak
        {
            commercial[0 as libc::c_int as usize].start_block = 0 as libc::c_int;
            commercial[0 as libc::c_int as usize].start_frame =
                cblock[0 as libc::c_int as usize].f_start;
            commercial[0 as libc::c_int as usize].length = (if !frame.is_null() {
                (if commercial[0 as libc::c_int as usize].end_frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[0 as libc::c_int as usize].end_frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[0 as libc::c_int as usize].end_frame as isize))
                            .pts
                    })
                })
            } else {
                commercial[0 as libc::c_int as usize].end_frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if commercial[0 as libc::c_int as usize].start_frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[0 as libc::c_int as usize].start_frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[0 as libc::c_int as usize].start_frame as isize))
                            .pts
                    })
                })
            } else {
                commercial[0 as libc::c_int as usize].start_frame as libc::c_double / fps
            });
            Debug(
                3 as libc::c_int,
                b"H5 Deleting cblock %i of %i seconds because its too short and before first commercial.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                0 as libc::c_int,
                cblock[0 as libc::c_int as usize].length as libc::c_int,
            );
            cblock[0 as libc::c_int as usize].score = 99.99f64;
            cblock[0 as libc::c_int as usize].cause = (cblock[0 as libc::c_int as usize].cause
                as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
                as libc::c_int;
            cblock[0 as libc::c_int as usize].more = (cblock[0 as libc::c_int as usize].more
                as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
                as libc::c_int;
        }
    }
    Debug(
        2 as libc::c_int,
        b"\n\n\t---------------------\n\tInitial Commercial List\n\t---------------------\n\0"
            as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    i = 0 as libc::c_int;
    while i <= commercial_count {
        Debug(
            2 as libc::c_int,
            b"%2i) %6i\t%6i\t%s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            i,
            commercial[i as usize].start_frame,
            commercial[i as usize].end_frame,
            dblSecondsToStrMinutes(commercial[i as usize].length),
        );
        i += 1;
    }
    if disable_heuristics & (1 as libc::c_int) << 6 as libc::c_int - 1 as libc::c_int == 0 {
        k = commercial_count;
        while k >= 0 as libc::c_int {
            if ((if !frame.is_null() {
                (if commercial[k as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[k as usize].start_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[k as usize].start_frame as isize)).pts
                    })
                })
            } else {
                commercial[k as usize].start_frame as libc::c_double / fps
            }) > 1.0f64
                || commercial[k as usize].length < 10.2f64)
                && (commercial[k as usize].length > max_commercialbreak
                    && k != 0 as libc::c_int
                    && k != commercial_count
                    || commercial[k as usize].length < min_commercialbreak)
                && (if !frame.is_null() {
                    (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize]
                                    .f_end as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                        as libc::c_double
                        / fps
                }) - (if !frame.is_null() {
                    (if commercial[k as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if commercial[k as usize].start_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(commercial[k as usize].start_frame as isize)).pts
                        })
                    })
                } else {
                    commercial[k as usize].start_frame as libc::c_double / fps
                }) > min_commercial_break_at_start_or_end as libc::c_double
                && (if !frame.is_null() {
                    (if commercial[k as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if commercial[k as usize].end_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(commercial[k as usize].end_frame as isize)).pts
                        })
                    })
                } else {
                    commercial[k as usize].end_frame as libc::c_double / fps
                }) > min_commercial_break_at_start_or_end as libc::c_double
            {
                i = commercial[k as usize].start_block;
                while i <= commercial[k as usize].end_block {
                    Debug(
                        3 as libc::c_int,
                        b"H6 Deleting block %i because it is part of a too short or too long commercial.\n\0"
                            as *const u8 as *const libc::c_char as *mut libc::c_char,
                        i,
                    );
                    cblock[i as usize].score = 0 as libc::c_int as libc::c_double;
                    cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 22 as libc::c_int)
                        as libc::c_int;
                    cblock[i as usize].less = (cblock[i as usize].less as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 22 as libc::c_int)
                        as libc::c_int;
                    i += 1;
                }
                i = k;
                while i < commercial_count {
                    commercial[i as usize] = commercial[(i + 1 as libc::c_int) as usize];
                    i += 1;
                }
                commercial_count -= 1;
                deleted = 1 as libc::c_int != 0;
            }
            k -= 1;
        }
    }
    if delete_show_after_last_commercial != 0
        && commercial_count > -(1 as libc::c_int)
        && (delete_show_after_last_commercial == 1 as libc::c_int
            && cblock[commercial[commercial_count as usize].start_block as usize].f_end
                > before_end as libc::c_long
            || delete_show_after_last_commercial as libc::c_double
                > (if !frame.is_null() {
                    (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize]
                                    .f_end as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                        as libc::c_double
                        / fps
                }) - (if !frame.is_null() {
                    (if cblock[commercial[commercial_count as usize].start_block as usize].f_start
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[commercial[commercial_count as usize].start_block as usize]
                            .f_start
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                cblock[commercial[commercial_count as usize].start_block as usize]
                                    .f_start as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    cblock[commercial[commercial_count as usize].start_block as usize].f_start
                        as libc::c_double
                        / fps
                }))
        && (commercial[commercial_count as usize].end_block as libc::c_long)
            < block_count - 1 as libc::c_int as libc::c_long
    {
        i = commercial[commercial_count as usize].end_block + 1 as libc::c_int;
        commercial[commercial_count as usize].end_block =
            (block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        commercial[commercial_count as usize].end_frame =
            cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end;
        commercial[commercial_count as usize].length = (if !frame.is_null() {
            (if commercial[commercial_count as usize].end_frame <= 0 as libc::c_int as libc::c_long
            {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if commercial[commercial_count as usize].end_frame >= framenum_real as libc::c_long
                {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(commercial[commercial_count as usize].end_frame as isize)).pts
                })
            })
        } else {
            commercial[commercial_count as usize].end_frame as libc::c_double / fps
        }) - (if !frame.is_null() {
            (if commercial[commercial_count as usize].start_frame
                <= 0 as libc::c_int as libc::c_long
            {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if commercial[commercial_count as usize].start_frame
                    >= framenum_real as libc::c_long
                {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(commercial[commercial_count as usize].start_frame as isize)).pts
                })
            })
        } else {
            commercial[commercial_count as usize].start_frame as libc::c_double / fps
        });
        while (i as libc::c_long) < block_count {
            Debug(
                3 as libc::c_int,
                b"H5 Deleting cblock %i of %i seconds because it comes after the last commercial.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
                cblock[i as usize].length as libc::c_int,
            );
            cblock[i as usize].cause = (cblock[i as usize].cause as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
                as libc::c_int;
            cblock[i as usize].score = 99.99f64;
            cblock[i as usize].more = (cblock[i as usize].more as libc::c_long
                | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
                as libc::c_int;
            i += 1;
        }
    }
    if delete_show_before_first_commercial != 0
        && commercial_count > -(1 as libc::c_int)
        && commercial[0 as libc::c_int as usize].start_block == 1 as libc::c_int
        && (delete_show_before_first_commercial == 1 as libc::c_int
            && cblock[commercial[0 as libc::c_int as usize].end_block as usize].f_end
                < after_start as libc::c_long
            || delete_show_before_first_commercial as libc::c_double
                > (if !frame.is_null() {
                    (if cblock[commercial[0 as libc::c_int as usize].end_block as usize].f_end
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[commercial[0 as libc::c_int as usize].end_block as usize].f_end
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                cblock[commercial[0 as libc::c_int as usize].end_block as usize]
                                    .f_end as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    cblock[commercial[0 as libc::c_int as usize].end_block as usize].f_end
                        as libc::c_double
                        / fps
                }))
    {
        commercial[0 as libc::c_int as usize].start_block = 0 as libc::c_int;
        commercial[0 as libc::c_int as usize].start_frame =
            cblock[0 as libc::c_int as usize].f_start;
        commercial[0 as libc::c_int as usize].length = (if !frame.is_null() {
            (if commercial[0 as libc::c_int as usize].end_frame <= 0 as libc::c_int as libc::c_long
            {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if commercial[0 as libc::c_int as usize].end_frame >= framenum_real as libc::c_long
                {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(commercial[0 as libc::c_int as usize].end_frame as isize)).pts
                })
            })
        } else {
            commercial[0 as libc::c_int as usize].end_frame as libc::c_double / fps
        }) - (if !frame.is_null() {
            (if commercial[0 as libc::c_int as usize].start_frame
                <= 0 as libc::c_int as libc::c_long
            {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if commercial[0 as libc::c_int as usize].start_frame
                    >= framenum_real as libc::c_long
                {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(commercial[0 as libc::c_int as usize].start_frame as isize)).pts
                })
            })
        } else {
            commercial[0 as libc::c_int as usize].start_frame as libc::c_double / fps
        });
        Debug(
            3 as libc::c_int,
            b"H5 Deleting cblock %i of %i seconds because it comes before the first commercial.\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
            0 as libc::c_int,
            cblock[0 as libc::c_int as usize].length as libc::c_int,
        );
        cblock[0 as libc::c_int as usize].score = 99.99f64;
        cblock[0 as libc::c_int as usize].cause = (cblock[0 as libc::c_int as usize].cause
            as libc::c_long
            | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
            as libc::c_int;
        cblock[0 as libc::c_int as usize].more = (cblock[0 as libc::c_int as usize].more
            as libc::c_long
            | (1 as libc::c_int as libc::c_long) << 17 as libc::c_int)
            as libc::c_int;
    }
    if always_keep_first_seconds != 0 && commercial_count >= 0 as libc::c_int {
        k = 0 as libc::c_int;
        while commercial_count >= 0 as libc::c_int
            && (if !frame.is_null() {
                (if commercial[k as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[k as usize].end_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[k as usize].end_frame as isize)).pts
                    })
                })
            } else {
                commercial[k as usize].end_frame as libc::c_double / fps
            }) < always_keep_first_seconds as libc::c_double
        {
            Debug(
                3 as libc::c_int,
                b"Deleting commercial block %i because the first %d seconds should always be kept.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                k,
                always_keep_first_seconds,
            );
            i = k;
            while i <= commercial_count {
                commercial[i as usize] = commercial[(i + 1 as libc::c_int) as usize];
                i += 1;
            }
            commercial_count -= 1;
            deleted = 1 as libc::c_int != 0;
        }
        if commercial_count >= 0 as libc::c_int
            && (if !frame.is_null() {
                (if commercial[k as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[k as usize].start_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[k as usize].start_frame as isize)).pts
                    })
                })
            } else {
                commercial[k as usize].start_frame as libc::c_double / fps
            }) < always_keep_first_seconds as libc::c_double
        {
            Debug(
                3 as libc::c_int,
                b"Shortening commercial block %i because the first %d seconds should always be kept.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                k,
                always_keep_first_seconds,
            );
            while (if !frame.is_null() {
                (if commercial[k as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[k as usize].start_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[k as usize].start_frame as isize)).pts
                    })
                })
            } else {
                commercial[k as usize].start_frame as libc::c_double / fps
            }) < always_keep_first_seconds as libc::c_double
                && (commercial[k as usize].start_frame as libc::c_double)
                    < always_keep_first_seconds as libc::c_double * fps
            {
                commercial[k as usize].start_frame += 1;
            }
        }
    }
    if always_keep_last_seconds != 0 && commercial_count >= 0 as libc::c_int {
        k = commercial_count;
        while (if !frame.is_null() {
            (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                <= 0 as libc::c_int as libc::c_long
            {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                    >= framenum_real as libc::c_long
                {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(
                        cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                            as isize,
                    ))
                    .pts
                })
            })
        } else {
            cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                as libc::c_double
                / fps
        }) - (if !frame.is_null() {
            (if commercial[k as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if commercial[k as usize].start_frame >= framenum_real as libc::c_long {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(commercial[k as usize].start_frame as isize)).pts
                })
            })
        } else {
            commercial[k as usize].start_frame as libc::c_double / fps
        }) < always_keep_last_seconds as libc::c_double
        {
            Debug(
                3 as libc::c_int,
                b"Deleting commercial block %i because the last %d seconds should always be kept.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                k,
                always_keep_last_seconds,
            );
            commercial_count -= 1;
            k = commercial_count;
            deleted = 1 as libc::c_int != 0;
        }
        if (if !frame.is_null() {
            (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                <= 0 as libc::c_int as libc::c_long
            {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                    >= framenum_real as libc::c_long
                {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(
                        cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                            as isize,
                    ))
                    .pts
                })
            })
        } else {
            cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                as libc::c_double
                / fps
        }) - (if !frame.is_null() {
            (if commercial[k as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if commercial[k as usize].end_frame >= framenum_real as libc::c_long {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(commercial[k as usize].end_frame as isize)).pts
                })
            })
        } else {
            commercial[k as usize].end_frame as libc::c_double / fps
        }) < always_keep_last_seconds as libc::c_double
        {
            Debug(
                3 as libc::c_int,
                b"Shortening commercial block %i because the last %d seconds should always be kept.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                k,
                always_keep_last_seconds,
            );
            while (if !frame.is_null() {
                (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(
                            cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                                as isize,
                        ))
                        .pts
                    })
                })
            } else {
                cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                    as libc::c_double
                    / fps
            }) - (if !frame.is_null() {
                (if commercial[k as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[k as usize].end_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[k as usize].end_frame as isize)).pts
                    })
                })
            } else {
                commercial[k as usize].end_frame as libc::c_double / fps
            }) < always_keep_last_seconds as libc::c_double
                && ((cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize].f_end
                    - commercial[k as usize].end_frame) as libc::c_double)
                    < fps * always_keep_last_seconds as libc::c_double
            {
                commercial[k as usize].end_frame -= 1;
            }
        }
    }
    if deleted {
        Debug(
            1 as libc::c_int,
            b"\n\n\t---------------------\n\tFinal Commercial List\n\t---------------------\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    } else {
        Debug(
            1 as libc::c_int,
            b"No change\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    i = 0 as libc::c_int;
    while i <= commercial_count {
        commercial[i as usize].start_frame = (commercial[i as usize].start_frame as libc::c_double
            + (padding as libc::c_double * fps - remove_before as libc::c_double * fps))
            as libc::c_long;
        commercial[i as usize].end_frame = (commercial[i as usize].end_frame as libc::c_double
            - (padding as libc::c_double * fps - remove_after as libc::c_double * fps))
            as libc::c_long;
        if commercial[i as usize].end_frame > frame_count {
            commercial[i as usize].end_frame = frame_count;
        }
        commercial[i as usize].length +=
            (-(2 as libc::c_int) * padding + remove_before + remove_after) as libc::c_double;
        i += 1;
    }
    comlength = 0.0f64;
    i = 0 as libc::c_int;
    while i < commercial_count {
        comlength += commercial[i as usize].length;
        i += 1;
    }
    if !zoomplayer_chapter_file.is_null()
        && commercial[0 as libc::c_int as usize].start_frame > 5 as libc::c_int as libc::c_long
    {
        fprintf(
            zoomplayer_chapter_file,
            b"AddChapter(1,Show Segment)\n\0" as *const u8 as *const libc::c_char,
        );
    }
    if !ffmeta_file.is_null() {
        fprintf(
            ffmeta_file,
            b";FFMETADATA1\n\0" as *const u8 as *const libc::c_char,
        );
    }
    prev = -(1 as libc::c_int) as libc::c_long;
    i = 0 as libc::c_int;
    while i <= commercial_count {
        foundCommercials = 1 as libc::c_int != 0;
        if deleted {
            Debug(
                1 as libc::c_int,
                b"%i - start: %6i\tend: %6i\t[%6i:%6i]\tlength: %s\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                i + 1 as libc::c_int,
                commercial[i as usize].start_frame,
                commercial[i as usize].end_frame,
                commercial[i as usize].start_block,
                commercial[i as usize].end_block,
                dblSecondsToStrMinutes(commercial[i as usize].length),
            );
        }
        OutputCommercialBlock(
            i,
            prev,
            commercial[i as usize].start_frame,
            commercial[i as usize].end_frame,
            if commercial[i as usize].end_frame < frame_count - 2 as libc::c_int as libc::c_long {
                0 as libc::c_int
            } else {
                1 as libc::c_int
            } != 0,
        );
        prev = commercial[i as usize].end_frame;
        i += 1;
    }
    if commercial[commercial_count as usize].end_frame
        < frame_count - 2 as libc::c_int as libc::c_long
    {
        OutputCommercialBlock(
            commercial_count + 1 as libc::c_int,
            prev,
            frame_count - 2 as libc::c_int as libc::c_long,
            frame_count - 1 as libc::c_int as libc::c_long,
            1 as libc::c_int != 0,
        );
    }
    if output_videoredo {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.VPrj\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        videoredo_file = myfopen(
            filename.as_mut_ptr(),
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !videoredo_file.is_null() {
            i = 0 as libc::c_int;
            while (i as libc::c_long) < block_count {
                fprintf(
                    videoredo_file,
                    b"<SceneMarker %d>%.0f\n\0" as *const u8 as *const libc::c_char,
                    i,
                    (if !frame.is_null() {
                        (if max(
                            (cblock[i as usize].f_end
                                - videoredo_offset as libc::c_long
                                - 1 as libc::c_int as libc::c_long)
                                as libc::c_int,
                            0 as libc::c_int,
                        ) <= 0 as libc::c_int
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if max(
                                (cblock[i as usize].f_end
                                    - videoredo_offset as libc::c_long
                                    - 1 as libc::c_int as libc::c_long)
                                    as libc::c_int,
                                0 as libc::c_int,
                            ) >= framenum_real
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(max(
                                    (cblock[i as usize].f_end
                                        - videoredo_offset as libc::c_long
                                        - 1 as libc::c_int as libc::c_long)
                                        as libc::c_int,
                                    0 as libc::c_int,
                                ) as isize))
                                .pts
                            })
                        })
                    } else {
                        max(
                            (cblock[i as usize].f_end
                                - videoredo_offset as libc::c_long
                                - 1 as libc::c_int as libc::c_long)
                                as libc::c_int,
                            0 as libc::c_int,
                        ) as libc::c_double
                            / fps
                    }) * 10000000 as libc::c_int as libc::c_double,
                );
                i += 1;
            }
            fclose(videoredo_file);
        }
    }
    if output_videoredo3 {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.VPrj\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        videoredo3_file = myfopen(
            filename.as_mut_ptr(),
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !videoredo3_file.is_null() {
            fprintf(
                videoredo3_file,
                b"<SceneList>\n\0" as *const u8 as *const libc::c_char,
            );
            i = 0 as libc::c_int;
            while (i as libc::c_long) < block_count {
                fprintf(
                    videoredo3_file,
                    b"<SceneMarker Sequence=\"%d\" Timecode=\"%s\">%.0f</SceneMarker>\n\0"
                        as *const u8 as *const libc::c_char,
                    i,
                    dblSecondsToStrMinutes(if !frame.is_null() {
                        if max(
                            (cblock[i as usize].f_end
                                - videoredo_offset as libc::c_long
                                - 1 as libc::c_int as libc::c_long)
                                as libc::c_int,
                            0 as libc::c_int,
                        ) <= 0 as libc::c_int
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else if max(
                            (cblock[i as usize].f_end
                                - videoredo_offset as libc::c_long
                                - 1 as libc::c_int as libc::c_long)
                                as libc::c_int,
                            0 as libc::c_int,
                        ) >= framenum_real
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(max(
                                (cblock[i as usize].f_end
                                    - videoredo_offset as libc::c_long
                                    - 1 as libc::c_int as libc::c_long)
                                    as libc::c_int,
                                0 as libc::c_int,
                            ) as isize))
                            .pts
                        }
                    } else {
                        max(
                            (cblock[i as usize].f_end
                                - videoredo_offset as libc::c_long
                                - 1 as libc::c_int as libc::c_long)
                                as libc::c_int,
                            0 as libc::c_int,
                        ) as libc::c_double
                            / fps
                    }),
                    (if !frame.is_null() {
                        (if max(
                            (cblock[i as usize].f_end
                                - videoredo_offset as libc::c_long
                                - 1 as libc::c_int as libc::c_long)
                                as libc::c_int,
                            0 as libc::c_int,
                        ) <= 0 as libc::c_int
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if max(
                                (cblock[i as usize].f_end
                                    - videoredo_offset as libc::c_long
                                    - 1 as libc::c_int as libc::c_long)
                                    as libc::c_int,
                                0 as libc::c_int,
                            ) >= framenum_real
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(max(
                                    (cblock[i as usize].f_end
                                        - videoredo_offset as libc::c_long
                                        - 1 as libc::c_int as libc::c_long)
                                        as libc::c_int,
                                    0 as libc::c_int,
                                ) as isize))
                                .pts
                            })
                        })
                    } else {
                        max(
                            (cblock[i as usize].f_end
                                - videoredo_offset as libc::c_long
                                - 1 as libc::c_int as libc::c_long)
                                as libc::c_int,
                            0 as libc::c_int,
                        ) as libc::c_double
                            / fps
                    }) * 10000000 as libc::c_int as libc::c_double,
                );
                i += 1;
            }
            fprintf(
                videoredo3_file,
                b"</SceneList>\n\0" as *const u8 as *const libc::c_char,
            );
            fprintf(
                videoredo3_file,
                b"</VideoReDoProject>\n\0" as *const u8 as *const libc::c_char,
            );
            fclose(videoredo3_file);
        }
    }
    if output_chapters {
        if !chapters_file.is_null() {
            i = 0 as libc::c_int;
            while (i as libc::c_long) < block_count {
                fprintf(
                    chapters_file,
                    b"%ld\n\0" as *const u8 as *const libc::c_char,
                    cblock[i as usize].f_end,
                );
                i += 1;
            }
            fclose(chapters_file);
        }
    }
    if !mkvtoolnix_chapters_file.is_null() {
        let mut currentStart: libc::c_double = 0 as libc::c_int as libc::c_double;
        let mut startTimespan: [libc::c_char; 15] = [0; 15];
        let mut endTimespan: [libc::c_char; 15] = [0; 15];
        if output_mkvtoolnix > 0 as libc::c_int {
            fprintf(
                mkvtoolnix_chapters_file,
                b"\t<EditionEntry>\n\t\t<EditionUID>1</EditionUID>\n\0" as *const u8
                    as *const libc::c_char,
            );
            i = 0 as libc::c_int;
            while (i as libc::c_long) < block_count {
                if i == 0 as libc::c_int
                    || cblock[(i - 1 as libc::c_int) as usize].iscommercial
                        != cblock[i as usize].iscommercial
                {
                    currentStart = cblock[i as usize].f_start as libc::c_double;
                }
                if i == i - 1 as libc::c_int
                    || cblock[(i + 1 as libc::c_int) as usize].iscommercial
                        != cblock[i as usize].iscommercial
                {
                    strcpy(
                        startTimespan.as_mut_ptr(),
                        dblSecondsToStrMinutes(get_frame_pts(currentStart as libc::c_int)),
                    );
                    fprintf(
                        mkvtoolnix_chapters_file,
                        b"\t\t<ChapterAtom>\n\t\t\t<ChapterDisplay>\n\t\t\t\t<ChapterString>%s</ChapterString>\n\t\t\t</ChapterDisplay>\n\t\t\t<ChapterTimeStart>%s</ChapterTimeStart>\n\t\t</ChapterAtom>\n\0"
                            as *const u8 as *const libc::c_char,
                        if cblock[i as usize].iscommercial != 0 {
                            b"Commercial\0" as *const u8 as *const libc::c_char
                        } else {
                            b"Show\0" as *const u8 as *const libc::c_char
                        },
                        startTimespan.as_mut_ptr(),
                    );
                }
                i += 1;
            }
            fprintf(
                mkvtoolnix_chapters_file,
                b"\t</EditionEntry>\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if output_mkvtoolnix == 2 as libc::c_int {
            fprintf(
                mkvtoolnix_chapters_file,
                b"\t<EditionEntry>\n\t\t<EditionUID>2</EditionUID>\n\t\t<EditionFlagOrdered>1</EditionFlagOrdered>\n\0"
                    as *const u8 as *const libc::c_char,
            );
            i = 0 as libc::c_int;
            while (i as libc::c_long) < block_count {
                if cblock[i as usize].iscommercial == 0 {
                    if i == 0 as libc::c_int
                        || cblock[(i - 1 as libc::c_int) as usize].iscommercial != 0
                    {
                        currentStart = cblock[i as usize].f_start as libc::c_double;
                    }
                    if i == i - 1 as libc::c_int
                        || cblock[(i + 1 as libc::c_int) as usize].iscommercial != 0
                    {
                        strcpy(
                            startTimespan.as_mut_ptr(),
                            dblSecondsToStrMinutes(get_frame_pts(currentStart as libc::c_int)),
                        );
                        strcpy(
                            endTimespan.as_mut_ptr(),
                            dblSecondsToStrMinutes(get_frame_pts(
                                cblock[i as usize].f_end as libc::c_int,
                            )),
                        );
                        fprintf(
                            mkvtoolnix_chapters_file,
                            b"\t\t<ChapterAtom>\n\t\t\t<ChapterDisplay>\n\t\t\t\t<ChapterString>Show</ChapterString>\n\t\t\t</ChapterDisplay>\n\t\t\t<ChapterFlagEnabled>1</ChapterFlagEnabled>\n\t\t\t<ChapterTimeStart>%s</ChapterTimeStart>\n\t\t\t<ChapterTimeEnd>%s</ChapterTimeEnd>\n\t\t</ChapterAtom>\n\0"
                                as *const u8 as *const libc::c_char,
                            startTimespan.as_mut_ptr(),
                            endTimespan.as_mut_ptr(),
                        );
                    }
                }
                i += 1;
            }
            fprintf(
                mkvtoolnix_chapters_file,
                b"\t</EditionEntry>\n\0" as *const u8 as *const libc::c_char,
            );
        }
        fprintf(
            mkvtoolnix_chapters_file,
            b"</Chapters>\0" as *const u8 as *const libc::c_char,
        );
        fclose(mkvtoolnix_chapters_file);
    }
    if reffer_count == -(1 as libc::c_int) {
        reffer_count = commercial_count;
        i = 0 as libc::c_int;
        while i <= commercial_count {
            reffer[i as usize].start_frame = commercial[i as usize].start_frame;
            reffer[i as usize].end_frame = commercial[i as usize].end_frame;
            i += 1;
        }
    }
    InputReffer(
        b".ref\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        0 as libc::c_int,
    );
    if output_tuning {
        sprintf(
            filename.as_mut_ptr(),
            b"%s.tun\0" as *const u8 as *const libc::c_char,
            workbasename.as_mut_ptr(),
        );
        tuning_file = myfopen(
            filename.as_mut_ptr(),
            b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        fprintf(
            tuning_file,
            b"max_volume=%6i\n\0" as *const u8 as *const libc::c_char,
            min_volume + 200 as libc::c_int,
        );
        fprintf(
            tuning_file,
            b"max_avg_brightness=%6i\n\0" as *const u8 as *const libc::c_char,
            min_brightness_found + 5 as libc::c_int,
        );
        fprintf(
            tuning_file,
            b"max_commercialbreak=%6i\n\0" as *const u8 as *const libc::c_char,
            max_logo_gap + 10 as libc::c_int,
        );
        fprintf(
            tuning_file,
            b"shrink_logo=%.2f\n\0" as *const u8 as *const libc::c_char,
            logo_overshoot,
        );
        fprintf(
            tuning_file,
            b"min_show_segment_length=%6i\n\0" as *const u8 as *const libc::c_char,
            max_nonlogo_block_length + 10 as libc::c_int,
        );
        fprintf(
            tuning_file,
            b"logo_threshold=%.3f\n\0" as *const u8 as *const libc::c_char,
            logo_quality,
        );
    }
    if verbose != 0 {
        Debug(
            1 as libc::c_int,
            b"\nLogo fraction:              %.4f      %s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            logoPercentage,
            if commDetectMethod & 2 as libc::c_int != 0 {
                if reverseLogoLogic as libc::c_int != 0 {
                    b"(Reversed Logo Logic)\0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                }
            } else {
                b"Logo disabled\0" as *const u8 as *const libc::c_char
            },
        );
        Debug(
            1 as libc::c_int,
            b"Maximum volume found:       %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            maxi_volume,
        );
        Debug(
            1 as libc::c_int,
            b"Average volume:             %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            avg_volume,
        );
        Debug(
            1 as libc::c_int,
            b"Sound threshold:            %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            max_volume,
        );
        Debug(
            1 as libc::c_int,
            b"Silence threshold:          %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            max_silence,
        );
        Debug(
            1 as libc::c_int,
            b"Minimum volume found:       %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            min_volume,
        );
        Debug(
            1 as libc::c_int,
            b"Average frames with silence:%6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            avg_silence,
        );
        Debug(
            1 as libc::c_int,
            b"Black threshold:            %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            max_avg_brightness,
        );
        Debug(
            1 as libc::c_int,
            b"Minimum brightness found:   %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            min_brightness_found,
        );
        Debug(
            1 as libc::c_int,
            b"Minimum bright pixels found:%6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            min_hasBright,
        );
        Debug(
            1 as libc::c_int,
            b"Minimum dim level found:    %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            min_dimCount,
        );
        Debug(
            1 as libc::c_int,
            b"Average brightness:         %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            avg_brightness,
        );
        Debug(
            1 as libc::c_int,
            b"Uniformity level:           %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            non_uniformity,
        );
        Debug(
            1 as libc::c_int,
            b"Average non uniformity:     %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            avg_uniform,
        );
        Debug(
            1 as libc::c_int,
            b"Maximum gap between logo's: %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            max_logo_gap,
        );
        Debug(
            1 as libc::c_int,
            b"Suggested logo_threshold:   %.4f\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            logo_quality,
        );
        Debug(
            1 as libc::c_int,
            b"Suggested shrink_logo:\t    %.2f\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            logo_overshoot,
        );
        Debug(
            1 as libc::c_int,
            b"Max commercial size found:  %6i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            max_nonlogo_block_length,
        );
        Debug(
            1 as libc::c_int,
            b"Dominant aspect ratio:      %.4f\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            dominant_ar,
        );
        Debug(
            1 as libc::c_int,
            b"Score threshold:            %.4f\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            threshold,
        );
        Debug(
            1 as libc::c_int,
            b"Framerate:                  %2.3f\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            fps,
        );
        Debug(
            1 as libc::c_int,
            b"Average framerate:          %2.3f\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            avg_fps,
        );
        Debug(
            1 as libc::c_int,
            b"Total commercial length:    %s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            dblSecondsToStrMinutes(comlength),
        );
        Debug(
            1 as libc::c_int,
            b"Cut codes:\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        Debug(
            1 as libc::c_int,
            b"  F: scene\t c: change\n  A: aspect\t t: cutscene\n  E: exceeds\t l: logo\n  L: logo\t v: volume\n  B: bright\t s: scene_change\n  C: combined\t a: aspect_ratio\n  N: nonstrict\t u: uniform_frame\n  S: strict\t b: black_frame\n  \t\t r: resolution\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        Debug(
            1 as libc::c_int,
            b"----------------------------------------------------\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        Debug(
            1 as libc::c_int,
            b"Block list after weighing\n----------------------------------------------------\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
            threshold,
        );
        Debug(
            1 as libc::c_int,
            b"  #     sbf  bs  be     fs     fe        ts        te       len     sc   scr cmb   ar                   cut    bri logo   vol sil   corr stdev   cc\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count {
            Debug(
                1 as libc::c_int,
                b"%3i:%c%c %4i %3i %3i %6i %6i %8.2fs %8.2fs %8.2fs %6.2f %5.2f %3i %4.2f %s %4i%c %4.2f %4i%c %2i%c %6.3f %5i %-10s\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
                CheckFramesForCommercial(
                    (cblock[i as usize].f_start
                        + cblock[i as usize].b_head as libc::c_long) as libc::c_int,
                    (cblock[i as usize].f_end
                        - cblock[i as usize].b_tail as libc::c_long) as libc::c_int,
                ) as libc::c_int,
                CheckFramesForReffer(
                    (cblock[i as usize].f_start
                        + cblock[i as usize].b_head as libc::c_long) as libc::c_int,
                    (cblock[i as usize].f_end
                        - cblock[i as usize].b_tail as libc::c_long) as libc::c_int,
                ) as libc::c_int,
                cblock[i as usize].bframe_count,
                cblock[i as usize].b_head,
                cblock[i as usize].b_tail,
                cblock[i as usize].f_start,
                cblock[i as usize].f_end,
                get_frame_pts(cblock[i as usize].f_start as libc::c_int),
                get_frame_pts(cblock[i as usize].f_end as libc::c_int),
                cblock[i as usize].length,
                cblock[i as usize].score,
                cblock[i as usize].schange_rate,
                cblock[i as usize].combined_count,
                cblock[i as usize].ar_ratio,
                CauseString(cblock[i as usize].cause),
                cblock[i as usize].brightness,
                CompareLetter(
                    cblock[i as usize].brightness,
                    avg_brightness as libc::c_int,
                    i,
                ) as libc::c_int,
                cblock[i as usize].logo,
                cblock[i as usize].volume,
                CompareLetter(cblock[i as usize].volume, avg_volume as libc::c_int, i)
                    as libc::c_int,
                cblock[i as usize].silence,
                CompareLetter(cblock[i as usize].silence, avg_silence as libc::c_int, i)
                    as libc::c_int,
                0.0f64,
                cblock[i as usize].stdev,
                CCTypeToStr(cblock[i as usize].cc_type),
            );
            if commDetectMethod & 2 as libc::c_int != 0 {
                Debug(
                    1 as libc::c_int,
                    b"\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            } else {
                Debug(
                    1 as libc::c_int,
                    b"\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            i += 1;
        }
        OutputAspect();
        OutputTraining();
    }
    return foundCommercials;
}
#[no_mangle]
pub unsafe extern "C" fn OutputStrict(
    mut len: libc::c_double,
    mut delta: libc::c_double,
    mut tol: libc::c_double,
) {
    if output_training != 0 && training_file.is_null() {
        training_file = myfopen(
            b"strict.csv\0" as *const u8 as *const libc::c_char,
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if !training_file.is_null() {
        fprintf(
            training_file,
            b"%+f,%+f,%+f, %s\n\0" as *const u8 as *const libc::c_char,
            len,
            delta,
            tol,
            inbasename.as_mut_ptr(),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn OutputTraining() {
    let mut i: libc::c_int = 0;
    if output_training == 0 {
        return;
    }
    training_file = myfopen(
        b"comskip.csv\0" as *const u8 as *const libc::c_char,
        b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    fprintf(
        training_file,
        b"block, cm,rf, score, length, start, end, fromend ar, logo, cause, less, more\n\0"
            as *const u8 as *const libc::c_char,
    );
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        if output_training != 0 {
            fprintf(
                training_file,
                b"%3d,%c,%c,%7.2f,%7.2f,%7.2f,%7.2f,%7.2f,%5.2f,%5.2f,\"%10s\",\"%10s\",\"%10s\",\"%s\"\n\0"
                    as *const u8 as *const libc::c_char,
                i,
                CheckFramesForCommercial(
                    (cblock[i as usize].f_start
                        + cblock[i as usize].b_head as libc::c_long) as libc::c_int,
                    (cblock[i as usize].f_end
                        - cblock[i as usize].b_tail as libc::c_long) as libc::c_int,
                ) as libc::c_int,
                CheckFramesForReffer(
                    (cblock[i as usize].f_start
                        + cblock[i as usize].b_head as libc::c_long) as libc::c_int,
                    (cblock[i as usize].f_end
                        - cblock[i as usize].b_tail as libc::c_long) as libc::c_int,
                ) as libc::c_int,
                cblock[i as usize].score,
                cblock[i as usize].length,
                if !frame.is_null() {
                    if cblock[i as usize].f_start <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else if cblock[i as usize].f_start >= framenum_real as libc::c_long
                        {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[i as usize].f_start as isize)).pts
                    }
                } else {
                    cblock[i as usize].f_start as libc::c_double / fps
                },
                if !frame.is_null() {
                    if cblock[i as usize].f_end <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else if cblock[i as usize].f_end >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[i as usize].f_end as isize)).pts
                    }
                } else {
                    cblock[i as usize].f_end as libc::c_double / fps
                },
                (if !frame.is_null() {
                    (if cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize]
                        .f_end <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[(block_count - 1 as libc::c_int as libc::c_long)
                                as usize]
                            .f_end >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                .pts
                        } else {
                            (*frame
                                .offset(
                                    cblock[(block_count - 1 as libc::c_int as libc::c_long)
                                            as usize]
                                        .f_end as isize,
                                ))
                                .pts
                        })
                    })
                } else {
                    cblock[(block_count - 1 as libc::c_int as libc::c_long) as usize]
                        .f_end as libc::c_double / fps
                })
                    - (if !frame.is_null() {
                        (if cblock[i as usize].f_end <= 0 as libc::c_int as libc::c_long
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if cblock[i as usize].f_end >= framenum_real as libc::c_long
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                    .pts
                            } else {
                                (*frame.offset(cblock[i as usize].f_end as isize)).pts
                            })
                        })
                    } else {
                        cblock[i as usize].f_end as libc::c_double / fps
                    }),
                cblock[i as usize].ar_ratio,
                cblock[i as usize].logo,
                CauseString(cblock[i as usize].cause),
                CauseString(cblock[i as usize].less),
                CauseString(cblock[i as usize].more),
                inbasename.as_mut_ptr(),
            );
        }
        i += 1;
    }
}
static mut MPEG2SysHdr: [libc::c_uchar; 24] = [
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0x1 as libc::c_int as libc::c_uchar,
    0xbb as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0x12 as libc::c_int as libc::c_uchar,
    0x80 as libc::c_int as libc::c_uchar,
    0x8e as libc::c_int as libc::c_uchar,
    0xd3 as libc::c_int as libc::c_uchar,
    0x4 as libc::c_int as libc::c_uchar,
    0xe1 as libc::c_int as libc::c_uchar,
    0x7f as libc::c_int as libc::c_uchar,
    0xb9 as libc::c_int as libc::c_uchar,
    0xe0 as libc::c_int as libc::c_uchar,
    0xe0 as libc::c_int as libc::c_uchar,
    0xb8 as libc::c_int as libc::c_uchar,
    0xc0 as libc::c_int as libc::c_uchar,
    0x54 as libc::c_int as libc::c_uchar,
    0xbd as libc::c_int as libc::c_uchar,
    0xe0 as libc::c_int as libc::c_uchar,
    0x3a as libc::c_int as libc::c_uchar,
    0xbf as libc::c_int as libc::c_uchar,
    0xe0 as libc::c_int as libc::c_uchar,
    0x2 as libc::c_int as libc::c_uchar,
];
#[no_mangle]
pub unsafe extern "C" fn OutputCleanMpg() -> bool {
    let mut inf: libc::c_int = 0;
    let mut outf: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut startpos: int64_t = 0 as libc::c_int as int64_t;
    let mut endpos: int64_t = 0 as libc::c_int as int64_t;
    let mut begin: int64_t = 0 as libc::c_int as int64_t;
    let mut len: libc::c_int = 0;
    let mut prevperc: libc::c_int = 0;
    let mut curperc: libc::c_int = 0;
    let mut Buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut infile: *mut FILE = 0 as *mut FILE;
    let mut firstbl: bool = 1 as libc::c_int != 0;
    if outputdirname[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
        return 1 as libc::c_int != 0;
    }
    Buf = malloc(((1 as libc::c_int) << 22 as libc::c_int) as libc::c_ulong) as *mut libc::c_char;
    if Buf.is_null() {
        return 0 as libc::c_int != 0;
    }
    outf = open(
        outputdirname.as_mut_ptr(),
        0x200 as libc::c_int | 0x400 as libc::c_int | 0x1 as libc::c_int,
        0o400 as libc::c_int | 0o200 as libc::c_int,
    );
    if outf < 0 as libc::c_int {
        return 0 as libc::c_int != 0;
    }
    infile = myfopen(
        mpegfilename.as_mut_ptr(),
        b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    inf = fileno(infile);
    startpos = (*frame.offset(1 as libc::c_int as isize)).goppos;
    c = 0 as libc::c_int;
    while c <= commercial_count {
        endpos = (*frame.offset(commercial[c as usize].start_frame as isize)).goppos;
        fseeko(infile, startpos, 0 as libc::c_int);
        begin = startpos;
        prevperc = 0 as libc::c_int;
        while startpos < endpos {
            len = (endpos as libc::c_int as libc::c_longlong - startpos) as libc::c_int;
            if len > (1 as libc::c_int) << 22 as libc::c_int {
                len = (1 as libc::c_int) << 22 as libc::c_int;
            }
            i = read(inf, Buf as *mut libc::c_void, len as libc::c_uint as size_t) as libc::c_int;
            if i <= 0 as libc::c_int {
                return 0 as libc::c_int != 0;
            }
            j = 0 as libc::c_int;
            if firstbl {
                firstbl = 0 as libc::c_int != 0;
                j = 14 as libc::c_int
                    + (*Buf.offset(13 as libc::c_int as isize) as libc::c_int & 7 as libc::c_int);
                if *(Buf.offset(j as isize) as *mut uint32_t) == 0xbb010000 as libc::c_uint {
                    j = 0 as libc::c_int;
                } else {
                    write(outf, Buf as *const libc::c_void, j as size_t);
                    write(
                        outf,
                        MPEG2SysHdr.as_mut_ptr() as *const libc::c_void,
                        ::std::mem::size_of::<[libc::c_uchar; 24]>() as libc::c_ulong,
                    );
                }
            }
            if write(
                outf,
                Buf.offset(j as isize) as *const libc::c_void,
                (i - j) as size_t,
            ) <= 0 as libc::c_int as libc::c_long
            {
                return 0 as libc::c_int != 0;
            }
            if i != len {
                return 0 as libc::c_int != 0;
            }
            startpos += len as libc::c_longlong;
            curperc = ((startpos - begin) * 100 as libc::c_int as libc::c_longlong
                / (endpos - begin)) as libc::c_int;
            if curperc != prevperc {
                prevperc = curperc;
            }
        }
        startpos = (*frame.offset(commercial[c as usize].end_frame as isize)).goppos;
        c += 1;
    }
    close(outf);
    free(Buf as *mut libc::c_void);
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn LengthWithinTolerance(
    mut test_length: libc::c_double,
    mut expected_length: libc::c_double,
    mut tolerance: libc::c_double,
) -> bool {
    return abs((test_length * fps) as libc::c_int - (expected_length * fps) as libc::c_int)
        <= (tolerance * fps) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn IsStandardCommercialLength(
    mut length: libc::c_double,
    mut tolerance: libc::c_double,
    mut strict: bool,
) -> bool {
    let mut i: libc::c_int = 0;
    let mut local_tolerance: libc::c_double = 0.;
    let mut length_count: libc::c_int = 0;
    let mut delta: libc::c_double = 0.;
    let mut standard_length: [libc::c_int; 17] = [
        10 as libc::c_int,
        15 as libc::c_int,
        20 as libc::c_int,
        25 as libc::c_int,
        30 as libc::c_int,
        45 as libc::c_int,
        60 as libc::c_int,
        90 as libc::c_int,
        120 as libc::c_int,
        150 as libc::c_int,
        180 as libc::c_int,
        35 as libc::c_int,
        40 as libc::c_int,
        50 as libc::c_int,
        70 as libc::c_int,
        75 as libc::c_int,
        105 as libc::c_int,
    ];
    if strict {
        length_count = 11 as libc::c_int;
    } else {
        length_count = 17 as libc::c_int;
    }
    if div5_tolerance >= 0 as libc::c_int as libc::c_double {
        local_tolerance = div5_tolerance;
    } else {
        local_tolerance = tolerance;
    }
    if local_tolerance < 0.5f64 {
        local_tolerance = 0.5f64;
    }
    if local_tolerance > 1.0f64 {
        local_tolerance = 1.0f64;
    }
    length += 0.11f64;
    i = 0 as libc::c_int;
    while i < length_count {
        if (standard_length[i as usize] as libc::c_double)
            < min_show_segment_length - 3 as libc::c_int as libc::c_double
        {
            if LengthWithinTolerance(
                length,
                standard_length[i as usize] as libc::c_double,
                local_tolerance,
            ) {
                delta = length - standard_length[i as usize] as libc::c_double;
                OutputStrict(length, delta, local_tolerance);
                return 1 as libc::c_int != 0;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn FindNumber(
    mut str1: *mut libc::c_char,
    mut str2: *mut libc::c_char,
    mut v: libc::c_double,
) -> libc::c_double {
    let mut tmp: [libc::c_char; 255] = [0; 255];
    let mut negative: bool = 0 as libc::c_int != 0;
    let mut i: libc::c_int = 0;
    let mut res: libc::c_double = -(1 as libc::c_int) as libc::c_double;
    if str1.is_null() {
        return -(1 as libc::c_int) as libc::c_double;
    }
    str1 = strstr(str1, str2);
    if !str1.is_null() {
        str1 = str1.offset(strlen(str2) as isize);
        while isspace(*str1 as libc::c_int) != 0 {
            str1 = str1.offset(1);
        }
        if *str1 as libc::c_int == '-' as i32 {
            str1 = str1.offset(1);
            negative = 1 as libc::c_int != 0;
        }
        res = if negative as libc::c_int != 0 {
            -atof(str1)
        } else {
            atof(str1)
        };
        sprintf(
            tmp.as_mut_ptr(),
            b"%s%0f\n\0" as *const u8 as *const libc::c_char,
            str2,
            res,
        );
    } else {
        sprintf(
            tmp.as_mut_ptr(),
            b"%s%0f\n\0" as *const u8 as *const libc::c_char,
            str2,
            v,
        );
    }
    i = strlen(tmp.as_mut_ptr()) as libc::c_int;
    while i >= 2 as libc::c_int && tmp[(i - 2 as libc::c_int) as usize] as libc::c_int == '0' as i32
    {
        tmp[(i - 1 as libc::c_int) as usize] = 0 as libc::c_int as libc::c_char;
        let fresh57 = i;
        i = i - 1;
        tmp[(fresh57 - 2 as libc::c_int) as usize] = '\n' as i32 as libc::c_char;
    }
    if i >= 2 as libc::c_int && tmp[(i - 2 as libc::c_int) as usize] as libc::c_int == '.' as i32 {
        tmp[(i - 1 as libc::c_int) as usize] = 0 as libc::c_int as libc::c_char;
        let fresh58 = i;
        i = i - 1;
        tmp[(fresh58 - 2 as libc::c_int) as usize] = '\n' as i32 as libc::c_char;
    }
    AddIniString(tmp.as_mut_ptr());
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn FindString(
    mut str1: *mut libc::c_char,
    mut str2: *mut libc::c_char,
    mut v: *mut libc::c_char,
) -> *mut libc::c_char {
    static mut foundText: [libc::c_char; 1024] = [0; 1024];
    let mut tmp: [libc::c_char; 255] = [0; 255];
    let mut t: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut found: libc::c_int = 0 as libc::c_int;
    if str1.is_null() {
        return 0 as *mut libc::c_char;
    }
    str1 = strstr(str1, str2);
    if !str1.is_null() {
        str1 = str1.offset(strlen(str2) as isize);
        while isspace(*str1 as libc::c_int) != 0 {
            str1 = str1.offset(1);
        }
        if *str1 as libc::c_int == '"' as i32 {
            t = foundText.as_mut_ptr();
            str1 = str1.offset(1);
            while *str1 as libc::c_int != '"' as i32
                && *str1 as libc::c_int != 0 as libc::c_int
                && *str1 as libc::c_int != 10 as libc::c_int
            {
                if *str1 as libc::c_int == '\\' as i32 {
                    str1 = str1.offset(1);
                    if *str1 as libc::c_int == 'n' as i32 {
                        *str1 = '\n' as i32 as libc::c_char;
                    }
                }
                let fresh59 = str1;
                str1 = str1.offset(1);
                let fresh60 = t;
                t = t.offset(1);
                *fresh60 = *fresh59;
            }
            let fresh61 = t;
            t = t.offset(1);
            *fresh61 = 0 as libc::c_int as libc::c_char;
            v = foundText.as_mut_ptr();
            found = 1 as libc::c_int;
            sprintf(
                tmp.as_mut_ptr(),
                b"%s\"%s\"\n\0" as *const u8 as *const libc::c_char,
                str2,
                foundText.as_mut_ptr(),
            );
        } else {
            Debug(
                1 as libc::c_int,
                b"String parameter for %s must be enclosed in double quotes\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                str2,
            );
        }
    } else {
        return 0 as *mut libc::c_char;
    }
    t = tmp.as_mut_ptr();
    while *str2 != 0 {
        let fresh62 = str2;
        str2 = str2.offset(1);
        let fresh63 = t;
        t = t.offset(1);
        *fresh63 = *fresh62;
    }
    let fresh64 = t;
    t = t.offset(1);
    *fresh64 = '"' as i32 as libc::c_char;
    while *v != 0 {
        match *v as libc::c_int {
            34 | 92 => {
                let fresh65 = t;
                t = t.offset(1);
                *fresh65 = '\\' as i32 as libc::c_char;
                let fresh66 = v;
                v = v.offset(1);
                let fresh67 = t;
                t = t.offset(1);
                *fresh67 = *fresh66;
            }
            10 => {
                let fresh68 = t;
                t = t.offset(1);
                *fresh68 = '\\' as i32 as libc::c_char;
                let fresh69 = t;
                t = t.offset(1);
                *fresh69 = 'n' as i32 as libc::c_char;
                v = v.offset(1);
            }
            9 => {
                let fresh70 = t;
                t = t.offset(1);
                *fresh70 = '\\' as i32 as libc::c_char;
                let fresh71 = t;
                t = t.offset(1);
                *fresh71 = 't' as i32 as libc::c_char;
                v = v.offset(1);
            }
            _ => {
                let fresh72 = v;
                v = v.offset(1);
                let fresh73 = t;
                t = t.offset(1);
                *fresh73 = *fresh72;
            }
        }
    }
    let fresh74 = t;
    t = t.offset(1);
    *fresh74 = '"' as i32 as libc::c_char;
    let fresh75 = t;
    t = t.offset(1);
    *fresh75 = '\n' as i32 as libc::c_char;
    let fresh76 = t;
    t = t.offset(1);
    *fresh76 = 0 as libc::c_int as libc::c_char;
    AddIniString(tmp.as_mut_ptr());
    if found != 0 {
        return foundText.as_mut_ptr();
    } else {
        return 0 as *mut libc::c_char;
    };
}
#[no_mangle]
pub unsafe extern "C" fn AddIniString(mut s: *mut libc::c_char) {
    strcat(ini_text.as_mut_ptr(), s);
}
#[no_mangle]
pub unsafe extern "C" fn intSecondsToStrMinutes(mut seconds: libc::c_int) -> *mut libc::c_char {
    let mut minutes: libc::c_int = 0;
    let mut hours: libc::c_int = 0;
    hours = seconds / 3600 as libc::c_int;
    seconds -= hours * 60 as libc::c_int * 60 as libc::c_int;
    minutes = seconds / 60 as libc::c_int;
    seconds -= minutes * 60 as libc::c_int;
    sprintf(
        tempString.as_mut_ptr(),
        b"%i:%.2i:%.2i\0" as *const u8 as *const libc::c_char,
        hours,
        minutes,
        seconds,
    );
    return tempString.as_mut_ptr();
}
#[no_mangle]
pub unsafe extern "C" fn dblSecondsToStrMinutes(mut seconds: libc::c_double) -> *mut libc::c_char {
    let mut minutes: libc::c_int = 0;
    let mut hours: libc::c_int = 0;
    hours = (seconds / 3600 as libc::c_int as libc::c_double) as libc::c_int;
    seconds -= (hours * 60 as libc::c_int * 60 as libc::c_int) as libc::c_double;
    minutes = (seconds / 60 as libc::c_int as libc::c_double) as libc::c_int;
    seconds -= (minutes * 60 as libc::c_int) as libc::c_double;
    sprintf(
        tempString.as_mut_ptr(),
        b"%0i:%.2i:%.2d.%.2d\0" as *const u8 as *const libc::c_char,
        hours,
        minutes,
        seconds as libc::c_int,
        ((seconds - seconds as libc::c_int as libc::c_double)
            * 100 as libc::c_int as libc::c_double) as libc::c_int,
    );
    return tempString.as_mut_ptr();
}
#[no_mangle]
pub unsafe extern "C" fn dblSecondsToStrMinutesFrames(
    mut seconds: libc::c_double,
) -> *mut libc::c_char {
    let mut minutes: libc::c_int = 0;
    let mut hours: libc::c_int = 0;
    hours = (seconds / 3600 as libc::c_int as libc::c_double) as libc::c_int;
    seconds -= (hours * 60 as libc::c_int * 60 as libc::c_int) as libc::c_double;
    minutes = (seconds / 60 as libc::c_int as libc::c_double) as libc::c_int;
    seconds -= (minutes * 60 as libc::c_int) as libc::c_double;
    sprintf(
        tempString.as_mut_ptr(),
        b"%0i:%.2i:%.2d.%.2d\0" as *const u8 as *const libc::c_char,
        hours,
        minutes,
        seconds as libc::c_int,
        (((seconds - seconds as libc::c_int as libc::c_double) * 100.0f64) as libc::c_int
            as libc::c_double
            * fps
            / 100.0f64) as libc::c_int,
    );
    return tempString.as_mut_ptr();
}
#[no_mangle]
pub unsafe extern "C" fn LoadIniFile() {
    let mut data: [libc::c_char; 60000] = [0; 60000];
    let mut ts: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0 as libc::c_int as size_t;
    let mut tmp: libc::c_double = 0.;
    ini_text[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    if ini_file.is_null() {
        printf(
            b"No INI file found in current directory.  Searching PATH...\n\0" as *const u8
                as *const libc::c_char,
        );
        FindIniFile();
        if *inifilename.as_mut_ptr() as libc::c_int != '\0' as i32 {
            printf(
                b"INI file found at %s\n\0" as *const u8 as *const libc::c_char,
                inifilename.as_mut_ptr(),
            );
            ini_file = myfopen(
                inifilename.as_mut_ptr(),
                b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
        } else {
            printf(b"No INI file found in PATH...\n\0" as *const u8 as *const libc::c_char);
        }
    }
    if !ini_file.is_null() {
        printf(
            b"Using %s for initiation values.\n\0" as *const u8 as *const libc::c_char,
            inifilename.as_mut_ptr(),
        );
        len = fread(
            data.as_mut_ptr() as *mut libc::c_void,
            1 as libc::c_int as libc::c_ulong,
            59999 as libc::c_int as libc::c_ulong,
            ini_file,
        );
        fclose(ini_file);
        data[len as usize] = '\0' as i32 as libc::c_char;
        ini_text[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        AddIniString(
            b"[Main Settings]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        AddIniString(
            b";the sum of the values for which kind of frames comskip will consider as possible cutpoints: 1=uniform (black or any other color) frame, 2=logo, 4=scene change, 8=resolution change, 16=closed captions, 32=aspect ration, 64=silence, 255=all.\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"detect_method=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            commDetectMethod as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            commDetectMethod = tmp as libc::c_int;
        }
        AddIniString(
            b";Set to 10 to show a lot of extra info, level 5 is also OK, set to 0 to disable\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"verbose=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            verbose as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            verbose = tmp as libc::c_int;
        }
        AddIniString(
            b";Frame not black if any of the pixels of the frame has a brightness greater than this (scale 0 to 255)\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"max_brightness=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            max_brightness as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            max_brightness = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"maxbright=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            maxbright as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            maxbright = tmp as libc::c_int;
        }
        AddIniString(
            b";Frame not pure black if a small number of the pixels of the frame has a brightness greater than this. To decide if the frame is truly black, comskip will also check average brightness (scale 0 to 255)\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"test_brightness=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            test_brightness as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            test_brightness = tmp as libc::c_int;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"max_avg_brightness=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            max_avg_brightness as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            max_avg_brightness = tmp as libc::c_int;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"max_commercialbreak=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            max_commercialbreak,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            max_commercialbreak = tmp as libc::c_int as libc::c_double;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"min_commercialbreak=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            min_commercialbreak,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            min_commercialbreak = tmp as libc::c_int as libc::c_double;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"max_commercial_size=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            max_commercial_size,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            max_commercial_size = tmp as libc::c_int as libc::c_double;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"min_commercial_size=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            min_commercial_size,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            min_commercial_size = tmp as libc::c_int as libc::c_double;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"min_show_segment_length=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            min_show_segment_length,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            min_show_segment_length = tmp;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"max_volume=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            max_volume as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            max_volume = tmp as libc::c_int;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"max_silence=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            max_silence as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            max_silence = tmp as libc::c_int;
        }
        AddIniString(b";\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"non_uniformity=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            non_uniformity as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            non_uniformity = tmp as libc::c_int;
        }
        AddIniString(
            b"[Detailed Settings]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"min_silence=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            min_silence as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            min_silence = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"remove_silent_segments=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            remove_silent_segments as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            remove_silent_segments = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"noise_level=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            noise_level as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            noise_level = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"brightness_jump=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            brightness_jump as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            brightness_jump = (tmp != 0.) as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"fps=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            fps,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            fps = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"validate_silence=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            validate_silence as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            validate_silence = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"validate_uniform=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            validate_uniform as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            validate_uniform = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"validate_scenechange=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            validate_scenechange as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            validate_scenechange = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"global_threshold=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            global_threshold,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            global_threshold = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"disable_heuristics=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            disable_heuristics as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            disable_heuristics = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"cut_on_ac_change=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            cut_on_ac_change as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            cut_on_ac_change = tmp as libc::c_int;
        }
        AddIniString(
            b"[CPU Load Reduction]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"thread_count=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            thread_count as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            thread_count = tmp as libc::c_int;
        }
        if hardware_decode == 0 {
            tmp = FindNumber(
                data.as_mut_ptr(),
                b"hardware_decode=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                hardware_decode as libc::c_double,
            );
            if tmp > -(1 as libc::c_int) as libc::c_double {
                hardware_decode = tmp as libc::c_int;
            }
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"play_nice_start=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            play_nice_start as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            play_nice_start = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"play_nice_end=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            play_nice_end as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            play_nice_end = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"play_nice_sleep=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            play_nice_sleep as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            play_nice_sleep = tmp as libc::c_long;
        }
        AddIniString(
            b"[Input Correction]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"max_repair_size=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            max_repair_size as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            max_repair_size = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ms_audio_delay=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ms_audio_delay as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ms_audio_delay = -(tmp as libc::c_int);
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"volume_slip=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            volume_slip as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            volume_slip = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"lowres=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            lowres as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            lowres = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"skip_b_frames=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            skip_B_frames as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            skip_B_frames = tmp as libc::c_int;
        }
        AddIniString(
            b"[Aspect Ratio]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ar_delta=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ar_delta,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ar_delta = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"cut_on_ar_change=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            cut_on_ar_change as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            cut_on_ar_change = tmp as libc::c_int;
        }
        AddIniString(
            b"[Global Removes]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"padding=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            padding as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            padding = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"remove_before=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            remove_before as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            remove_before = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"remove_after=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            remove_after as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            remove_after = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"added_recording=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            added_recording as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            added_recording = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"delete_show_after_last_commercial=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            delete_show_after_last_commercial as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            delete_show_after_last_commercial = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"delete_show_before_first_commercial=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            delete_show_before_first_commercial as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            delete_show_before_first_commercial = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"delete_show_before_or_after_current=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            delete_show_before_or_after_current as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            delete_show_before_or_after_current = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"delete_block_after_commercial=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            delete_block_after_commercial as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            delete_block_after_commercial = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"min_commercial_break_at_start_or_end=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            min_commercial_break_at_start_or_end as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            min_commercial_break_at_start_or_end = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"always_keep_first_seconds=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            always_keep_first_seconds as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            always_keep_first_seconds = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"always_keep_last_seconds=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            always_keep_last_seconds as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            always_keep_last_seconds = tmp as libc::c_int;
        }
        AddIniString(
            b"[USA Specific]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"intelligent_brightness=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if intelligent_brightness { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            intelligent_brightness = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"black_percentile=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            black_percentile,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            black_percentile = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"uniform_percentile=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            uniform_percentile,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            uniform_percentile = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"score_percentile=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            score_percentile,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            score_percentile = tmp;
        }
        AddIniString(
            b"[Main Scoring]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"length_strict_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            length_strict_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            length_strict_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"length_nonstrict_modifier=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            length_nonstrict_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            length_nonstrict_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"combined_length_strict_modifier=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            combined_length_strict_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            combined_length_strict_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"combined_length_nonstrict_modifier=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            combined_length_nonstrict_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            combined_length_nonstrict_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ar_wrong_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ar_wrong_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ar_wrong_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ac_wrong_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ac_wrong_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ac_wrong_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"excessive_length_modifier=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            excessive_length_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            excessive_length_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"dark_block_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            dark_block_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            dark_block_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"min_schange_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            min_schange_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            min_schange_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"max_schange_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            max_schange_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            max_schange_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_present_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            logo_present_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_present_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"punish_no_logo=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            punish_no_logo as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            punish_no_logo = tmp as libc::c_int;
        }
        AddIniString(
            b"[Detailed Scoring]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"punish=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            punish as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            punish = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"reward=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            reward as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            reward = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"punish_threshold=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            punish_threshold,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            punish_threshold = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"punish_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            punish_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            punish_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"reward_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            reward_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            reward_modifier = tmp;
        }
        AddIniString(
            b"[Logo Finding]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"border=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            border as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            border = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"give_up_logo_search=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            giveUpOnLogoSearch as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            giveUpOnLogoSearch = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"delay_logo_search=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            delay_logo_search as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            delay_logo_search = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_max_percentage_of_screen=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            logo_max_percentage_of_screen,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_max_percentage_of_screen = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_min_percentage_of_screen=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            logo_min_percentage_of_screen,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_min_percentage_of_screen = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ticker_tape=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ticker_tape as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ticker_tape = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ticker_tape_percentage=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ticker_tape_percentage as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ticker_tape_percentage = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ignore_side=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ignore_side as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ignore_side = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ignore_left_side=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ignore_left_side as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ignore_left_side = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ignore_right_side=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ignore_right_side as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ignore_right_side = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"subtitles=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            subtitles as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            subtitles = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_at_bottom=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            logo_at_bottom as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_at_bottom = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_threshold=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            logo_threshold,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_threshold = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_percentage_threshold=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            logo_percentage_threshold,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_percentage_threshold = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_filter=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            logo_filter as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_filter = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"aggressive_logo_rejection=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            aggressive_logo_rejection as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            aggressive_logo_rejection = (tmp != 0.) as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"edge_level_threshold=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            edge_level_threshold as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            edge_level_threshold = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"edge_radius=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            edge_radius as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            edge_radius = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"edge_weight=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            edge_weight as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            edge_weight = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"edge_step=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            edge_step as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            edge_step = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"num_logo_buffers=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            num_logo_buffers as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            num_logo_buffers = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"use_existing_logo_file=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if useExistingLogoFile { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            useExistingLogoFile = tmp as libc::c_int != 0;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"two_pass_logo=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if startOverAfterLogoInfoAvail {
                1.0
            } else {
                0.0
            },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            startOverAfterLogoInfoAvail = tmp != 0.;
        }
        AddIniString(
            b"[Logo Interpretation]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"connect_blocks_with_logo=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if connect_blocks_with_logo { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            connect_blocks_with_logo = tmp as libc::c_int != 0;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_percentile=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            logo_percentile,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_percentile = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logo_fraction=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            logo_fraction,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            logo_fraction = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"shrink_logo=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            shrink_logo,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            shrink_logo = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"shrink_logo_tail=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            shrink_logo_tail as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            shrink_logo_tail = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"before_logo=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            before_logo as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            before_logo = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"after_logo=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            after_logo as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            after_logo = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"where_logo=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            where_logo as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            where_logo = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"min_black_frames_for_break=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            min_black_frames_for_break as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            min_black_frames_for_break = tmp as libc::c_uint;
        }
        AddIniString(
            b"[Closed Captioning]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"ccCheck=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if ccCheck { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            ccCheck = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"cc_commercial_type_modifier=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            cc_commercial_type_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            cc_commercial_type_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"cc_wrong_type_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            cc_wrong_type_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            cc_wrong_type_modifier = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"cc_correct_type_modifier=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            cc_correct_type_modifier,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            cc_correct_type_modifier = tmp;
        }
        AddIniString(b"[Live TV]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char);
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"live_tv=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if live_tv { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            live_tv = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"live_tv_retries=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            live_tv_retries as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            live_tv_retries = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"require_div5=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if require_div5 { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            require_div5 = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"div5_tolerance=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            div5_tolerance,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            div5_tolerance = tmp;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"incommercial_frames=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            incommercial_frames as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            incommercial_frames = tmp as libc::c_int;
        }
        AddIniString(
            b"[Output Control]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_default=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_default { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_default = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_chapters=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_chapters { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_chapters = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_plist_cutlist=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_plist_cutlist { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_plist_cutlist = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_zoomplayer_cutlist=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            if output_zoomplayer_cutlist { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_zoomplayer_cutlist = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_zoomplayer_chapter=\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            if output_zoomplayer_chapter { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_zoomplayer_chapter = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_scf=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_scf { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_scf = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_vcf=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_vcf { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_vcf = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_vdr=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_vdr { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_vdr = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_projectx=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_projectx { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_projectx = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_avisynth=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_avisynth { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_avisynth = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_videoredo=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_videoredo { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_videoredo = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_videoredo3=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_videoredo3 { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            if tmp != 0. {
                output_videoredo3 = tmp != 0.;
            }
            if output_videoredo3 {
                output_videoredo = 0 as libc::c_int != 0;
            }
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"videoredo_offset=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            videoredo_offset as libc::c_double,
        );
        if tmp != -(1 as libc::c_int) as libc::c_double {
            videoredo_offset = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_btv=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_btv { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_btv = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_edl=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_edl { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_edl = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_live=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_live { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_live = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"edl_offset=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            edl_offset as libc::c_double,
        );
        if tmp != -(1 as libc::c_int) as libc::c_double {
            edl_offset = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"timeline_repair=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            timeline_repair as libc::c_double,
        );
        if tmp != -(1 as libc::c_int) as libc::c_double {
            timeline_repair = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"edl_skip_field=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            edl_skip_field as libc::c_double,
        );
        if tmp != -(1 as libc::c_int) as libc::c_double {
            edl_skip_field = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_edlp=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_edlp { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_edlp = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_bsplayer=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_bsplayer { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_bsplayer = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_edlx=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_edlx { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_edlx = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_cuttermaran=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_cuttermaran { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_cuttermaran = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_mpeg2schnitt=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_mpeg2schnitt { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_mpeg2schnitt = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_womble=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_womble { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_womble = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_mls=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_mls { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_mls = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_mpgtx=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_mpgtx { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_mpgtx = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_dvrmstb=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_dvrmstb { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_dvrmstb = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_dvrcut=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_dvrcut { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_dvrcut = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_ipodchap=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_ipodchap { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_ipodchap = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_framearray=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_framearray { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_framearray = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_debugwindow=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_debugwindow { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_debugwindow = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_tuning=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_tuning { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_tuning = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_training=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            output_training as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_training = (tmp != 0.) as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_false=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_false { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_false = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_aspect=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_aspect { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_aspect = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_demux=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_demux { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_demux = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_data=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_data { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_data = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_srt=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_srt { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_srt = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_smi=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_smi { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_smi = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_timing=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_timing { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_timing = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_incommercial=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_incommercial { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_incommercial = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_ffmeta=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_ffmeta { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_ffmeta = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_ffsplit=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if output_ffsplit { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_ffsplit = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"delete_logo_file=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if deleteLogoFile { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            deleteLogoFile = tmp as libc::c_int != 0;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"output_mkvtoolnix=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            output_mkvtoolnix as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            output_mkvtoolnix = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"cutscene_frame=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            cutsceneno as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            cutsceneno = tmp as libc::c_int;
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscene_dumpfile=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile.as_mut_ptr(), ts);
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"cutscene_threshold=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            cutscenedelta as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            cutscenedelta = tmp as libc::c_int;
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscenefile1=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile1.as_mut_ptr(), ts);
        }
        if cutscenefile1[0 as libc::c_int as usize] != 0 {
            LoadCutScene(cutscenefile1.as_mut_ptr());
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscenefile2=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile2.as_mut_ptr(), ts);
        }
        if cutscenefile2[0 as libc::c_int as usize] != 0 {
            LoadCutScene(cutscenefile2.as_mut_ptr());
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscenefile3=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile3.as_mut_ptr(), ts);
        }
        if cutscenefile3[0 as libc::c_int as usize] != 0 {
            LoadCutScene(cutscenefile3.as_mut_ptr());
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscenefile4=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile4.as_mut_ptr(), ts);
        }
        if cutscenefile4[0 as libc::c_int as usize] != 0 {
            LoadCutScene(cutscenefile4.as_mut_ptr());
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscenefile5=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile5.as_mut_ptr(), ts);
        }
        if cutscenefile5[0 as libc::c_int as usize] != 0 {
            LoadCutScene(cutscenefile5.as_mut_ptr());
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscenefile6=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile6.as_mut_ptr(), ts);
        }
        if cutscenefile6[0 as libc::c_int as usize] != 0 {
            LoadCutScene(cutscenefile6.as_mut_ptr());
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscenefile7=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile7.as_mut_ptr(), ts);
        }
        if cutscenefile7[0 as libc::c_int as usize] != 0 {
            LoadCutScene(cutscenefile7.as_mut_ptr());
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cutscenefile8=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if !ts.is_null() {
            strcpy(cutscenefile8.as_mut_ptr(), ts);
        }
        if cutscenefile8[0 as libc::c_int as usize] != 0 {
            LoadCutScene(cutscenefile8.as_mut_ptr());
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"windowtitle=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            windowtitle.as_mut_ptr(),
        );
        if !ts.is_null() {
            strcpy(windowtitle.as_mut_ptr(), ts);
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"cuttermaran_options=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            cuttermaran_options.as_mut_ptr(),
        );
        if !ts.is_null() {
            strcpy(cuttermaran_options.as_mut_ptr(), ts);
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"mpeg2schnitt_options=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            mpeg2schnitt_options.as_mut_ptr(),
        );
        if !ts.is_null() {
            strcpy(mpeg2schnitt_options.as_mut_ptr(), ts);
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"avisynth_options=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            avisynth_options.as_mut_ptr(),
        );
        if !ts.is_null() {
            strcpy(avisynth_options.as_mut_ptr(), ts);
        }
        ts = FindString(
            data.as_mut_ptr(),
            b"dvrcut_options=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            dvrcut_options.as_mut_ptr(),
        );
        if !ts.is_null() {
            strcpy(dvrcut_options.as_mut_ptr(), ts);
        }
        AddIniString(
            b"[Sage Workarounds]\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"sage_framenumber_bug=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if sage_framenumber_bug { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            sage_framenumber_bug = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"sage_minute_bug=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if sage_minute_bug { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            sage_minute_bug = tmp != 0.;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"enable_mencoder_pts=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            if enable_mencoder_pts { 1.0 } else { 0.0 },
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            enable_mencoder_pts = tmp != 0.;
        }
    } else {
        printf(b"No INI file found anywhere!!!!\n\0" as *const u8 as *const libc::c_char);
    }
    if added_recording > 0 as libc::c_int
        && giveUpOnLogoSearch < added_recording * 60 as libc::c_int
    {
        giveUpOnLogoSearch += added_recording * 60 as libc::c_int;
    }
}
#[no_mangle]
pub unsafe extern "C" fn LoadSettings(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> *mut FILE {
    let mut tempstr: [libc::c_char; 4096] = [0; 4096];
    let mut logo_file: *mut FILE = 0 as *mut FILE;
    let mut log_file_0: *mut FILE = 0 as *mut FILE;
    let mut test_file: *mut FILE = 0 as *mut FILE;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut ltime: time_t = 0;
    let mut now: *mut tm = 0 as *mut tm;
    let mut mil_time: libc::c_int = 0;
    let mut cl_playnice: *mut arg_lit = arg_lit0(
        b"n\0" as *const u8 as *const libc::c_char,
        b"playnice\0" as *const u8 as *const libc::c_char,
        b"Slows detection down\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_output_zp_cutlist: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"zpcut\0" as *const u8 as *const libc::c_char,
        b"Outputs a ZoomPlayer cutlist\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_output_zp_chapter: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"zpchapter\0" as *const u8 as *const libc::c_char,
        b"Outputs a ZoomPlayer chapter file\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_output_scf: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"scf\0" as *const u8 as *const libc::c_char,
        b"Outputs a simple chapter file for mkvmerge\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_output_vredo: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"videoredo\0" as *const u8 as *const libc::c_char,
        b"Outputs a VideoRedo cutlist\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_output_vredo3: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"videoredo3\0" as *const u8 as *const libc::c_char,
        b"Outputs a VideoRedo3 cutlist\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_output_csv: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"csvout\0" as *const u8 as *const libc::c_char,
        b"Outputs a csv of the frame array\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_output_training: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"quality\0" as *const u8 as *const libc::c_char,
        b"Outputs a csv of false detection segments\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_output_plist: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"plist\0" as *const u8 as *const libc::c_char,
        b"Outputs a mac-style plist for addition to an EyeTV archive as the 'markers' property\0"
            as *const u8 as *const libc::c_char,
    );
    let mut cl_detectmethod: *mut arg_int = arg_intn(
        b"d\0" as *const u8 as *const libc::c_char,
        b"detectmethod\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"An integer sum of the detection methods to use\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_pid: *mut arg_str = arg_strn(
        b"p\0" as *const u8 as *const libc::c_char,
        b"pid\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"The PID of the video in the TS\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_dump: *mut arg_int = arg_intn(
        b"u\0" as *const u8 as *const libc::c_char,
        b"dump\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"Dump the cutscene at this frame number\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_ts: *mut arg_lit = arg_lit0(
        b"t\0" as *const u8 as *const libc::c_char,
        b"ts\0" as *const u8 as *const libc::c_char,
        b"The input file is a Transport Stream\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_help: *mut arg_lit = arg_lit0(
        b"h\0" as *const u8 as *const libc::c_char,
        b"help\0" as *const u8 as *const libc::c_char,
        b"Display syntax\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_show: *mut arg_lit = arg_lit0(
        b"s\0" as *const u8 as *const libc::c_char,
        b"play\0" as *const u8 as *const libc::c_char,
        b"Play the video\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_timing: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"timing\0" as *const u8 as *const libc::c_char,
        b"Dump the timing into a file\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_debugwindow: *mut arg_lit = arg_lit0(
        b"w\0" as *const u8 as *const libc::c_char,
        b"debugwindow\0" as *const u8 as *const libc::c_char,
        b"Show debug window\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_quiet: *mut arg_lit = arg_lit0(
        b"q\0" as *const u8 as *const libc::c_char,
        b"quiet\0" as *const u8 as *const libc::c_char,
        b"Not output logging to the console window\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_demux: *mut arg_lit = arg_lit0(
        b"m\0" as *const u8 as *const libc::c_char,
        b"demux\0" as *const u8 as *const libc::c_char,
        b"Demux the input into elementary streams\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_hwassist: *mut arg_lit = arg_lit0(
        0 as *const libc::c_char,
        b"hwassist\0" as *const u8 as *const libc::c_char,
        b"Activate Hardware Assisted video decoding\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_threads: *mut arg_int = arg_int0(
        0 as *const libc::c_char,
        b"threads\0" as *const u8 as *const libc::c_char,
        b"<int>\0" as *const u8 as *const libc::c_char,
        b"The number of threads to use\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_verbose: *mut arg_int = arg_intn(
        b"v\0" as *const u8 as *const libc::c_char,
        b"verbose\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"Verbose level\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_ini: *mut arg_file = arg_filen(
        0 as *const libc::c_char,
        b"ini\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"Ini file to use\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_logo: *mut arg_file = arg_filen(
        0 as *const libc::c_char,
        b"logo\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"Logo file to use\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_cut: *mut arg_file = arg_filen(
        0 as *const libc::c_char,
        b"cut\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"CutScene file to use\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_work: *mut arg_file = arg_filen(
        0 as *const libc::c_char,
        b"output\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"Folder to use for all output files\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_work_fname: *mut arg_file = arg_filen(
        0 as *const libc::c_char,
        b"output-filename\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"Filename base to use for all output files\0" as *const u8 as *const libc::c_char,
    );
    let mut cl_selftest: *mut arg_int = arg_intn(
        0 as *const libc::c_char,
        b"selftest\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"Execute a selftest\0" as *const u8 as *const libc::c_char,
    );
    let mut in_0: *mut arg_file = arg_filen(
        0 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int,
        b"Input file\0" as *const u8 as *const libc::c_char,
    );
    let mut out: *mut arg_file = arg_filen(
        0 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        1 as libc::c_int,
        b"Output folder for cutlist\0" as *const u8 as *const libc::c_char,
    );
    let mut end: *mut arg_end = arg_end(20 as libc::c_int);
    let mut argtable: [*mut libc::c_void; 31] = [
        cl_help as *mut libc::c_void,
        cl_debugwindow as *mut libc::c_void,
        cl_playnice as *mut libc::c_void,
        cl_output_zp_cutlist as *mut libc::c_void,
        cl_output_zp_chapter as *mut libc::c_void,
        cl_output_scf as *mut libc::c_void,
        cl_output_vredo as *mut libc::c_void,
        cl_output_vredo3 as *mut libc::c_void,
        cl_output_csv as *mut libc::c_void,
        cl_output_training as *mut libc::c_void,
        cl_output_plist as *mut libc::c_void,
        cl_demux as *mut libc::c_void,
        cl_hwassist as *mut libc::c_void,
        cl_threads as *mut libc::c_void,
        cl_pid as *mut libc::c_void,
        cl_ts as *mut libc::c_void,
        cl_detectmethod as *mut libc::c_void,
        cl_verbose as *mut libc::c_void,
        cl_dump as *mut libc::c_void,
        cl_show as *mut libc::c_void,
        cl_timing as *mut libc::c_void,
        cl_quiet as *mut libc::c_void,
        cl_ini as *mut libc::c_void,
        cl_logo as *mut libc::c_void,
        cl_cut as *mut libc::c_void,
        cl_work as *mut libc::c_void,
        cl_work_fname as *mut libc::c_void,
        cl_selftest as *mut libc::c_void,
        in_0 as *mut libc::c_void,
        out as *mut libc::c_void,
        end as *mut libc::c_void,
    ];
    let mut nerrors: libc::c_int = 0;
    incomingCommandLine[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    if !(strchr(*argv.offset(0 as libc::c_int as isize), ' ' as i32)).is_null() {
        sprintf(
            incomingCommandLine.as_mut_ptr(),
            b"\"%s\"\0" as *const u8 as *const libc::c_char,
            *argv.offset(0 as libc::c_int as isize),
        );
    } else {
        sprintf(
            incomingCommandLine.as_mut_ptr(),
            b"%s\0" as *const u8 as *const libc::c_char,
            *argv.offset(0 as libc::c_int as isize),
        );
    }
    i = 1 as libc::c_int;
    while i < argc {
        sprintf(
            tempstr.as_mut_ptr(),
            b"%s\0" as *const u8 as *const libc::c_char,
            incomingCommandLine.as_mut_ptr(),
        );
        if !(strchr(*argv.offset(i as isize), ' ' as i32)).is_null() {
            sprintf(
                incomingCommandLine.as_mut_ptr(),
                b"%s \"%s\"\0" as *const u8 as *const libc::c_char,
                tempstr.as_mut_ptr(),
                *argv.offset(i as isize),
            );
        } else {
            sprintf(
                incomingCommandLine.as_mut_ptr(),
                b"%s %s\0" as *const u8 as *const libc::c_char,
                tempstr.as_mut_ptr(),
                *argv.offset(i as isize),
            );
        }
        i += 1;
    }
    printf(
        b"The commandline used was:\n%s\n\n\0" as *const u8 as *const libc::c_char,
        incomingCommandLine.as_mut_ptr(),
    );
    argument = malloc(
        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
            .wrapping_mul(argc as libc::c_ulong),
    ) as *mut *mut libc::c_char;
    argument_count = argc;
    i = 0 as libc::c_int;
    while i < argc {
        let ref mut fresh77 = *argument.offset(i as isize);
        *fresh77 = malloc(
            (::std::mem::size_of::<libc::c_char>() as libc::c_ulong).wrapping_mul(
                (strlen(*argv.offset(i as isize))).wrapping_add(1 as libc::c_int as libc::c_ulong),
            ),
        ) as *mut libc::c_char;
        strcpy(*argument.offset(i as isize), *argv.offset(i as isize));
        i += 1;
    }
    if argc <= 1 as libc::c_int {
        if !(strstr(
            *argv.offset(0 as libc::c_int as isize),
            b"GUI\0" as *const u8 as *const libc::c_char,
        ))
        .is_null()
        {
            output_debugwindow = 1 as libc::c_int != 0;
        }
        output_debugwindow;
    }
    if arg_nullcheck(argtable.as_mut_ptr()) != 0 as libc::c_int {
        Debug(
            0 as libc::c_int,
            b"%s: insufficient memory\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            progname,
        );
    } else {
        nerrors = arg_parse(argc, argv, argtable.as_mut_ptr());
        if (*cl_help).count != 0 {
            printf(b"Usage:\n  comskip \0" as *const u8 as *const libc::c_char);
            arg_print_syntaxv(
                __stdoutp,
                argtable.as_mut_ptr(),
                b"\n\n\0" as *const u8 as *const libc::c_char,
            );
            arg_print_glossary(
                __stdoutp,
                argtable.as_mut_ptr(),
                b"  %-25s %s\n\0" as *const u8 as *const libc::c_char,
            );
            printf(b"\nDetection Methods\n\0" as *const u8 as *const libc::c_char);
            printf(
                b"\t%3i - Black Frame\n\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
            );
            printf(
                b"\t%3i - Logo\n\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
            );
            printf(
                b"\t%3i - Scene Change\n\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int,
            );
            printf(
                b"\t%3i - Resolution Change\n\0" as *const u8 as *const libc::c_char,
                8 as libc::c_int,
            );
            printf(
                b"\t%3i - Closed Captions\n\0" as *const u8 as *const libc::c_char,
                16 as libc::c_int,
            );
            printf(
                b"\t%3i - Aspect Ratio\n\0" as *const u8 as *const libc::c_char,
                32 as libc::c_int,
            );
            printf(
                b"\t%3i - Silence\n\0" as *const u8 as *const libc::c_char,
                64 as libc::c_int,
            );
            printf(
                b"\t%3i - CutScenes\n\0" as *const u8 as *const libc::c_char,
                128 as libc::c_int,
            );
            printf(b"\t255 - USE ALL AVAILABLE\n\0" as *const u8 as *const libc::c_char);
            exit(2 as libc::c_int);
        }
        if nerrors != 0 {
            printf(b"Usage:\n  comskip \0" as *const u8 as *const libc::c_char);
            arg_print_syntaxv(
                __stdoutp,
                argtable.as_mut_ptr(),
                b"\n\n\0" as *const u8 as *const libc::c_char,
            );
            arg_print_glossary(
                __stdoutp,
                argtable.as_mut_ptr(),
                b"  %-25s %s\n\0" as *const u8 as *const libc::c_char,
            );
            printf(b"\nDetection methods available:\n\0" as *const u8 as *const libc::c_char);
            printf(
                b"\t%3i - Black Frame\n\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
            );
            printf(
                b"\t%3i - Logo\n\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
            );
            printf(
                b"\t%3i - Scene Change\n\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int,
            );
            printf(
                b"\t%3i - Resolution Change\n\0" as *const u8 as *const libc::c_char,
                8 as libc::c_int,
            );
            printf(
                b"\t%3i - Closed Captions\n\0" as *const u8 as *const libc::c_char,
                16 as libc::c_int,
            );
            printf(
                b"\t%3i - Aspect Ratio\n\0" as *const u8 as *const libc::c_char,
                32 as libc::c_int,
            );
            printf(
                b"\t%3i - Silence\n\0" as *const u8 as *const libc::c_char,
                64 as libc::c_int,
            );
            printf(
                b"\t%3i - CutScenes\n\0" as *const u8 as *const libc::c_char,
                128 as libc::c_int,
            );
            printf(b"\t255 - USE ALL AVAILABLE\n\0" as *const u8 as *const libc::c_char);
            printf(b"\nErrors:\n\0" as *const u8 as *const libc::c_char);
            arg_print_errors(
                __stdoutp,
                end,
                b"ComSkip\0" as *const u8 as *const libc::c_char,
            );
            exit(2 as libc::c_int);
        }
        if strcmp(
            *((*in_0).extension).offset(0 as libc::c_int as isize),
            b".csv\0" as *const u8 as *const libc::c_char,
        ) != 0 as libc::c_int
            && strcmp(
                *((*in_0).extension).offset(0 as libc::c_int as isize),
                b".txt\0" as *const u8 as *const libc::c_char,
            ) != 0 as libc::c_int
        {
            sprintf(
                mpegfilename.as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                *((*in_0).filename).offset(0 as libc::c_int as isize),
            );
            sprintf(
                inbasename.as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                strlen(*((*in_0).filename).offset(0 as libc::c_int as isize)) as libc::c_int
                    - strlen(*((*in_0).extension).offset(0 as libc::c_int as isize)) as libc::c_int,
                *((*in_0).filename).offset(0 as libc::c_int as isize),
            );
            i = strlen(inbasename.as_mut_ptr()) as libc::c_int;
            while i > 0 as libc::c_int
                && inbasename[(i - 1 as libc::c_int) as usize] as libc::c_int != '/' as i32
            {
                i -= 1;
            }
            strcpy(
                shortbasename.as_mut_ptr(),
                &mut *inbasename.as_mut_ptr().offset(i as isize),
            );
            sprintf(
                inifilename.as_mut_ptr(),
                b"%.*scomskip.ini\0" as *const u8 as *const libc::c_char,
                i,
                inbasename.as_mut_ptr(),
            );
        } else if strcmp(
            *((*in_0).extension).offset(0 as libc::c_int as isize),
            b".csv\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
        {
            loadingCSV = 1 as libc::c_int != 0;
            in_file = myfopen(
                *((*in_0).filename).offset(0 as libc::c_int as isize),
                b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            printf(
                b"Opening %s array file.\n\0" as *const u8 as *const libc::c_char,
                *((*in_0).filename).offset(0 as libc::c_int as isize),
            );
            if in_file.is_null() {
                fprintf(
                    __stderrp,
                    b"%s - could not open file %s\n\0" as *const u8 as *const libc::c_char,
                    strerror(*__error()),
                    *((*in_0).filename).offset(0 as libc::c_int as isize),
                );
                exit(4 as libc::c_int);
            }
            sprintf(
                inbasename.as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                strlen(*((*in_0).filename).offset(0 as libc::c_int as isize)) as libc::c_int
                    - strlen(*((*in_0).extension).offset(0 as libc::c_int as isize)) as libc::c_int,
                *((*in_0).filename).offset(0 as libc::c_int as isize),
            );
            sprintf(
                mpegfilename.as_mut_ptr(),
                b"%.*s.mpg\0" as *const u8 as *const libc::c_char,
                strlen(inbasename.as_mut_ptr()) as libc::c_int,
                inbasename.as_mut_ptr(),
            );
            test_file = myfopen(
                mpegfilename.as_mut_ptr(),
                b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.ts\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.tp\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.dvr-ms\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.wtv\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.mp4\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.mkv\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                mpegfilename[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            } else {
                fclose(test_file);
            }
            i = strlen(inbasename.as_mut_ptr()) as libc::c_int;
            while i > 0 as libc::c_int
                && inbasename[(i - 1 as libc::c_int) as usize] as libc::c_int != '/' as i32
            {
                i -= 1;
            }
            strcpy(
                shortbasename.as_mut_ptr(),
                &mut *inbasename.as_mut_ptr().offset(i as isize),
            );
            sprintf(
                inifilename.as_mut_ptr(),
                b"%.*scomskip.ini\0" as *const u8 as *const libc::c_char,
                i,
                inbasename.as_mut_ptr(),
            );
            if mpegfilename[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%s.mpg\0" as *const u8 as *const libc::c_char,
                    inbasename.as_mut_ptr(),
                );
            }
        } else if strcmp(
            *((*in_0).extension).offset(0 as libc::c_int as isize),
            b".txt\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
        {
            loadingTXT = 1 as libc::c_int != 0;
            output_default = 0 as libc::c_int != 0;
            in_file = myfopen(
                *((*in_0).filename).offset(0 as libc::c_int as isize),
                b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            printf(
                b"Opening %s for review\n\0" as *const u8 as *const libc::c_char,
                *((*in_0).filename).offset(0 as libc::c_int as isize),
            );
            if in_file.is_null() {
                fprintf(
                    __stderrp,
                    b"%s - could not open file %s\n\0" as *const u8 as *const libc::c_char,
                    strerror(*__error()),
                    *((*in_0).filename).offset(0 as libc::c_int as isize),
                );
                exit(4 as libc::c_int);
            }
            fclose(in_file);
            in_file = 0 as *mut FILE;
            sprintf(
                inbasename.as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                strlen(*((*in_0).filename).offset(0 as libc::c_int as isize)) as libc::c_int
                    - strlen(*((*in_0).extension).offset(0 as libc::c_int as isize)) as libc::c_int,
                *((*in_0).filename).offset(0 as libc::c_int as isize),
            );
            sprintf(
                mpegfilename.as_mut_ptr(),
                b"%.*s.mpg\0" as *const u8 as *const libc::c_char,
                strlen(inbasename.as_mut_ptr()) as libc::c_int,
                inbasename.as_mut_ptr(),
            );
            test_file = myfopen(
                mpegfilename.as_mut_ptr(),
                b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.ts\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.tp\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.dvr-ms\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.wtv\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.mp4\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                sprintf(
                    mpegfilename.as_mut_ptr(),
                    b"%.*s.mkv\0" as *const u8 as *const libc::c_char,
                    strlen(inbasename.as_mut_ptr()) as libc::c_int,
                    inbasename.as_mut_ptr(),
                );
                test_file = myfopen(
                    mpegfilename.as_mut_ptr(),
                    b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            if test_file.is_null() {
                mpegfilename[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            } else {
                fclose(test_file);
            }
            i = strlen(inbasename.as_mut_ptr()) as libc::c_int;
            while i > 0 as libc::c_int
                && inbasename[(i - 1 as libc::c_int) as usize] as libc::c_int != '/' as i32
            {
                i -= 1;
            }
            strcpy(
                shortbasename.as_mut_ptr(),
                &mut *inbasename.as_mut_ptr().offset(i as isize),
            );
            sprintf(
                inifilename.as_mut_ptr(),
                b"%.*scomskip.ini\0" as *const u8 as *const libc::c_char,
                i,
                inbasename.as_mut_ptr(),
            );
        } else {
            printf(
                b"The input file was not a Video file or comskip CSV or TXT file - %s.\n\0"
                    as *const u8 as *const libc::c_char,
                *((*in_0).extension).offset(0 as libc::c_int as isize),
            );
            exit(5 as libc::c_int);
        }
        if (*cl_ini).count != 0 {
            sprintf(
                inifilename.as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                *((*cl_ini).filename).offset(0 as libc::c_int as isize),
            );
            printf(
                b"Setting ini file to %s as per commandline\n\0" as *const u8
                    as *const libc::c_char,
                inifilename.as_mut_ptr(),
            );
        }
        ini_file = myfopen(
            inifilename.as_mut_ptr(),
            b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if (*cl_work_fname).count != 0 {
            sprintf(
                shortbasename.as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                *((*cl_work_fname).filename).offset(0 as libc::c_int as isize),
            );
        }
        if (*cl_work).count != 0 {
            sprintf(
                outputdirname.as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                *((*cl_work).filename).offset(0 as libc::c_int as isize),
            );
            i = strlen(outputdirname.as_mut_ptr()) as libc::c_int;
            if outputdirname[(i - 1 as libc::c_int) as usize] as libc::c_int == '/' as i32 {
                outputdirname[(i - 1 as libc::c_int) as usize] = 0 as libc::c_int as libc::c_char;
            }
            sprintf(
                workbasename.as_mut_ptr(),
                b"%s%c%s\0" as *const u8 as *const libc::c_char,
                outputdirname.as_mut_ptr(),
                '/' as i32,
                shortbasename.as_mut_ptr(),
            );
            strcpy(outbasename.as_mut_ptr(), workbasename.as_mut_ptr());
        } else {
            outputdirname[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            strcpy(workbasename.as_mut_ptr(), inbasename.as_mut_ptr());
        }
        if (*out).count != 0 {
            sprintf(
                outputdirname.as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                *((*out).filename).offset(0 as libc::c_int as isize),
            );
            i = strlen(outputdirname.as_mut_ptr()) as libc::c_int;
            if outputdirname[(i - 1 as libc::c_int) as usize] as libc::c_int == '/' as i32 {
                outputdirname[(i - 1 as libc::c_int) as usize] = 0 as libc::c_int as libc::c_char;
            }
            sprintf(
                outbasename.as_mut_ptr(),
                b"%s%c%s\0" as *const u8 as *const libc::c_char,
                outputdirname.as_mut_ptr(),
                '/' as i32,
                shortbasename.as_mut_ptr(),
            );
        } else {
            outputdirname[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            strcpy(outbasename.as_mut_ptr(), inbasename.as_mut_ptr());
        }
        if (*cl_work).count != 0 && (*out).count == 0 {
            strcpy(outbasename.as_mut_ptr(), workbasename.as_mut_ptr());
        }
        sprintf(
            logofilename.as_mut_ptr(),
            b"%s.logo.txt\0" as *const u8 as *const libc::c_char,
            workbasename.as_mut_ptr(),
        );
        sprintf(
            logfilename.as_mut_ptr(),
            b"%s.log\0" as *const u8 as *const libc::c_char,
            workbasename.as_mut_ptr(),
        );
        sprintf(
            filename.as_mut_ptr(),
            b"%s.txt\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        if strcmp(
            HomeDir.as_mut_ptr(),
            b".\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
        {
            if ini_file.is_null() {
                sprintf(
                    inifilename.as_mut_ptr(),
                    b"comskip.ini\0" as *const u8 as *const libc::c_char,
                );
                ini_file = myfopen(
                    inifilename.as_mut_ptr(),
                    b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            sprintf(
                exefilename.as_mut_ptr(),
                b"comskip.exe\0" as *const u8 as *const libc::c_char,
            );
            sprintf(
                dictfilename.as_mut_ptr(),
                b"comskip.dictionary\0" as *const u8 as *const libc::c_char,
            );
        } else {
            if ini_file.is_null() {
                sprintf(
                    inifilename.as_mut_ptr(),
                    b"%s%ccomskip.ini\0" as *const u8 as *const libc::c_char,
                    HomeDir.as_mut_ptr(),
                    '/' as i32,
                );
                ini_file = myfopen(
                    inifilename.as_mut_ptr(),
                    b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            sprintf(
                exefilename.as_mut_ptr(),
                b"%s%ccomskip.exe\0" as *const u8 as *const libc::c_char,
                HomeDir.as_mut_ptr(),
                '/' as i32,
            );
            sprintf(
                dictfilename.as_mut_ptr(),
                b"%s%ccomskip.dictionary\0" as *const u8 as *const libc::c_char,
                HomeDir.as_mut_ptr(),
                '/' as i32,
            );
        }
        if (*cl_cut).count != 0 {
            printf(
                b"Loading cutfile %s as per commandline\n\0" as *const u8 as *const libc::c_char,
                *((*cl_cut).filename).offset(0 as libc::c_int as isize),
            );
            LoadCutScene(*((*cl_cut).filename).offset(0 as libc::c_int as isize));
        }
        if (*cl_logo).count != 0 {
            sprintf(
                logofilename.as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                *((*cl_logo).filename).offset(0 as libc::c_int as isize),
            );
            printf(
                b"Setting logo file to %s as per commandline\n\0" as *const u8
                    as *const libc::c_char,
                logofilename.as_mut_ptr(),
            );
        }
        LoadIniFile();
        time(&mut ltime);
        now = localtime(&mut ltime);
        mil_time = (*now).tm_hour * 100 as libc::c_int + (*now).tm_min;
        if play_nice_start > -(1 as libc::c_int) && play_nice_end > -(1 as libc::c_int) {
            if play_nice_start > play_nice_end {
                if mil_time >= play_nice_start || mil_time <= play_nice_end {
                    play_nice = 1 as libc::c_int != 0;
                }
            } else if mil_time >= play_nice_start && mil_time <= play_nice_end {
                play_nice = 1 as libc::c_int != 0;
            }
        }
        if (*cl_verbose).count != 0 {
            verbose = *((*cl_verbose).ival).offset(0 as libc::c_int as isize);
            printf(
                b"Setting verbose level to %i as per command line.\n\0" as *const u8
                    as *const libc::c_char,
                verbose,
            );
        }
        if (*cl_selftest).count != 0 {
            selftest = *((*cl_selftest).ival).offset(0 as libc::c_int as isize);
            printf(
                b"Setting selftest to %i as per command line.\n\0" as *const u8
                    as *const libc::c_char,
                selftest,
            );
        }
        if (*cl_debugwindow).count != 0 || loadingTXT as libc::c_int != 0 {
            output_debugwindow = 1 as libc::c_int != 0;
        }
        if (*cl_timing).count != 0 {
            output_timing = 1 as libc::c_int != 0;
        }
        if (*cl_show).count != 0 {
            subsample_video = 0 as libc::c_int;
            output_debugwindow = 1 as libc::c_int != 0;
        }
        if (*cl_quiet).count != 0 {
            output_console = 0 as libc::c_int != 0;
        }
        if !(strstr(
            *argv.offset(0 as libc::c_int as isize),
            b"GUI\0" as *const u8 as *const libc::c_char,
        ))
        .is_null()
            || !(strstr(
                *argv.offset(0 as libc::c_int as isize),
                b"-gui\0" as *const u8 as *const libc::c_char,
            ))
            .is_null()
        {
            output_debugwindow = 1 as libc::c_int != 0;
        }
        if (*cl_demux).count != 0 {
            output_demux = 1 as libc::c_int != 0;
        }
        if (*cl_hwassist).count != 0 {
            hardware_decode = 1 as libc::c_int;
        }
        if (*cl_threads).count != 0 {
            thread_count = *((*cl_threads).ival).offset(0 as libc::c_int as isize);
        }
        if !loadingTXT && !useExistingLogoFile && (*cl_logo).count == 0 as libc::c_int {
            logo_file = myfopen(
                logofilename.as_mut_ptr(),
                b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if !logo_file.is_null() {
                fclose(logo_file);
                myremove(logofilename.as_mut_ptr());
            }
        }
        if (*cl_output_csv).count != 0 {
            output_framearray = 1 as libc::c_int != 0;
        }
        if (*cl_output_training).count != 0 {
            output_training = 1 as libc::c_int;
        }
        if verbose != 0 {
            logo_file = myfopen(
                logofilename.as_mut_ptr(),
                b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if loadingTXT {
                verbose = 0 as libc::c_int;
            } else if loadingCSV {
                log_file_0 = myfopen(
                    logfilename.as_mut_ptr(),
                    b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if !log_file_0.is_null() {
                    fprintf(
                        log_file_0,
                        b"################################################################\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    fprintf(
                        log_file_0,
                        b"Generated using %s %s\n\0" as *const u8 as *const libc::c_char,
                        b"donator\0" as *const u8 as *const libc::c_char,
                        b"Comskip 0.82.005\0" as *const u8 as *const libc::c_char,
                    );
                    fprintf(
                        log_file_0,
                        b"Loading comskip csv file - %s\n\0" as *const u8 as *const libc::c_char,
                        *((*in_0).filename).offset(0 as libc::c_int as isize),
                    );
                    fprintf(
                        log_file_0,
                        b"Time at start of run:\n%s\0" as *const u8 as *const libc::c_char,
                        ctime(&mut ltime),
                    );
                    fprintf(
                        log_file_0,
                        b"################################################################\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    fclose(log_file_0);
                }
                log_file_0 = 0 as *mut FILE;
            } else if !logo_file.is_null() {
                fclose(logo_file);
                log_file_0 = myfopen(
                    logfilename.as_mut_ptr(),
                    b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if !log_file_0.is_null() {
                    fprintf(
                        log_file_0,
                        b"################################################################\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    fprintf(
                        log_file_0,
                        b"Starting second pass using %s\n\0" as *const u8 as *const libc::c_char,
                        logofilename.as_mut_ptr(),
                    );
                    fprintf(
                        log_file_0,
                        b"Time at start of second run:\n%s\0" as *const u8 as *const libc::c_char,
                        ctime(&mut ltime),
                    );
                    fprintf(
                        log_file_0,
                        b"################################################################\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    fclose(log_file_0);
                }
                log_file_0 = 0 as *mut FILE;
            } else {
                log_file_0 = myfopen(
                    logfilename.as_mut_ptr(),
                    b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if !log_file_0.is_null() {
                    fprintf(
                        log_file_0,
                        b"################################################################\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    fprintf(
                        log_file_0,
                        b"Generated using %s %s\n\0" as *const u8 as *const libc::c_char,
                        b"donator\0" as *const u8 as *const libc::c_char,
                        b"Comskip 0.82.005\0" as *const u8 as *const libc::c_char,
                    );
                    fprintf(
                        log_file_0,
                        b"Time at start of run:\n%s\0" as *const u8 as *const libc::c_char,
                        ctime(&mut ltime),
                    );
                    fprintf(
                        log_file_0,
                        b"################################################################\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    fclose(log_file_0);
                }
                log_file_0 = 0 as *mut FILE;
            }
        }
        if (*cl_playnice).count != 0 {
            play_nice = 1 as libc::c_int != 0;
            Debug(
                1 as libc::c_int,
                b"ComSkip playing nice due as per command line.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
        }
        if (*cl_detectmethod).count != 0 {
            commDetectMethod = *((*cl_detectmethod).ival).offset(0 as libc::c_int as isize);
            printf(
                b"Setting detection methods to %i as per command line.\n\0" as *const u8
                    as *const libc::c_char,
                commDetectMethod,
            );
        }
        if (*cl_dump).count != 0 {
            cutsceneno = *((*cl_dump).ival).offset(0 as libc::c_int as isize);
            printf(
                b"Setting dump frame number to %i as per command line.\n\0" as *const u8
                    as *const libc::c_char,
                cutsceneno,
            );
        }
        if (*cl_ts).count != 0 {
            demux_pid = 1 as libc::c_int;
            printf(b"Auto selecting the PID.\n\0" as *const u8 as *const libc::c_char);
        }
        if (*cl_pid).count != 0 {
            sscanf(
                *((*cl_pid).sval).offset(0 as libc::c_int as isize),
                b"%x\0" as *const u8 as *const libc::c_char,
                &mut demux_pid as *mut libc::c_int,
            );
            printf(
                b"Selecting PID %x as per command line.\n\0" as *const u8 as *const libc::c_char,
                demux_pid,
            );
        }
        Debug(
            9 as libc::c_int,
            b"Mpeg:\t%s\nExe\t%s\nLogo:\t%s\nIni:\t%s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            mpegfilename.as_mut_ptr(),
            exefilename.as_mut_ptr(),
            logofilename.as_mut_ptr(),
            inifilename.as_mut_ptr(),
        );
        Debug(
            1 as libc::c_int,
            b"\nDetection Methods to be used:\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        i = 0 as libc::c_int;
        if commDetectMethod & 1 as libc::c_int != 0 {
            i += 1;
            Debug(
                1 as libc::c_int,
                b"\t%i) Black Frame\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
            );
        }
        if commDetectMethod & 2 as libc::c_int != 0 {
            i += 1;
            Debug(
                1 as libc::c_int,
                b"\t%i) Logo - Give up after %i seconds\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
                giveUpOnLogoSearch,
            );
        }
        commDetectMethod & 128 as libc::c_int != 0;
        if commDetectMethod & 4 as libc::c_int != 0 {
            i += 1;
            Debug(
                1 as libc::c_int,
                b"\t%i) Scene Change\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
            );
        }
        if commDetectMethod & 8 as libc::c_int != 0 {
            i += 1;
            Debug(
                1 as libc::c_int,
                b"\t%i) Resolution Change\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
            );
        }
        if commDetectMethod & 16 as libc::c_int != 0 {
            i += 1;
            processCC = 1 as libc::c_int != 0;
            Debug(
                1 as libc::c_int,
                b"\t%i) Closed Captions\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                i,
            );
        }
        if commDetectMethod & 32 as libc::c_int != 0 {
            i += 1;
            Debug(
                1 as libc::c_int,
                b"\t%i) Aspect Ratio\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
            );
        }
        if commDetectMethod & 64 as libc::c_int != 0 {
            i += 1;
            Debug(
                1 as libc::c_int,
                b"\t%i) Silence\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
            );
        }
        if commDetectMethod & 128 as libc::c_int != 0 {
            i += 1;
            Debug(
                1 as libc::c_int,
                b"\t%i) CutScenes\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
            );
        }
        Debug(
            1 as libc::c_int,
            b"\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if play_nice_start != 0 || play_nice_end != 0 {
            Debug(
                1 as libc::c_int,
                b"\nComSkip throttles back from %.4i to %.4i.\nThe time is now %.4i \0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                play_nice_start,
                play_nice_end,
                mil_time,
            );
            if play_nice {
                Debug(
                    1 as libc::c_int,
                    b"so comskip is running slowly.\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
            } else {
                Debug(
                    1 as libc::c_int,
                    b"so it's full speed ahead!\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
            }
        }
        Debug(
            10 as libc::c_int,
            b"\nSettings\n--------\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        Debug(
            10 as libc::c_int,
            b"%s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            ini_text.as_mut_ptr(),
        );
        sprintf(
            out_filename.as_mut_ptr(),
            b"%s.txt\0" as *const u8 as *const libc::c_char,
            outbasename.as_mut_ptr(),
        );
        if !loadingTXT {
            logo_file = myfopen(
                logofilename.as_mut_ptr(),
                b"r+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if !logo_file.is_null() {
                Debug(
                    1 as libc::c_int,
                    b"The logo mask file exists.\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                );
                fclose(logo_file);
                LoadLogoMaskData();
            }
        }
        training_file = 0 as *mut FILE;
        tuning_file = training_file;
        dvrmstb_file = tuning_file;
        dvrcut_file = dvrmstb_file;
        mpgtx_file = dvrcut_file;
        womble_file = mpgtx_file;
        mls_file = womble_file;
        edlx_file = mls_file;
        edlp_file = edlx_file;
        ipodchap_file = edlp_file;
        live_file = ipodchap_file;
        ffsplit_file = live_file;
        ffmeta_file = ffsplit_file;
        edl_file = ffmeta_file;
        btv_file = edl_file;
        videoredo3_file = btv_file;
        videoredo_file = videoredo3_file;
        cuttermaran_file = videoredo_file;
        avisynth_file = cuttermaran_file;
        projectx_file = avisynth_file;
        scf_file = projectx_file;
        vdr_file = scf_file;
        vcf_file = vdr_file;
        zoomplayer_chapter_file = vcf_file;
        zoomplayer_cutlist_file = zoomplayer_chapter_file;
        plist_cutlist_file = zoomplayer_cutlist_file;
        out_file = plist_cutlist_file;
        if (*cl_output_plist).count != 0 {
            output_plist_cutlist = 1 as libc::c_int != 0;
        }
        if (*cl_output_zp_cutlist).count != 0 {
            output_zoomplayer_cutlist = 1 as libc::c_int != 0;
        }
        if (*cl_output_zp_chapter).count != 0 {
            output_zoomplayer_chapter = 1 as libc::c_int != 0;
        }
        if (*cl_output_scf).count != 0 {
            output_scf = 1 as libc::c_int != 0;
        }
        if (*cl_output_vredo).count != 0 {
            output_videoredo = 1 as libc::c_int != 0;
        }
        if (*cl_output_vredo3).count != 0 {
            output_videoredo3 = 1 as libc::c_int != 0;
            output_videoredo = 0 as libc::c_int != 0;
        }
        if (*cl_output_plist).count != 0 {
            output_plist_cutlist = 1 as libc::c_int != 0;
        }
        if output_default as libc::c_int != 0 && !loadingTXT {
            if !isSecondPass {
                out_file = myfopen(
                    out_filename.as_mut_ptr(),
                    b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if out_file.is_null() {
                    fprintf(
                        __stderrp,
                        b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                        strerror(*__error()),
                        filename.as_mut_ptr(),
                    );
                    exit(6 as libc::c_int);
                } else {
                    output_default = 1 as libc::c_int != 0;
                    fclose(out_file);
                }
            }
        }
        if loadingTXT {
            frame_count = InputReffer(
                b".txt\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                1 as libc::c_int,
            ) as libc::c_long;
            if frame_count < 0 as libc::c_int as libc::c_long {
                printf(b"Incompatible TXT file\n\0" as *const u8 as *const libc::c_char);
                exit(2 as libc::c_int);
            }
            framearray = 0 as libc::c_int != 0;
            printf(b"Close window or hit ESCAPE when done\n\0" as *const u8 as *const libc::c_char);
            output_debugwindow = 1 as libc::c_int != 0;
            ReviewResult();
        }
        if !loadingTXT && (output_srt as libc::c_int != 0 || output_smi as libc::c_int != 0) {
            static mut filename_0: [libc::c_char; 1024] = [0; 1024];
            static mut CEW_argv: [*mut libc::c_char; 10] =
                [0 as *const libc::c_char as *mut libc::c_char; 10];
            i = 0 as libc::c_int;
            let fresh78 = i;
            i = i + 1;
            CEW_argv[fresh78 as usize] =
                b"comskip.exe\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
            if output_smi {
                let fresh79 = i;
                i = i + 1;
                CEW_argv[fresh79 as usize] =
                    b"-sami\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
                output_srt = 1 as libc::c_int != 0;
                sprintf(
                    filename_0.as_mut_ptr(),
                    b"%s.smi\0" as *const u8 as *const libc::c_char,
                    outbasename.as_mut_ptr(),
                );
            } else {
                let fresh80 = i;
                i = i + 1;
                CEW_argv[fresh80 as usize] =
                    b"-srt\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
                sprintf(
                    filename_0.as_mut_ptr(),
                    b"%s.srt\0" as *const u8 as *const libc::c_char,
                    outbasename.as_mut_ptr(),
                );
            }
            let fresh81 = i;
            i = i + 1;
            CEW_argv[fresh81 as usize] =
                *((*in_0).filename).offset(0 as libc::c_int as isize) as *mut libc::c_char;
            let fresh82 = i;
            i = i + 1;
            CEW_argv[fresh82 as usize] =
                b"-o\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
            let fresh83 = i;
            i = i + 1;
            CEW_argv[fresh83 as usize] = filename_0.as_mut_ptr();
            CEW_init(i, CEW_argv.as_mut_ptr());
        }
        if loadingCSV {
            output_framearray = 0 as libc::c_int != 0;
            ProcessCSV(in_file);
            output_debugwindow = 0 as libc::c_int != 0;
        }
    }
    arg_freetable(
        argtable.as_mut_ptr(),
        (::std::mem::size_of::<[*mut libc::c_void; 31]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong),
    );
    return in_file;
}
#[no_mangle]
pub unsafe extern "C" fn ProcessARInfoInit(
    mut minY_0: libc::c_int,
    mut maxY_0: libc::c_int,
    mut minX_0: libc::c_int,
    mut maxX_0: libc::c_int,
) {
    let mut pictureHeight: libc::c_double = (maxY_0 - minY_0) as libc::c_double;
    let mut pictureWidth: libc::c_double = (maxX_0 - minX_0) as libc::c_double;
    if minX_0 <= border {
        minX_0 = 1 as libc::c_int;
    }
    if minY_0 <= border {
        minY_0 = 1 as libc::c_int;
    }
    if maxY_0 >= height - border {
        maxY_0 = height;
    }
    if maxX_0 >= videowidth - border {
        maxX_0 = videowidth;
    }
    last_ar_ratio = pictureWidth / pictureHeight;
    last_ar_ratio = ceil(last_ar_ratio * ar_rounding) / ar_rounding;
    ar_ratio_trend = last_ar_ratio;
    if last_ar_ratio < 0.5f64 || last_ar_ratio > 3.0f64 {
        last_ar_ratio = 0.0f64;
    }
    ar_ratio_start = framenum_real;
    (*ar_block.offset(ar_block_count as isize)).start = framenum_real;
    (*ar_block.offset(ar_block_count as isize)).width = videowidth;
    (*ar_block.offset(ar_block_count as isize)).height = height;
    (*ar_block.offset(ar_block_count as isize)).minX = minX_0;
    (*ar_block.offset(ar_block_count as isize)).minY = minY_0;
    (*ar_block.offset(ar_block_count as isize)).maxX = maxX_0;
    (*ar_block.offset(ar_block_count as isize)).maxY = maxY_0;
    (*ar_block.offset(ar_block_count as isize)).ar_ratio = last_ar_ratio;
    Debug(
        4 as libc::c_int,
        b"Frame: %i\tRatio: %.2f\tMinY: %i MaxY: %i MinX: %i MaxX: %i\n\0" as *const u8
            as *const libc::c_char as *mut libc::c_char,
        ar_ratio_start,
        ar_ratio_trend,
        minY_0,
        maxY_0,
        minX_0,
        maxX_0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn ProcessARInfo(
    mut minY_0: libc::c_int,
    mut maxY_0: libc::c_int,
    mut minX_0: libc::c_int,
    mut maxX_0: libc::c_int,
) {
    let mut pictureHeight: libc::c_int = 0;
    let mut pictureWidth: libc::c_int = 0;
    let mut hi: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut cur_ar_ratio: libc::c_double = 0.;
    if minX_0 <= border {
        minX_0 = 1 as libc::c_int;
    }
    if minY_0 <= border {
        minY_0 = 1 as libc::c_int;
    }
    if maxY_0 >= height - border {
        maxY_0 = height;
    }
    if maxX_0 >= videowidth - border {
        maxX_0 = videowidth;
    }
    if ticker_tape_percentage > 0 as libc::c_int {
        ticker_tape = ticker_tape_percentage * height / 100 as libc::c_int;
    }
    if ticker_tape > 0 as libc::c_int
        || abs(height - maxY_0 - minY_0) < 13 as libc::c_int + minY_0 / 15 as libc::c_int
            && abs(videowidth - maxX_0 - minX_0) < 13 as libc::c_int + minX_0 / 15 as libc::c_int
            && minY_0 < height / 4 as libc::c_int
            && minX_0 < videowidth / 4 as libc::c_int
    {
        pictureHeight = maxY_0 - minY_0;
        pictureWidth = maxX_0 - minX_0;
        cur_ar_ratio = pictureWidth as libc::c_double / pictureHeight as libc::c_double;
        cur_ar_ratio = ceil(cur_ar_ratio * ar_rounding) / ar_rounding;
        if cur_ar_ratio > 3.0f64 || cur_ar_ratio < 0.5f64 {
            cur_ar_ratio = 0.0f64;
        }
        hi = ((cur_ar_ratio - 0.5f64) * 100 as libc::c_int as libc::c_double) as libc::c_int;
        if hi >= 0 as libc::c_int && hi < 1000 as libc::c_int {
            ar_histogram[hi as usize].frames += 1 as libc::c_int as libc::c_long;
            ar_histogram[hi as usize].ar_ratio = cur_ar_ratio;
        }
        if cur_ar_ratio - last_ar_ratio > ar_delta || cur_ar_ratio - last_ar_ratio < -ar_delta {
            if cur_ar_ratio - ar_ratio_trend < ar_delta && cur_ar_ratio - ar_ratio_trend > -ar_delta
            {
                ar_ratio_trend_counter += 1;
                if ar_ratio_trend_counter as libc::c_double / fps > 0.8f64 {
                    last_ar_ratio = ar_ratio_trend;
                    ar_ratio_trend_counter = 0 as libc::c_int;
                    ar_misratio_trend_counter = 0 as libc::c_int;
                    if commDetectMethod & 32 as libc::c_int != 0 {
                        (*ar_block.offset(ar_block_count as isize)).end =
                            ar_ratio_start - 1 as libc::c_int;
                        ar_block_count += 1;
                        InitializeARBlockArray(ar_block_count);
                        (*ar_block.offset(ar_block_count as isize)).start = ar_ratio_start;
                        (*ar_block.offset(ar_block_count as isize)).ar_ratio = ar_ratio_trend;
                        (*ar_block.offset(ar_block_count as isize)).volume = 0 as libc::c_int;
                        (*ar_block.offset(ar_block_count as isize)).width = videowidth;
                        (*ar_block.offset(ar_block_count as isize)).height = height;
                        (*ar_block.offset(ar_block_count as isize)).minX = minX_0;
                        (*ar_block.offset(ar_block_count as isize)).minY = minY_0;
                        (*ar_block.offset(ar_block_count as isize)).maxX = maxX_0;
                        (*ar_block.offset(ar_block_count as isize)).maxY = maxY_0;
                    }
                    Debug(
                        9 as libc::c_int,
                        b"Frame: %i\tRatio: %.2f\tMinY: %i\tMaxY: %i\tMinX: %i\tMaxX: %i\n\0"
                            as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        ar_ratio_start,
                        ar_ratio_trend,
                        minY_0,
                        maxY_0,
                        minX_0,
                        maxX_0,
                    );
                    last_ar_ratio = ar_ratio_trend;
                    if framearray {
                        i = ar_ratio_start;
                        while i < framenum_real {
                            (*frame.offset(i as isize)).ar_ratio = last_ar_ratio;
                            i += 1;
                        }
                    }
                }
            } else {
                ar_ratio_trend = cur_ar_ratio;
                ar_ratio_trend_counter = 0 as libc::c_int;
                ar_ratio_start = framenum_real;
            }
            ar_misratio_trend_counter += 1;
        } else {
            ar_ratio_trend_counter = 0 as libc::c_int;
            ar_ratio_start = framenum_real;
            ar_misratio_trend_counter = 0 as libc::c_int;
            ar_misratio_start = framenum_real;
        }
    } else {
        ar_ratio_trend_counter = 0 as libc::c_int;
        ar_ratio_start = framenum_real;
    }
    if ar_misratio_trend_counter as libc::c_double > 3 as libc::c_int as libc::c_double * fps
        && last_ar_ratio != 0.0f64
    {
        ar_ratio_trend = 0.0f64;
        last_ar_ratio = ar_ratio_trend;
        if commDetectMethod & 32 as libc::c_int != 0 {
            (*ar_block.offset(ar_block_count as isize)).end =
                framenum_real - 3 as libc::c_int * fps as libc::c_int - 1 as libc::c_int;
            ar_block_count += 1;
            InitializeARBlockArray(ar_block_count);
            (*ar_block.offset(ar_block_count as isize)).start =
                framenum_real - 3 as libc::c_int * fps as libc::c_int;
            (*ar_block.offset(ar_block_count as isize)).ar_ratio = ar_ratio_trend;
            (*ar_block.offset(ar_block_count as isize)).volume = 0 as libc::c_int;
            (*ar_block.offset(ar_block_count as isize)).width = videowidth;
            (*ar_block.offset(ar_block_count as isize)).height = height;
            (*ar_block.offset(ar_block_count as isize)).minX = minX_0;
            (*ar_block.offset(ar_block_count as isize)).minY = minY_0;
            (*ar_block.offset(ar_block_count as isize)).maxX = maxX_0;
            (*ar_block.offset(ar_block_count as isize)).maxY = maxY_0;
        }
        Debug(
            9 as libc::c_int,
            b"Frame: %i\tRatio: %.2f\tMinY: %i\tMaxY: %i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            ar_ratio_start,
            ar_ratio_trend,
            minY_0,
            maxY_0,
        );
        last_ar_ratio = ar_ratio_trend;
    }
}
#[no_mangle]
pub unsafe extern "C" fn ProcessACInfoInit(mut audio_channels_0: libc::c_int) {
    (*ac_block.offset(ac_block_count as isize)).start = framenum_real;
    (*ac_block.offset(ac_block_count as isize)).audio_channels = audio_channels_0;
    last_audio_channels = audio_channels_0;
    Debug(
        4 as libc::c_int,
        b"Frame: %i Channels: %2i\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        framenum_real,
        audio_channels_0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn ProcessACInfo(mut audio_channels_0: libc::c_int) {
    if last_audio_channels == audio_channels_0 {
        return;
    }
    (*ac_block.offset(ac_block_count as isize)).end = framenum_real;
    ac_block_count += 1;
    InitializeACBlockArray(ac_block_count);
    last_audio_channels = audio_channels_0;
    (*ac_block.offset(ac_block_count as isize)).start = framenum_real;
    (*ac_block.offset(ac_block_count as isize)).audio_channels = audio_channels_0;
    last_audio_channels = audio_channels_0;
    Debug(
        4 as libc::c_int,
        b"Frame: %i Channels: %2i\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        framenum_real,
        audio_channels_0,
    );
}
#[no_mangle]
pub unsafe extern "C" fn MatchCutScene(mut cutscene_0: *mut libc::c_uchar) -> libc::c_int {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut d: libc::c_int = 0;
    let mut delta: libc::c_int = 0 as libc::c_int;
    let mut step: libc::c_int = 4 as libc::c_int;
    let mut c: libc::c_int = 0 as libc::c_int;
    if width > 800 as libc::c_int {
        step = 8 as libc::c_int;
    }
    if width < 400 as libc::c_int {
        step = 2 as libc::c_int;
    }
    if width < 200 as libc::c_int {
        step = 1 as libc::c_int;
    }
    y = border;
    while y < height - border {
        x = border;
        while x < videowidth - border {
            if c < 400 as libc::c_int * 300 as libc::c_int {
                d = *frame_ptr.offset((y * width + x) as isize) as libc::c_int
                    - *cutscene_0.offset(c as isize) as libc::c_int;
                if d > edge_level_threshold || d < -edge_level_threshold {
                    delta += 1 as libc::c_int;
                }
            }
            c += 1;
            x += step;
        }
        y += step;
    }
    return delta;
}
#[no_mangle]
pub unsafe extern "C" fn RecordCutScene(
    mut frame_count_0: libc::c_int,
    mut brightness_0: libc::c_int,
) {
    let mut cs: [libc::c_char; 120000] = [0; 120000];
    let mut c: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut step: libc::c_int = 4 as libc::c_int;
    if width > 800 as libc::c_int {
        step = 8 as libc::c_int;
    }
    if width < 400 as libc::c_int {
        step = 2 as libc::c_int;
    }
    if width < 200 as libc::c_int {
        step = 1 as libc::c_int;
    }
    c = 0 as libc::c_int;
    y = border;
    while y < height - border {
        x = border;
        while x < videowidth - border {
            if c < 400 as libc::c_int * 300 as libc::c_int {
                let fresh84 = c;
                c = c + 1;
                cs[fresh84 as usize] = *frame_ptr.offset((y * width + x) as isize) as libc::c_char;
            }
            x += step;
        }
        y += step;
    }
    cutscene_file = 0 as *mut FILE;
    if *osname.as_mut_ptr().offset(0 as libc::c_int as isize) != 0 {
        strcpy(cutscenefile.as_mut_ptr(), osname.as_mut_ptr());
        strcat(
            cutscenefile.as_mut_ptr(),
            b".dmp\0" as *const u8 as *const libc::c_char,
        );
    }
    if cutscenefile[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int {
        sprintf(
            cutscenefile.as_mut_ptr(),
            b"%s.dmp\0" as *const u8 as *const libc::c_char,
            workbasename.as_mut_ptr(),
        );
    }
    if cutscenefile[0 as libc::c_int as usize] != 0 {
        cutscene_file = myfopen(
            cutscenefile.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if !cutscene_file.is_null() {
        fwrite(
            &mut brightness_0 as *mut libc::c_int as *const libc::c_void,
            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            cutscene_file,
        );
        fwrite(
            cs.as_mut_ptr() as *const libc::c_void,
            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
            c as libc::c_ulong,
            cutscene_file,
        );
        Debug(
            7 as libc::c_int,
            b"Saved frame %6i into cutfile \"%s\"\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            frame_count_0,
            cutscenefile.as_mut_ptr(),
        );
        fclose(cutscene_file);
        cutscene_file = 0 as *mut FILE;
    }
}
#[no_mangle]
pub unsafe extern "C" fn LoadCutScene(mut filename_0: *const libc::c_char) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    cutscene_file = myfopen(
        filename_0,
        b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if !cutscene_file.is_null() {
        i = cutscenes;
        fread(
            &mut *csbrightness.as_mut_ptr().offset(i as isize) as *mut libc::c_int
                as *mut libc::c_void,
            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            cutscene_file,
        );
        c = fread(
            (cutscene[i as usize]).as_mut_ptr() as *mut libc::c_void,
            ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
            (400 as libc::c_int * 300 as libc::c_int) as libc::c_ulong,
            cutscene_file,
        ) as libc::c_int;
        if c > 0 as libc::c_int {
            Debug(
                7 as libc::c_int,
                b"Loaded %i bytes from cutfile \"%s\"\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                c,
                filename_0,
            );
            cslength[i as usize] = c;
            b = 0 as libc::c_int;
            j = 0 as libc::c_int;
            while j < c {
                b += cutscene[i as usize][j as usize] as libc::c_int;
                j += 1;
            }
            cutscenes += 1;
        } else {
            Debug(
                1 as libc::c_int,
                b"ERROR: Loading from cutfile \"%s\" failed\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                c,
                filename_0,
            );
        }
        fclose(cutscene_file);
    } else {
        Debug(
            1 as libc::c_int,
            b"Can't open cutfile \"%s\"\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            filename_0,
        );
    };
}
static mut own_histogram: [[libc::c_int; 256]; 4] = [[0; 256]; 4];
#[no_mangle]
pub static mut scan_step: libc::c_int = 0;
static mut thwait: [sema_t; 4] = [0 as *const dispatch_semaphore_s as *mut dispatch_semaphore_s; 4];
static mut thdone: [sema_t; 4] = [0 as *const dispatch_semaphore_s as *mut dispatch_semaphore_s; 4];
static mut thread_init_done: libc::c_int = 0 as libc::c_int;
static mut th1: pthread_t = 0 as *const _opaque_pthread_t as *mut _opaque_pthread_t;
static mut th2: pthread_t = 0 as *const _opaque_pthread_t as *mut _opaque_pthread_t;
static mut th3: pthread_t = 0 as *const _opaque_pthread_t as *mut _opaque_pthread_t;
static mut th4: pthread_t = 0 as *const _opaque_pthread_t as *mut _opaque_pthread_t;
#[no_mangle]
pub unsafe extern "C" fn ScanBottom(mut arg: intptr_t) {
    let mut i: libc::c_int = 0;
    let mut i_max: libc::c_int = 0;
    let mut i_step: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut delta: libc::c_int = 0;
    let mut max_delta: libc::c_int = 0;
    let mut hereBright: libc::c_int = 0;
    let mut brightCount: libc::c_int = 0;
    let mut w: libc::c_int = arg as libc::c_int;
    loop {
        if thread_count > 1 as libc::c_int {
            dispatch_semaphore_wait(thwait[w as usize], !(0 as libc::c_ulonglong));
        }
        brightCount = 0 as libc::c_int;
        max_delta = min(videowidth, height) / 2 as libc::c_int - border;
        delta = 0 as libc::c_int;
        while delta < max_delta {
            y = border + delta;
            x = border + delta;
            i = y * width + x;
            i_max = y * width + videowidth - border - delta;
            i_step = scan_step;
            while i < i_max {
                if !(haslogo[i as usize] != 0) {
                    hereBright = *frame_ptr.offset(i as isize) as libc::c_int;
                    own_histogram[0 as libc::c_int as usize][hereBright as usize] += 1;
                    if hereBright > test_brightness {
                        brightCount += 1;
                    }
                }
                i += i_step;
            }
            if brightCount < 5 as libc::c_int {
                minY = y;
            }
            delta += scan_step;
        }
        if !(thread_count > 1 as libc::c_int) {
            break;
        }
        dispatch_semaphore_signal(thdone[w as usize]);
    }
}
#[no_mangle]
pub unsafe extern "C" fn ScanTop(mut arg: intptr_t) {
    let mut i: libc::c_int = 0;
    let mut i_max: libc::c_int = 0;
    let mut i_step: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut delta: libc::c_int = 0;
    let mut max_delta: libc::c_int = 0;
    let mut hereBright: libc::c_int = 0;
    let mut brightCount: libc::c_int = 0;
    let mut w: libc::c_int = arg as libc::c_int;
    loop {
        if thread_count > 1 as libc::c_int {
            dispatch_semaphore_wait(thwait[w as usize], !(0 as libc::c_ulonglong));
        }
        max_delta = min(videowidth, height) / 2 as libc::c_int - border;
        brightCount = 0 as libc::c_int;
        delta = 0 as libc::c_int;
        while delta < max_delta {
            x = border + delta;
            y = height - border - delta;
            i = y * width + x;
            i_max = y * width + videowidth - border - delta;
            i_step = scan_step;
            while i < i_max {
                if !(haslogo[i as usize] != 0) {
                    hereBright = *frame_ptr.offset(i as isize) as libc::c_int;
                    own_histogram[1 as libc::c_int as usize][hereBright as usize] += 1;
                    if hereBright > test_brightness {
                        brightCount += 1;
                    }
                }
                i += i_step;
            }
            if brightCount < 5 as libc::c_int {
                maxY = y;
            }
            delta += scan_step;
        }
        if !(thread_count > 1 as libc::c_int) {
            break;
        }
        dispatch_semaphore_signal(thdone[w as usize]);
    }
}
#[no_mangle]
pub unsafe extern "C" fn ScanLeft(mut arg: intptr_t) {
    let mut i: libc::c_int = 0;
    let mut i_max: libc::c_int = 0;
    let mut i_step: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut delta: libc::c_int = 0;
    let mut max_delta: libc::c_int = 0;
    let mut hereBright: libc::c_int = 0;
    let mut brightCount: libc::c_int = 0;
    let mut w: libc::c_int = arg as libc::c_int;
    loop {
        if thread_count > 1 as libc::c_int {
            dispatch_semaphore_wait(thwait[w as usize], !(0 as libc::c_ulonglong));
        }
        max_delta = min(videowidth, height) / 2 as libc::c_int - border;
        brightCount = 0 as libc::c_int;
        delta = 0 as libc::c_int;
        while delta < max_delta {
            x = border + delta;
            y = border + delta;
            i = y * width + x;
            i_step = scan_step * width;
            i_max = (height - border - delta) * width + x;
            while i < i_max {
                if !(haslogo[i as usize] != 0) {
                    hereBright = *frame_ptr.offset(i as isize) as libc::c_int;
                    own_histogram[2 as libc::c_int as usize][hereBright as usize] += 1;
                    if hereBright > test_brightness {
                        brightCount += 1;
                    }
                }
                i += i_step;
            }
            if brightCount < 5 as libc::c_int {
                minX = x;
            }
            delta += scan_step;
        }
        if !(thread_count > 1 as libc::c_int) {
            break;
        }
        dispatch_semaphore_signal(thdone[w as usize]);
    }
}
#[no_mangle]
pub unsafe extern "C" fn ScanRight(mut arg: intptr_t) {
    let mut i: libc::c_int = 0;
    let mut i_max: libc::c_int = 0;
    let mut i_step: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut delta: libc::c_int = 0;
    let mut max_delta: libc::c_int = 0;
    let mut hereBright: libc::c_int = 0;
    let mut brightCount: libc::c_int = 0;
    let mut w: libc::c_int = arg as libc::c_int;
    loop {
        if thread_count > 1 as libc::c_int {
            dispatch_semaphore_wait(thwait[w as usize], !(0 as libc::c_ulonglong));
        }
        max_delta = min(videowidth, height) / 2 as libc::c_int - border;
        brightCount = 0 as libc::c_int;
        delta = 0 as libc::c_int;
        while delta < max_delta {
            x = videowidth - border - delta;
            y = border + delta;
            i = y * width + x;
            i_step = scan_step * width;
            i_max = (height - border - delta) * width + x;
            while i < i_max {
                if !(haslogo[i as usize] != 0) {
                    hereBright = *frame_ptr.offset(i as isize) as libc::c_int;
                    own_histogram[3 as libc::c_int as usize][hereBright as usize] += 1;
                    if hereBright > test_brightness {
                        brightCount += 1;
                    }
                }
                i += i_step;
            }
            if brightCount < 5 as libc::c_int {
                maxX = x;
            }
            delta += scan_step;
        }
        if !(thread_count > 1 as libc::c_int) {
            break;
        }
        dispatch_semaphore_signal(thdone[w as usize]);
    }
}
#[no_mangle]
pub unsafe extern "C" fn DetectCredits(mut frame_count_0: libc::c_int) {
    static mut credit_length: libc::c_int = 0 as libc::c_int;
    static mut prev_credit_length: libc::c_int = 0 as libc::c_int;
    static mut prev_credit_end: libc::c_int = 0 as libc::c_int;
    static mut credit_count: libc::c_int = 0 as libc::c_int;
    if frame_count_0 > 1 as libc::c_int
        && abs((*frame.offset(frame_count_0 as isize)).brightness
            - (*frame.offset((frame_count_0 - 1 as libc::c_int) as isize)).brightness)
            < 2 as libc::c_int
        && (*frame.offset(frame_count_0 as isize)).brightness
            < max_avg_brightness + 5 as libc::c_int
    {
        (*frame.offset(frame_count_0 as isize)).cutscenematch =
            (*frame.offset((frame_count_0 - 1 as libc::c_int) as isize)).cutscenematch
                - 1 as libc::c_int;
        credit_length += 1;
    } else if credit_length as libc::c_double > fps * 0.5f64 {
        (*frame.offset(frame_count_0 as isize)).cutscenematch = 100 as libc::c_int;
        if abs(credit_length - prev_credit_length) < 10 as libc::c_int
            && frame_count_0 - credit_length - prev_credit_end
                < fps as libc::c_int / 2 as libc::c_int
        {
            credit_count += 1;
            if credit_count > 5 as libc::c_int {
                Debug(
                    1 as libc::c_int,
                    b"Credits[%i] detected at frame %i\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    credit_count,
                    frame_count_0,
                );
            }
        }
        prev_credit_end = frame_count_0;
        prev_credit_length = credit_length;
        credit_length = 0 as libc::c_int;
    } else if frame_count_0 - prev_credit_end < fps as libc::c_int / 2 as libc::c_int {
        (*frame.offset(frame_count_0 as isize)).cutscenematch = 100 as libc::c_int;
        credit_length = 0 as libc::c_int;
    } else {
        (*frame.offset(frame_count_0 as isize)).cutscenematch = 100 as libc::c_int;
        credit_length = 0 as libc::c_int;
        credit_count = 0 as libc::c_int;
        prev_credit_length = 0 as libc::c_int;
        prev_credit_end = 0 as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn CheckSceneHasChanged() -> bool {
    let mut i: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut step: libc::c_int = 0;
    let mut similar: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut hasBright: libc::c_int = 0 as libc::c_int;
    let mut dimCount: libc::c_int = 0 as libc::c_int;
    let mut isDim: bool = 0 as libc::c_int != 0;
    let mut pixels: libc::c_int = 0 as libc::c_int;
    let mut cause: libc::c_long = 0;
    let mut uniform: libc::c_int = 0 as libc::c_int;
    let mut scale: libc::c_double = 1.0f64;
    if videowidth == 0 || width == 0 || height == 0 {
        return 0 as libc::c_int != 0;
    }
    minY = border;
    maxY = height - border;
    minX = border;
    maxX = videowidth - border;
    step = 2 as libc::c_int;
    if videowidth > 1200 as libc::c_int {
        step = 3 as libc::c_int;
    }
    if videowidth > 1800 as libc::c_int {
        step = 4 as libc::c_int;
    }
    if videowidth < 600 as libc::c_int {
        step = 1 as libc::c_int;
    }
    scan_step = step;
    if edge_step == 0 as libc::c_int {
        edge_step = step;
    }
    memcpy(
        lastHistogram.as_mut_ptr() as *mut libc::c_void,
        histogram.as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_long; 256]>() as libc::c_ulong,
    );
    last_brightness = brightness;
    brightness = 0 as libc::c_int;
    memset(
        own_histogram.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[[libc::c_int; 256]; 4]>() as libc::c_ulong,
    );
    if thread_count > 1 as libc::c_int {
        if thread_init_done == 0 {
            thread_init_done = 1 as libc::c_int;
            i = 0 as libc::c_int;
            while i < 4 as libc::c_int {
                thwait[i as usize] = dispatch_semaphore_create(0 as libc::c_int as intptr_t);
                thdone[i as usize] = dispatch_semaphore_create(0 as libc::c_int as intptr_t);
                i += 1;
            }
            pthread_create(
                &mut th2,
                0 as *const pthread_attr_t,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
                >(::std::mem::transmute::<
                    Option<unsafe extern "C" fn(intptr_t) -> ()>,
                    *mut libc::c_void,
                >(Some(
                    ScanBottom as unsafe extern "C" fn(intptr_t) -> (),
                ))),
                0 as *mut libc::c_void,
            );
            pthread_create(
                &mut th1,
                0 as *const pthread_attr_t,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
                >(::std::mem::transmute::<
                    Option<unsafe extern "C" fn(intptr_t) -> ()>,
                    *mut libc::c_void,
                >(Some(
                    ScanTop as unsafe extern "C" fn(intptr_t) -> (),
                ))),
                1 as libc::c_int as *mut libc::c_void,
            );
            pthread_create(
                &mut th3,
                0 as *const pthread_attr_t,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
                >(::std::mem::transmute::<
                    Option<unsafe extern "C" fn(intptr_t) -> ()>,
                    *mut libc::c_void,
                >(Some(
                    ScanLeft as unsafe extern "C" fn(intptr_t) -> (),
                ))),
                2 as libc::c_int as *mut libc::c_void,
            );
            pthread_create(
                &mut th4,
                0 as *const pthread_attr_t,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void>,
                >(::std::mem::transmute::<
                    Option<unsafe extern "C" fn(intptr_t) -> ()>,
                    *mut libc::c_void,
                >(Some(
                    ScanRight as unsafe extern "C" fn(intptr_t) -> (),
                ))),
                3 as libc::c_int as *mut libc::c_void,
            );
        }
        i = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            dispatch_semaphore_signal(thwait[i as usize]);
            i += 1;
        }
        i = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            dispatch_semaphore_wait(thdone[i as usize], !(0 as libc::c_ulonglong));
            i += 1;
        }
    } else {
        ScanBottom(0 as libc::c_int as intptr_t);
        ScanTop(0 as libc::c_int as intptr_t);
        ScanLeft(0 as libc::c_int as intptr_t);
        ScanRight(0 as libc::c_int as intptr_t);
    }
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        histogram[i as usize] = (own_histogram[0 as libc::c_int as usize][i as usize]
            + own_histogram[1 as libc::c_int as usize][i as usize]
            + own_histogram[2 as libc::c_int as usize][i as usize]
            + own_histogram[3 as libc::c_int as usize][i as usize])
            as libc::c_long;
        i += 1;
    }
    if framearray {
        (*frame.offset(frame_count as isize)).minY = minY;
    }
    if framearray {
        (*frame.offset(frame_count as isize)).maxY = maxY;
    }
    if framearray {
        (*frame.offset(frame_count as isize)).minX = minX;
    }
    if framearray {
        (*frame.offset(frame_count as isize)).maxX = maxX;
    }
    if framenum_real <= 1 as libc::c_int {
        memcpy(
            lastHistogram.as_mut_ptr() as *mut libc::c_void,
            histogram.as_mut_ptr() as *const libc::c_void,
            ::std::mem::size_of::<[libc::c_long; 256]>() as libc::c_ulong,
        );
        last_brightness = brightness;
        if commDetectMethod & 32 as libc::c_int != 0 {
            ProcessARInfoInit(minY, maxY, minX, maxX);
            if framearray {
                (*frame.offset(frame_count as isize)).ar_ratio = last_ar_ratio;
            }
        }
        ProcessACInfoInit((*frame.offset(frame_count as isize)).audio_channels);
        i = max_brightness;
        while i >= 0 as libc::c_int {
            last_brightness = (last_brightness as libc::c_long
                + histogram[i as usize] * i as libc::c_long)
                as libc::c_int;
            i -= 1;
        }
        last_brightness /= (width - border * 2 as libc::c_int)
            * (height - border * 2 as libc::c_int)
            / 16 as libc::c_int;
        if framearray {
            (*frame.offset(frame_count as isize)).brightness = last_brightness;
            (*frame.offset(frame_count as isize)).logo_present = 0 as libc::c_int != 0;
            (*frame.offset(frame_count as isize)).schange_percent = 0 as libc::c_int;
        }
        if commDetectMethod & 4 as libc::c_int != 0 {
            InitializeSchangeArray(0 as libc::c_int as libc::c_long);
            (*schange.offset(0 as libc::c_int as isize)).frame = 0 as libc::c_int as libc::c_long;
            (*schange.offset(0 as libc::c_int as isize)).percentage = 0 as libc::c_int;
            schange_count += 1;
        }
        return 0 as libc::c_int != 0;
    }
    (17652 as libc::c_int as libc::c_long) < frame_count
        && frame_count < 17657 as libc::c_int as libc::c_long;
    ProcessARInfo(minY, maxY, minX, maxX);
    ProcessACInfo((*frame.offset(frame_count as isize)).audio_channels);
    if framearray {
        (*frame.offset(frame_count as isize)).ar_ratio = last_ar_ratio;
    }
    similar *= 1 as libc::c_int as libc::c_long;
    i = 255 as libc::c_int;
    while i > max_brightness {
        pixels = (pixels as libc::c_long + histogram[i as usize]) as libc::c_int;
        brightness =
            (brightness as libc::c_long + histogram[i as usize] * i as libc::c_long) as libc::c_int;
        if histogram[i as usize] != 0 {
            hasBright += 1;
        }
        if histogram[i as usize] < lastHistogram[i as usize] {
            similar += histogram[i as usize];
        } else {
            similar += lastHistogram[i as usize];
        }
        i -= 1;
    }
    i = max_brightness;
    while i > test_brightness {
        pixels = (pixels as libc::c_long + histogram[i as usize]) as libc::c_int;
        brightness =
            (brightness as libc::c_long + histogram[i as usize] * i as libc::c_long) as libc::c_int;
        dimCount = (dimCount as libc::c_long + histogram[i as usize]) as libc::c_int;
        if histogram[i as usize] < lastHistogram[i as usize] {
            similar += histogram[i as usize];
        } else {
            similar += lastHistogram[i as usize];
        }
        i -= 1;
    }
    i = test_brightness;
    while i >= 0 as libc::c_int {
        pixels = (pixels as libc::c_long + histogram[i as usize]) as libc::c_int;
        brightness =
            (brightness as libc::c_long + histogram[i as usize] * i as libc::c_long) as libc::c_int;
        if histogram[i as usize] < lastHistogram[i as usize] {
            similar += histogram[i as usize];
        } else {
            similar += lastHistogram[i as usize];
        }
        i -= 1;
    }
    brightness /= pixels;
    if framearray {
        (*frame.offset(frame_count as isize)).hasBright = hasBright;
    }
    scale = 720.0f64 * 480.0f64 / width as libc::c_double / height as libc::c_double;
    if min_hasBright as libc::c_double > hasBright as libc::c_double * scale {
        min_hasBright = (hasBright as libc::c_double * scale) as libc::c_int;
    }
    if framearray {
        (*frame.offset(frame_count as isize)).dimCount = dimCount;
    }
    if min_dimCount as libc::c_double > dimCount as libc::c_double * scale {
        min_dimCount = (dimCount as libc::c_double * scale) as libc::c_int;
    }
    if cutsceneno != 0 as libc::c_int || frame_count == cutsceneno as libc::c_long {
        RecordCutScene(frame_count as libc::c_int, brightness);
    }
    uniform = 0 as libc::c_int;
    i = 255 as libc::c_int;
    while i > brightness + noise_level {
        uniform = (uniform as libc::c_long
            + histogram[i as usize] * (i - brightness) as libc::c_long)
            as libc::c_int;
        i -= 1;
    }
    i = brightness - noise_level;
    while i >= 0 as libc::c_int {
        uniform = (uniform as libc::c_long
            + histogram[i as usize] * (brightness - i) as libc::c_long)
            as libc::c_int;
        i -= 1;
    }
    uniform = (uniform as libc::c_double * 730 as libc::c_int as libc::c_double
        / pixels as libc::c_double) as libc::c_int;
    if framearray {
        (*frame.offset(frame_count as isize)).uniform = uniform;
    }
    x = 0 as libc::c_int;
    i = 10 as libc::c_int;
    while i < 100 as libc::c_int {
        if histogram[i as usize] > 10 as libc::c_int as libc::c_long {
            if (x as libc::c_long) < histogram[i as usize] {
                x = histogram[i as usize] as libc::c_int;
            } else if x as libc::c_long > histogram[(i + 1 as libc::c_int) as usize]
                && histogram[(i - 1 as libc::c_int) as usize] > 1000 as libc::c_int as libc::c_long
            {
                blackHistogram[(i - 1 as libc::c_int) as usize] += 1;
                break;
            }
        }
        i += 1;
    }
    x = 0 as libc::c_int;
    i = 10 as libc::c_int;
    while i < 100 as libc::c_int {
        if blackHistogram[x as usize] < blackHistogram[i as usize] {
            x = i;
        }
        i += 1;
    }
    if framearray {
        (*frame.offset(frame_count as isize)).brightness = brightness;
    }
    brightHistogram[brightness as usize] += 1;
    uniformHistogram[(if (uniform / 100 as libc::c_int) < 255 as libc::c_int {
        uniform / 100 as libc::c_int
    } else {
        255 as libc::c_int
    }) as usize] += 1;
    if dimCount > (0.05f64 * width as libc::c_double * height as libc::c_double) as libc::c_int
        && dimCount < (0.35f64 * width as libc::c_double * height as libc::c_double) as libc::c_int
    {
        isDim = 1 as libc::c_int != 0;
    }
    sceneChangePercent =
        (100.0f64 * similar as libc::c_double / pixels as libc::c_double) as libc::c_int;
    if framearray {
        (*frame.offset(frame_count as isize)).schange_percent = sceneChangePercent;
    }
    cause = 0 as libc::c_int as libc::c_long;
    if commDetectMethod & 1 as libc::c_int != 0 {
        if brightness <= max_avg_brightness
            && hasBright <= maxbright * width * height / 720 as libc::c_int / 480 as libc::c_int
            && !isDim
        {
            cause |= ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long;
            Debug(
                7 as libc::c_int,
                b"Frame %6i (%.3fs) - Black frame with brightness of %i,uniform of %i and volume of %i\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                framenum_real,
                get_frame_pts(framenum_real),
                brightness,
                uniform,
                (*black
                    .offset(
                        (if 0 as libc::c_int as libc::c_long
                            > black_count - 1 as libc::c_int as libc::c_long
                        {
                            0 as libc::c_int as libc::c_long
                        } else {
                            black_count - 1 as libc::c_int as libc::c_long
                        }) as isize,
                    ))
                    .volume,
            );
        } else if non_uniformity > 0 as libc::c_int {
            if brightness <= max_avg_brightness && uniform < non_uniformity {
                cause |= ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_long;
                Debug(
                    7 as libc::c_int,
                    b"Frame %6i (%.3fs) - Black frame with brightness of %i,uniform of %i and volume of %i\n\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                    framenum_real,
                    get_frame_pts(framenum_real),
                    brightness,
                    uniform,
                    (*black
                        .offset(
                            (if 0 as libc::c_int as libc::c_long
                                > black_count - 1 as libc::c_int as libc::c_long
                            {
                                0 as libc::c_int as libc::c_long
                            } else {
                                black_count - 1 as libc::c_int as libc::c_long
                            }) as isize,
                        ))
                        .volume,
                );
            }
            if brightness > max_avg_brightness
                && uniform < non_uniformity
                && brightness < 250 as libc::c_int
            {
                cause |= ((1 as libc::c_int) << 3 as libc::c_int) as libc::c_long;
                Debug(
                    7 as libc::c_int,
                    b"Frame %6i (%.3fs) - Uniform frame with brightness of %i and uniform of %i\n\0"
                        as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    framenum_real,
                    get_frame_pts(framenum_real),
                    brightness,
                    uniform,
                );
            }
        }
    }
    if old_width != 0 as libc::c_int && width != old_width
        || old_height != 0 as libc::c_int && height != old_height
    {
        cause |= (1 as libc::c_int as libc::c_long) << 29 as libc::c_int;
        Debug(
            7 as libc::c_int,
            b"Frame %6i (%.3fs) - Resolution change from %d x %d to %d x %d \n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            framenum_real,
            get_frame_pts(framenum_real),
            old_width,
            old_height,
            width,
            height,
        );
        old_width = width;
        old_height = height;
        ResetLogoBuffers();
    }
    old_width = width;
    old_height = height;
    if commDetectMethod & 4 as libc::c_int != 0 {
        if (*frame.offset((frame_count - 1 as libc::c_int as libc::c_long) as isize)).isblack
            as libc::c_int
            & (1 as libc::c_int) << 4 as libc::c_int
            == 0
            && cause & ((1 as libc::c_int) << 4 as libc::c_int) as libc::c_long == 0
        {
            if abs(
                (*frame.offset((frame_count - 1 as libc::c_int as libc::c_long) as isize))
                    .brightness
                    - last_brightness,
            ) > brightness_jump
            {
                Debug(
                    7 as libc::c_int,
                    b"Frame %6i (%.3fs) - Black frame because large brightness change from %i to %i with uniform %i\n\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                    framenum_real,
                    get_frame_pts(framenum_real),
                    last_brightness,
                    brightness,
                    uniform,
                );
                cause |= ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_long;
            } else if (*frame.offset((frame_count - 1 as libc::c_int as libc::c_long) as isize))
                .schange_percent
                < schange_cutlevel
            {
                Debug(
                    7 as libc::c_int,
                    b"Frame %6i (%.3fs) - Black frame because large scene change of %i, uniform %i\n\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                    framenum_real,
                    get_frame_pts(framenum_real),
                    sceneChangePercent,
                    uniform,
                );
                cause |= ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_long;
            }
        }
    }
    if sceneChangePercent < schange_threshold {
        InitializeSchangeArray(schange_count);
        (*schange.offset(schange_count as isize)).percentage = sceneChangePercent;
        (*schange.offset(schange_count as isize)).frame = framenum_real as libc::c_long;
        schange_count += 1;
    }
    if brightness < min_brightness_found {
        min_brightness_found = brightness;
    }
    if framearray {
        (*frame.offset(frame_count as isize)).cutscenematch = 100 as libc::c_int;
    }
    if cutscenes != 0 {
        if framearray {
            (*frame.offset(frame_count as isize)).cutscenematch = 100 as libc::c_int;
        }
        i = 0 as libc::c_int;
        while i < cutscenes {
            if abs(brightness - csbrightness[i as usize]) < 2 as libc::c_int {
                cutscenematch = MatchCutScene((cutscene[i as usize]).as_mut_ptr());
                if framearray {
                    if (*frame.offset(frame_count as isize)).cutscenematch
                        > cutscenematch * 100 as libc::c_int / cslength[i as usize]
                    {
                        (*frame.offset(frame_count as isize)).cutscenematch =
                            cutscenematch * 100 as libc::c_int / cslength[i as usize];
                    }
                    if (*frame.offset(frame_count as isize)).cutscenematch < cutscenedelta {
                        cause |= (1 as libc::c_int as libc::c_long) << 28 as libc::c_int;
                    }
                }
            }
            i += 1;
        }
    }
    if commDetectMethod & 64 as libc::c_int != 0 {
        if 0 as libc::c_int <= (*frame.offset(frame_count as isize)).volume
            && (*frame.offset(frame_count as isize)).volume < max_silence
            && min_silence == 1 as libc::c_int
        {
            cause |= (1 as libc::c_int as libc::c_long) << 18 as libc::c_int;
        }
        if 0 as libc::c_int == (*frame.offset(frame_count as isize)).volume {
            cause |= (1 as libc::c_int as libc::c_long) << 18 as libc::c_int;
        }
    }
    if cause != 0 as libc::c_int as libc::c_long {
        InsertBlackFrame(
            framenum_real,
            brightness,
            uniform,
            curvolume,
            cause as libc::c_int,
        );
    }
    if framearray {
        (*frame.offset(frame_count as isize)).isblack = cause != 0;
    }
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn PrintLogoFrameGroups() {
    let mut i: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut cl: libc::c_double = 0.;
    let mut f: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    Debug(
        2 as libc::c_int,
        b"\nLogos detected on the following frames\n--------------------------------------\n\0"
            as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    count = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < logo_block_count {
        f = FindBlock((*logo_block.offset(i as isize)).start as libc::c_long);
        t = FindBlock(((*logo_block.offset(i as isize)).end - 2 as libc::c_int) as libc::c_long);
        if f < 0 as libc::c_int {
            f = 0 as libc::c_int;
        }
        if t < 0 as libc::c_int {
            t = 0 as libc::c_int;
        }
        if t < 0 as libc::c_int {
            Debug(
                2 as libc::c_int,
                b"Panic\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            break;
        } else if f < 0 as libc::c_int {
            Debug(
                2 as libc::c_int,
                b"Panic\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            break;
        } else {
            Debug(
                2 as libc::c_int,
                b"Logo start - %6i\tend - %6i\tlength - %s\tbefore:%.1f s\t after:%.1f s\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                (*logo_block.offset(i as isize)).start,
                (*logo_block.offset(i as isize)).end,
                dblSecondsToStrMinutes(
                    (if !frame.is_null() {
                        (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*logo_block.offset(i as isize)).end >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((*logo_block.offset(i as isize)).end as isize)).pts
                            })
                        })
                    } else {
                        (*logo_block.offset(i as isize)).end as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if (*logo_block.offset(i as isize)).start <= 0 as libc::c_int {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*logo_block.offset(i as isize)).start >= framenum_real {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset((*logo_block.offset(i as isize)).start as isize)).pts
                            })
                        })
                    } else {
                        (*logo_block.offset(i as isize)).start as libc::c_double / fps
                    }),
                ),
                (if !frame.is_null() {
                    (if (*logo_block.offset(i as isize)).start <= 0 as libc::c_int {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*logo_block.offset(i as isize)).start >= framenum_real {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((*logo_block.offset(i as isize)).start as isize)).pts
                        })
                    })
                } else {
                    (*logo_block.offset(i as isize)).start as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if cblock[f as usize].f_start <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[f as usize].f_start >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(cblock[f as usize].f_start as isize)).pts
                        })
                    })
                } else {
                    cblock[f as usize].f_start as libc::c_double / fps
                }),
                (if !frame.is_null() {
                    (if cblock[t as usize].f_end <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if cblock[t as usize].f_end >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(cblock[t as usize].f_end as isize)).pts
                        })
                    })
                } else {
                    cblock[t as usize].f_end as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*logo_block.offset(i as isize)).end >= framenum_real {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((*logo_block.offset(i as isize)).end as isize)).pts
                        })
                    })
                } else {
                    (*logo_block.offset(i as isize)).end as libc::c_double / fps
                }),
            );
            count += (*logo_block.offset(i as isize)).end - (*logo_block.offset(i as isize)).start
                + 1 as libc::c_int;
            i += 1;
        }
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < logo_block_count - 1 as libc::c_int as libc::c_long {
        f = (*logo_block.offset(i as isize)).end;
        t = (*logo_block.offset((i + 1 as libc::c_int) as isize)).start;
        if (max_logo_gap as libc::c_double)
            < (if !frame.is_null() {
                (if t <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if t >= framenum_real {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(t as isize)).pts
                    })
                })
            } else {
                t as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if f <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if f >= framenum_real {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(f as isize)).pts
                    })
                })
            } else {
                f as libc::c_double / fps
            })
        {
            max_logo_gap = ((if !frame.is_null() {
                (if t <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if t >= framenum_real {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(t as isize)).pts
                    })
                })
            } else {
                t as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if f <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if f >= framenum_real {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(f as isize)).pts
                    })
                })
            } else {
                f as libc::c_double / fps
            })) as libc::c_int;
        }
        f = FindBlock((*logo_block.offset(i as isize)).end as libc::c_long);
        t = FindBlock((*logo_block.offset((i + 1 as libc::c_int) as isize)).start as libc::c_long);
        l = f + 1 as libc::c_int;
        while l < t {
            if (max_nonlogo_block_length as libc::c_double) < cblock[l as usize].length {
                max_nonlogo_block_length = cblock[l as usize].length as libc::c_int;
            }
            l += 1;
        }
        i += 1;
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < logo_block_count - 1 as libc::c_int as libc::c_long {
        f = FindBlock((*logo_block.offset(i as isize)).start as libc::c_long);
        t = FindBlock((*logo_block.offset(i as isize)).end as libc::c_long);
        if (if !frame.is_null() {
            (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if (*logo_block.offset(i as isize)).end >= framenum_real {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset((*logo_block.offset(i as isize)).end as isize)).pts
                })
            })
        } else {
            (*logo_block.offset(i as isize)).end as libc::c_double / fps
        }) - (if !frame.is_null() {
            (if (*logo_block.offset(i as isize)).start <= 0 as libc::c_int {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if (*logo_block.offset(i as isize)).start >= framenum_real {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset((*logo_block.offset(i as isize)).start as isize)).pts
                })
            })
        } else {
            (*logo_block.offset(i as isize)).start as libc::c_double / fps
        }) > max_nonlogo_block_length as libc::c_double
        {
            cl = (if !frame.is_null() {
                (if cblock[f as usize].f_end <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[f as usize].f_end >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[f as usize].f_end as isize)).pts
                    })
                })
            } else {
                cblock[f as usize].f_end as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if (*logo_block.offset(i as isize)).start <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*logo_block.offset(i as isize)).start >= framenum_real {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((*logo_block.offset(i as isize)).start as isize)).pts
                    })
                })
            } else {
                (*logo_block.offset(i as isize)).start as libc::c_double / fps
            });
            if cl < cblock[f as usize].length / 10 as libc::c_int as libc::c_double {
                if cl > logo_overshoot {
                    logo_overshoot = cl;
                }
            }
            cl = (if !frame.is_null() {
                (if (*logo_block.offset(i as isize)).end <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*logo_block.offset(i as isize)).end >= framenum_real {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset((*logo_block.offset(i as isize)).end as isize)).pts
                    })
                })
            } else {
                (*logo_block.offset(i as isize)).end as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if cblock[t as usize].f_start <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if cblock[t as usize].f_start >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(cblock[t as usize].f_start as isize)).pts
                    })
                })
            } else {
                cblock[t as usize].f_start as libc::c_double / fps
            });
            if cl < cblock[t as usize].length / 10 as libc::c_int as libc::c_double {
                if cl > logo_overshoot {
                    logo_overshoot = cl;
                }
            }
        }
        i += 1;
    }
    if logo_overshoot > 0 as libc::c_int as libc::c_double {
        logo_overshoot = logo_overshoot + 1 as libc::c_int as libc::c_double + shrink_logo;
    } else {
        logo_overshoot = shrink_logo;
    };
}
#[no_mangle]
pub unsafe extern "C" fn PrintCCBlocks() {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    Debug(
        2 as libc::c_int,
        b"Combining CC Blocks...\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    i = (cc_block_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
    while i > 0 as libc::c_int {
        if (if !frame.is_null() {
            (if (*cc_block.offset(i as isize)).end_frame <= 0 as libc::c_int as libc::c_long {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if (*cc_block.offset(i as isize)).end_frame >= framenum_real as libc::c_long {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset((*cc_block.offset(i as isize)).end_frame as isize)).pts
                })
            })
        } else {
            (*cc_block.offset(i as isize)).end_frame as libc::c_double / fps
        }) - (if !frame.is_null() {
            (if (*cc_block.offset(i as isize)).start_frame <= 0 as libc::c_int as libc::c_long {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if (*cc_block.offset(i as isize)).start_frame >= framenum_real as libc::c_long {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset((*cc_block.offset(i as isize)).start_frame as isize)).pts
                })
            })
        } else {
            (*cc_block.offset(i as isize)).start_frame as libc::c_double / fps
        }) < 1.0f64
        {
            Debug(
                4 as libc::c_int,
                b"Removing cc cblock %i because the length is %.2f.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                i,
                (if !frame.is_null() {
                    (if (*cc_block.offset(i as isize)).end_frame <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*cc_block.offset(i as isize)).end_frame
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((*cc_block.offset(i as isize)).end_frame as isize)).pts
                        })
                    })
                } else {
                    (*cc_block.offset(i as isize)).end_frame as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if (*cc_block.offset(i as isize)).start_frame
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*cc_block.offset(i as isize)).start_frame
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((*cc_block.offset(i as isize)).start_frame as isize)).pts
                        })
                    })
                } else {
                    (*cc_block.offset(i as isize)).start_frame as libc::c_double / fps
                }),
            );
            j = i;
            while (j as libc::c_long) < cc_block_count - 1 as libc::c_int as libc::c_long {
                (*cc_block.offset(j as isize)).start_frame =
                    (*cc_block.offset((j + 1 as libc::c_int) as isize)).start_frame;
                (*cc_block.offset(j as isize)).end_frame =
                    (*cc_block.offset((j + 1 as libc::c_int) as isize)).end_frame;
                (*cc_block.offset(j as isize)).type_0 =
                    (*cc_block.offset((j + 1 as libc::c_int) as isize)).type_0;
                j += 1;
            }
            cc_block_count -= 1;
        }
        i -= 1;
    }
    Debug(
        2 as libc::c_int,
        b"CC's detected on the following frames - %i total blocks\n--------------------------------------\n\0"
            as *const u8 as *const libc::c_char as *mut libc::c_char,
        cc_block_count,
    );
    Debug(
        2 as libc::c_int,
        b" 0 - CC start - %6i\tend - %6i\ttype - %s\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        (*cc_block.offset(0 as libc::c_int as isize)).start_frame,
        (*cc_block.offset(0 as libc::c_int as isize)).end_frame,
        CCTypeToStr((*cc_block.offset(0 as libc::c_int as isize)).type_0),
    );
    Debug(
        2 as libc::c_int,
        b"\tlength - %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        dblSecondsToStrMinutes(
            (if !frame.is_null() {
                (if (*cc_block.offset(0 as libc::c_int as isize)).end_frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*cc_block.offset(0 as libc::c_int as isize)).end_frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(
                            (*cc_block.offset(0 as libc::c_int as isize)).end_frame as isize,
                        ))
                        .pts
                    })
                })
            } else {
                (*cc_block.offset(0 as libc::c_int as isize)).end_frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if (*cc_block.offset(0 as libc::c_int as isize)).start_frame
                    <= 0 as libc::c_int as libc::c_long
                {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if (*cc_block.offset(0 as libc::c_int as isize)).start_frame
                        >= framenum_real as libc::c_long
                    {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(
                            (*cc_block.offset(0 as libc::c_int as isize)).start_frame as isize,
                        ))
                        .pts
                    })
                })
            } else {
                (*cc_block.offset(0 as libc::c_int as isize)).start_frame as libc::c_double / fps
            }),
        ),
    );
    cc_count[(*cc_block.offset(0 as libc::c_int as isize)).type_0 as usize] +=
        (*cc_block.offset(0 as libc::c_int as isize)).end_frame
            - (*cc_block.offset(0 as libc::c_int as isize)).start_frame
            + 1 as libc::c_int as libc::c_long;
    i = 1 as libc::c_int;
    while (i as libc::c_long) < cc_block_count {
        Debug(
            2 as libc::c_int,
            b"%2i - CC start - %6i\tend - %6i\ttype - %s\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            i,
            (*cc_block.offset(i as isize)).start_frame,
            (*cc_block.offset(i as isize)).end_frame,
            CCTypeToStr((*cc_block.offset(i as isize)).type_0),
        );
        Debug(
            2 as libc::c_int,
            b"\tlength - %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            dblSecondsToStrMinutes(
                (if !frame.is_null() {
                    (if (*cc_block.offset(i as isize)).end_frame <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*cc_block.offset(i as isize)).end_frame
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((*cc_block.offset(i as isize)).end_frame as isize)).pts
                        })
                    })
                } else {
                    (*cc_block.offset(i as isize)).end_frame as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if (*cc_block.offset(i as isize)).start_frame
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*cc_block.offset(i as isize)).start_frame
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset((*cc_block.offset(i as isize)).start_frame as isize)).pts
                        })
                    })
                } else {
                    (*cc_block.offset(i as isize)).start_frame as libc::c_double / fps
                }),
            ),
        );
        cc_count[(*cc_block.offset(i as isize)).type_0 as usize] +=
            (*cc_block.offset(i as isize)).end_frame - (*cc_block.offset(i as isize)).start_frame
                + 1 as libc::c_int as libc::c_long;
        i += 1;
    }
    Debug(
        2 as libc::c_int,
        b"\nCaption sums\n---------------------------\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
    );
    Debug(
        2 as libc::c_int,
        b"Pop on captions:   %6i:%5.2f - %s\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        cc_count[2 as libc::c_int as usize],
        cc_count[2 as libc::c_int as usize] as libc::c_double / framesprocessed as libc::c_double
            * 100.0f64,
        dblSecondsToStrMinutes(cc_count[2 as libc::c_int as usize] as libc::c_double / fps),
    );
    Debug(
        2 as libc::c_int,
        b"Roll up captions:  %6i:%5.2f - %s\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        cc_count[1 as libc::c_int as usize],
        cc_count[1 as libc::c_int as usize] as libc::c_double / framesprocessed as libc::c_double
            * 100.0f64,
        dblSecondsToStrMinutes(cc_count[1 as libc::c_int as usize] as libc::c_double / fps),
    );
    Debug(
        2 as libc::c_int,
        b"Paint on captions: %6i:%5.2f - %s\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        cc_count[3 as libc::c_int as usize],
        cc_count[3 as libc::c_int as usize] as libc::c_double / framesprocessed as libc::c_double
            * 100.0f64,
        dblSecondsToStrMinutes(cc_count[3 as libc::c_int as usize] as libc::c_double / fps),
    );
    Debug(
        2 as libc::c_int,
        b"No captions:       %6i:%5.2f - %s\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        cc_count[0 as libc::c_int as usize],
        cc_count[0 as libc::c_int as usize] as libc::c_double / framesprocessed as libc::c_double
            * 100.0f64,
        dblSecondsToStrMinutes(cc_count[0 as libc::c_int as usize] as libc::c_double / fps),
    );
    i = 0 as libc::c_int;
    while i <= 4 as libc::c_int {
        if cc_count[i as usize] > cc_count[most_cc_type as usize] {
            most_cc_type = i;
        }
        i += 1;
    }
    Debug(
        2 as libc::c_int,
        b"The %s type of closed captions were determined to be the most common.\n\0" as *const u8
            as *const libc::c_char as *mut libc::c_char,
        CCTypeToStr(most_cc_type),
    );
}
#[no_mangle]
pub unsafe extern "C" fn EdgeDetect(
    mut frame_ptr_0: *mut libc::c_uchar,
    mut maskNumber: libc::c_int,
) {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    hedge_count = 0 as libc::c_int;
    vedge_count = 0 as libc::c_int;
    if aggressive_logo_rejection == 1 as libc::c_int {
        x = edge_radius + border + 4 as libc::c_int * edge_step;
        while x < videowidth - edge_radius - border - 4 as libc::c_int * edge_step {
            let mut y_max_test: libc::c_int = if subtitles != 0 {
                height / 2 as libc::c_int
            } else {
                height - edge_radius - border - 4 as libc::c_int * edge_step
            };
            let mut y_step_test: libc::c_int = height / 3 as libc::c_int;
            y = if logo_at_bottom != 0 {
                height / 2 as libc::c_int
            } else {
                edge_radius + border + 4 as libc::c_int * edge_step
            };
            while y < y_max_test {
                if abs(
                    *frame_ptr_0.offset((y * width + x - edge_radius) as isize) as libc::c_int
                        - *frame_ptr_0.offset((y * width + x + edge_radius) as isize)
                            as libc::c_int,
                ) >= edge_level_threshold
                {
                    if (hor_edgecount[(y * width + x) as usize] as libc::c_int) < num_logo_buffers {
                        hor_edgecount[(y * width + x) as usize] =
                            (hor_edgecount[(y * width + x) as usize]).wrapping_add(1);
                    } else {
                        edge_count += 1;
                    }
                } else {
                    hor_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                }
                if abs(
                    *frame_ptr_0.offset(((y - edge_radius) * width + x) as isize) as libc::c_int
                        - *frame_ptr_0.offset(((y + edge_radius) * width + x) as isize)
                            as libc::c_int,
                ) >= edge_level_threshold
                {
                    if (ver_edgecount[(y * width + x) as usize] as libc::c_int) < num_logo_buffers {
                        ver_edgecount[(y * width + x) as usize] =
                            (ver_edgecount[(y * width + x) as usize]).wrapping_add(1);
                    } else {
                        edge_count += 1;
                    }
                } else {
                    ver_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                }
                y = if y == y_step_test {
                    2 as libc::c_int * height / 3 as libc::c_int
                } else {
                    y + edge_step
                };
            }
            x = if x == videowidth / 3 as libc::c_int {
                2 as libc::c_int * videowidth / 3 as libc::c_int
            } else {
                x + edge_step
            };
        }
    } else if aggressive_logo_rejection == 2 as libc::c_int {
        x = edge_radius + border + 4 as libc::c_int * edge_step;
        while x < videowidth - edge_radius - border - 4 as libc::c_int * edge_step {
            let mut y_max_test_0: libc::c_int = if subtitles != 0 {
                height / 2 as libc::c_int
            } else {
                height - edge_radius - border - 4 as libc::c_int * edge_step
            };
            let mut y_step_test_0: libc::c_int = height / 3 as libc::c_int;
            y = if logo_at_bottom != 0 {
                height / 2 as libc::c_int
            } else {
                edge_radius + border + 4 as libc::c_int * edge_step
            };
            while y < y_max_test_0 {
                if abs(*frame_ptr_0
                    .offset((y * width + x - edge_radius - 1 as libc::c_int) as isize)
                    as libc::c_int
                    + *frame_ptr_0.offset((y * width + x - edge_radius) as isize) as libc::c_int
                    + *frame_ptr_0.offset((y * width + x - edge_radius + 1 as libc::c_int) as isize)
                        as libc::c_int
                    - (*frame_ptr_0
                        .offset((y * width + x + edge_radius - 1 as libc::c_int) as isize)
                        as libc::c_int
                        + *frame_ptr_0.offset((y * width + x + edge_radius) as isize)
                            as libc::c_int
                        + *frame_ptr_0
                            .offset((y * width + x + edge_radius + 1 as libc::c_int) as isize)
                            as libc::c_int))
                    / 3 as libc::c_int
                    >= edge_level_threshold
                {
                    if (hor_edgecount[(y * width + x) as usize] as libc::c_int) < num_logo_buffers {
                        hor_edgecount[(y * width + x) as usize] =
                            (hor_edgecount[(y * width + x) as usize]).wrapping_add(1);
                    } else {
                        edge_count += 1;
                    }
                } else {
                    hor_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                }
                if abs(*frame_ptr_0
                    .offset(((y - edge_radius - 1 as libc::c_int) * width + x) as isize)
                    as libc::c_int
                    + *frame_ptr_0.offset(((y - edge_radius) * width + x) as isize) as libc::c_int
                    + *frame_ptr_0
                        .offset(((y - edge_radius + 1 as libc::c_int) * width + x) as isize)
                        as libc::c_int
                    - (*frame_ptr_0
                        .offset(((y + edge_radius - 1 as libc::c_int) * width + x) as isize)
                        as libc::c_int
                        + *frame_ptr_0.offset(((y + edge_radius) * width + x) as isize)
                            as libc::c_int
                        + *frame_ptr_0
                            .offset(((y + edge_radius + 1 as libc::c_int) * width + x) as isize)
                            as libc::c_int))
                    / 3 as libc::c_int
                    >= edge_level_threshold
                {
                    if (ver_edgecount[(y * width + x) as usize] as libc::c_int) < num_logo_buffers {
                        ver_edgecount[(y * width + x) as usize] =
                            (ver_edgecount[(y * width + x) as usize]).wrapping_add(1);
                    } else {
                        edge_count += 1;
                    }
                } else {
                    ver_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                }
                y = if y == y_step_test_0 {
                    2 as libc::c_int * height / 3 as libc::c_int
                } else {
                    y + edge_step
                };
            }
            x = if x == videowidth / 3 as libc::c_int {
                2 as libc::c_int * videowidth / 3 as libc::c_int
            } else {
                x + edge_step
            };
        }
    } else if aggressive_logo_rejection == 3 as libc::c_int {
        x = edge_radius + border + 4 as libc::c_int * edge_step;
        while x < videowidth - edge_radius - border - 4 as libc::c_int * edge_step {
            let mut y_max_test_1: libc::c_int = if subtitles != 0 {
                height / 2 as libc::c_int
            } else {
                height - edge_radius - border - 4 as libc::c_int * edge_step
            };
            let mut y_step_test_1: libc::c_int = height / 3 as libc::c_int;
            y = if logo_at_bottom != 0 {
                height / 2 as libc::c_int
            } else {
                edge_radius + border + 4 as libc::c_int * edge_step
            };
            while y < y_max_test_1 {
                if abs(
                    *frame_ptr_0.offset(((y - edge_radius) * width + x - edge_radius) as isize)
                        as libc::c_int
                        - *frame_ptr_0
                            .offset(((y - edge_radius) * width + x + edge_radius) as isize)
                            as libc::c_int
                        + *frame_ptr_0.offset((y * width + x - edge_radius) as isize)
                            as libc::c_int
                        - *frame_ptr_0.offset((y * width + x + edge_radius) as isize)
                            as libc::c_int
                        + *frame_ptr_0
                            .offset(((y + edge_radius) * width + x - edge_radius) as isize)
                            as libc::c_int
                        - *frame_ptr_0
                            .offset(((y + edge_radius) * width + x + edge_radius) as isize)
                            as libc::c_int,
                ) >= edge_level_threshold
                {
                    if (hor_edgecount[(y * width + x) as usize] as libc::c_int) < num_logo_buffers {
                        hor_edgecount[(y * width + x) as usize] =
                            (hor_edgecount[(y * width + x) as usize]).wrapping_add(1);
                    } else {
                        edge_count += 1;
                    }
                } else {
                    hor_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                }
                if abs(
                    *frame_ptr_0.offset(((y - edge_radius) * width + x - edge_radius) as isize)
                        as libc::c_int
                        - *frame_ptr_0
                            .offset(((y + edge_radius) * width + x - edge_radius) as isize)
                            as libc::c_int
                        + *frame_ptr_0.offset(((y - edge_radius) * width + x) as isize)
                            as libc::c_int
                        - *frame_ptr_0.offset(((y + edge_radius) * width + x) as isize)
                            as libc::c_int
                        + *frame_ptr_0
                            .offset(((y - edge_radius) * width + x + edge_radius) as isize)
                            as libc::c_int
                        - *frame_ptr_0
                            .offset(((y + edge_radius) * width + x + edge_radius) as isize)
                            as libc::c_int,
                ) >= edge_level_threshold
                {
                    if (ver_edgecount[(y * width + x) as usize] as libc::c_int) < num_logo_buffers {
                        ver_edgecount[(y * width + x) as usize] =
                            (ver_edgecount[(y * width + x) as usize]).wrapping_add(1);
                    } else {
                        edge_count += 1;
                    }
                } else {
                    ver_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                }
                y = if y == y_step_test_1 {
                    2 as libc::c_int * height / 3 as libc::c_int
                } else {
                    y + edge_step
                };
            }
            x = if x == videowidth / 3 as libc::c_int {
                2 as libc::c_int * videowidth / 3 as libc::c_int
            } else {
                x + edge_step
            };
        }
    } else if aggressive_logo_rejection == 4 as libc::c_int {
        x = edge_radius + border + 4 as libc::c_int * edge_step;
        while x < videowidth - edge_radius - border - 4 as libc::c_int * edge_step {
            let mut y_max_test_2: libc::c_int = if subtitles != 0 {
                height / 2 as libc::c_int
            } else {
                height - edge_radius - border - 4 as libc::c_int * edge_step
            };
            let mut y_step_test_2: libc::c_int = height / 3 as libc::c_int;
            y = if logo_at_bottom != 0 {
                height / 2 as libc::c_int
            } else {
                edge_radius + border + 4 as libc::c_int * edge_step
            };
            while y < y_max_test_2 {
                if (*frame_ptr_0.offset((y * width + x - edge_radius) as isize) as libc::c_int)
                    < 200 as libc::c_int
                    || (*frame_ptr_0.offset((y * width + x + edge_radius) as isize) as libc::c_int)
                        < 200 as libc::c_int
                {
                    if abs(*frame_ptr_0.offset((y * width + x - edge_radius) as isize)
                        as libc::c_int
                        - *frame_ptr_0.offset((y * width + x) as isize) as libc::c_int)
                        >= edge_level_threshold
                        || abs(*frame_ptr_0.offset((y * width + x + edge_radius) as isize)
                            as libc::c_int
                            - *frame_ptr_0.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                    {
                        if (hor_edgecount[(y * width + x) as usize] as libc::c_int)
                            < num_logo_buffers
                        {
                            hor_edgecount[(y * width + x) as usize] =
                                (hor_edgecount[(y * width + x) as usize]).wrapping_add(1);
                        } else {
                            edge_count += 1;
                        }
                    } else if (*frame_ptr_0.offset((y * width + x) as isize) as libc::c_int)
                        < 200 as libc::c_int
                    {
                        hor_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                    }
                }
                if (*frame_ptr_0.offset(((y - edge_radius) * width + x) as isize) as libc::c_int)
                    < 200 as libc::c_int
                    || (*frame_ptr_0.offset(((y + edge_radius) * width + x) as isize)
                        as libc::c_int)
                        < 200 as libc::c_int
                {
                    if abs(
                        *frame_ptr_0.offset(((y - edge_radius) * width + x) as isize)
                            as libc::c_int
                            - *frame_ptr_0.offset((y * width + x) as isize) as libc::c_int,
                    ) >= edge_level_threshold
                        || abs(
                            *frame_ptr_0.offset(((y + edge_radius) * width + x) as isize)
                                as libc::c_int
                                - *frame_ptr_0.offset((y * width + x) as isize) as libc::c_int,
                        ) >= edge_level_threshold
                    {
                        if (ver_edgecount[(y * width + x) as usize] as libc::c_int)
                            < num_logo_buffers
                        {
                            ver_edgecount[(y * width + x) as usize] =
                                (ver_edgecount[(y * width + x) as usize]).wrapping_add(1);
                        } else {
                            edge_count += 1;
                        }
                    } else if (*frame_ptr_0.offset((y * width + x) as isize) as libc::c_int)
                        < 200 as libc::c_int
                    {
                        ver_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                    }
                }
                y = if y == y_step_test_2 {
                    2 as libc::c_int * height / 3 as libc::c_int
                } else {
                    y + edge_step
                };
            }
            x = if x == videowidth / 3 as libc::c_int {
                2 as libc::c_int * videowidth / 3 as libc::c_int
            } else {
                x + edge_step
            };
        }
    } else {
        x = edge_radius + border + 4 as libc::c_int * edge_step;
        while x < videowidth - edge_radius - border - 4 as libc::c_int * edge_step {
            let mut y_max_test_3: libc::c_int = if subtitles != 0 {
                height / 2 as libc::c_int
            } else {
                height - edge_radius - border - 4 as libc::c_int * edge_step
            };
            let mut y_step_test_3: libc::c_int = height / 3 as libc::c_int;
            y = if logo_at_bottom != 0 {
                height / 2 as libc::c_int
            } else {
                edge_radius + border + 4 as libc::c_int * edge_step
            };
            while y < y_max_test_3 {
                if (*frame_ptr_0.offset((y * width + x - edge_radius) as isize) as libc::c_int)
                    < 200 as libc::c_int
                    || (*frame_ptr_0.offset((y * width + x + edge_radius) as isize) as libc::c_int)
                        < 200 as libc::c_int
                {
                    if abs(*frame_ptr_0.offset((y * width + x - edge_radius) as isize)
                        as libc::c_int
                        - *frame_ptr_0.offset((y * width + x) as isize) as libc::c_int)
                        >= edge_level_threshold
                        || abs(*frame_ptr_0.offset((y * width + x + edge_radius) as isize)
                            as libc::c_int
                            - *frame_ptr_0.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                    {
                        if (hor_edgecount[(y * width + x) as usize] as libc::c_int)
                            < num_logo_buffers
                        {
                            hor_edgecount[(y * width + x) as usize] =
                                (hor_edgecount[(y * width + x) as usize]).wrapping_add(1);
                        } else {
                            edge_count += 1;
                        }
                    } else {
                        hor_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                    }
                }
                if (*frame_ptr_0.offset(((y - edge_radius) * width + x) as isize) as libc::c_int)
                    < 200 as libc::c_int
                    || (*frame_ptr_0.offset(((y + edge_radius) * width + x) as isize)
                        as libc::c_int)
                        < 200 as libc::c_int
                {
                    if abs(
                        *frame_ptr_0.offset(((y - edge_radius) * width + x) as isize)
                            as libc::c_int
                            - *frame_ptr_0.offset((y * width + x) as isize) as libc::c_int,
                    ) >= edge_level_threshold
                        || abs(
                            *frame_ptr_0.offset(((y + edge_radius) * width + x) as isize)
                                as libc::c_int
                                - *frame_ptr_0.offset((y * width + x) as isize) as libc::c_int,
                        ) >= edge_level_threshold
                    {
                        if (ver_edgecount[(y * width + x) as usize] as libc::c_int)
                            < num_logo_buffers
                        {
                            ver_edgecount[(y * width + x) as usize] =
                                (ver_edgecount[(y * width + x) as usize]).wrapping_add(1);
                        } else {
                            edge_count += 1;
                        }
                    } else {
                        ver_edgecount[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                    }
                }
                y = if y == y_step_test_3 {
                    2 as libc::c_int * height / 3 as libc::c_int
                } else {
                    y + edge_step
                };
            }
            x = if x == videowidth / 3 as libc::c_int {
                2 as libc::c_int * videowidth / 3 as libc::c_int
            } else {
                x + edge_step
            };
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn CheckStationLogoEdge(mut testFrame: *mut libc::c_uchar) -> libc::c_double {
    let mut index: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut testEdges: libc::c_int = 0 as libc::c_int;
    let mut goodEdges: libc::c_int = 0 as libc::c_int;
    currentGoodEdge = 0.0f64;
    if !(videowidth < clogoMinX || height < clogoMinY) {
        if aggressive_logo_rejection == 1 as libc::c_int {
            y = clogoMinY;
            while y <= clogoMaxY {
                x = clogoMinX;
                while x <= clogoMaxX {
                    index = y * width + x;
                    if choriz_edgemask[index as usize] != 0 {
                        if abs(*testFrame.offset((y * width + x - edge_radius) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x + edge_radius) as isize)
                                as libc::c_int)
                            >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    if cvert_edgemask[index as usize] != 0 {
                        if abs(*testFrame.offset(((y - edge_radius) * width + x) as isize)
                            as libc::c_int
                            - *testFrame.offset(((y + edge_radius) * width + x) as isize)
                                as libc::c_int)
                            >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    x += edge_step;
                }
                y += edge_step;
            }
        } else if aggressive_logo_rejection == 2 as libc::c_int {
            y = clogoMinY;
            while y <= clogoMaxY {
                x = clogoMinX;
                while x <= clogoMaxX {
                    index = y * width + x;
                    if choriz_edgemask[index as usize] != 0 {
                        if abs(*testFrame
                            .offset((y * width + x - edge_radius - 1 as libc::c_int) as isize)
                            as libc::c_int
                            + *testFrame.offset((y * width + x - edge_radius) as isize)
                                as libc::c_int
                            + *testFrame
                                .offset((y * width + x - edge_radius + 1 as libc::c_int) as isize)
                                as libc::c_int
                            - (*testFrame
                                .offset((y * width + x + edge_radius - 1 as libc::c_int) as isize)
                                as libc::c_int
                                + *testFrame.offset((y * width + x + edge_radius) as isize)
                                    as libc::c_int
                                + *testFrame.offset(
                                    (y * width + x + edge_radius + 1 as libc::c_int) as isize,
                                ) as libc::c_int))
                            / 3 as libc::c_int
                            >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    if cvert_edgemask[index as usize] != 0 {
                        if abs(*testFrame
                            .offset(((y - edge_radius - 1 as libc::c_int) * width + x) as isize)
                            as libc::c_int
                            + *testFrame.offset(((y - edge_radius) * width + x) as isize)
                                as libc::c_int
                            + *testFrame
                                .offset(((y - edge_radius + 1 as libc::c_int) * width + x) as isize)
                                as libc::c_int
                            - (*testFrame
                                .offset(((y + edge_radius - 1 as libc::c_int) * width + x) as isize)
                                as libc::c_int
                                + *testFrame.offset(((y + edge_radius) * width + x) as isize)
                                    as libc::c_int
                                + *testFrame.offset(
                                    ((y + edge_radius + 1 as libc::c_int) * width + x) as isize,
                                ) as libc::c_int))
                            / 3 as libc::c_int
                            >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    x += edge_step;
                }
                y += edge_step;
            }
        } else if aggressive_logo_rejection == 3 as libc::c_int {
            y = clogoMinY;
            while y <= clogoMaxY {
                x = clogoMinX;
                while x <= clogoMaxX {
                    index = y * width + x;
                    if choriz_edgemask[index as usize] != 0 {
                        if abs(*testFrame
                            .offset(((y - edge_radius) * width + x - edge_radius) as isize)
                            as libc::c_int
                            - *testFrame
                                .offset(((y - edge_radius) * width + x + edge_radius) as isize)
                                as libc::c_int
                            + *testFrame.offset((y * width + x - edge_radius) as isize)
                                as libc::c_int
                            - *testFrame.offset((y * width + x + edge_radius) as isize)
                                as libc::c_int
                            + *testFrame
                                .offset(((y + edge_radius) * width + x - edge_radius) as isize)
                                as libc::c_int
                            - *testFrame
                                .offset(((y + edge_radius) * width + x + edge_radius) as isize)
                                as libc::c_int)
                            >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    if cvert_edgemask[index as usize] != 0 {
                        if abs(*testFrame
                            .offset(((y - edge_radius) * width + x - edge_radius) as isize)
                            as libc::c_int
                            - *testFrame
                                .offset(((y + edge_radius) * width + x - edge_radius) as isize)
                                as libc::c_int
                            + *testFrame.offset(((y - edge_radius) * width + x) as isize)
                                as libc::c_int
                            - *testFrame.offset(((y + edge_radius) * width + x) as isize)
                                as libc::c_int
                            + *testFrame
                                .offset(((y - edge_radius) * width + x + edge_radius) as isize)
                                as libc::c_int
                            - *testFrame
                                .offset(((y + edge_radius) * width + x + edge_radius) as isize)
                                as libc::c_int)
                            >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    x += edge_step;
                }
                y += edge_step;
            }
        } else if aggressive_logo_rejection == 4 as libc::c_int {
            y = clogoMinY;
            while y <= clogoMaxY {
                x = clogoMinX;
                while x <= clogoMaxX {
                    index = y * width + x;
                    if choriz_edgemask[index as usize] as libc::c_int != 0
                        && (*testFrame.offset(index as isize) as libc::c_int) < 200 as libc::c_int
                    {
                        if abs(*testFrame.offset((y * width + x - edge_radius) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                            || abs(*testFrame.offset((y * width + x + edge_radius) as isize)
                                as libc::c_int
                                - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                                >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    if cvert_edgemask[index as usize] as libc::c_int != 0
                        && (*testFrame.offset(index as isize) as libc::c_int) < 200 as libc::c_int
                    {
                        if abs(*testFrame.offset(((y - edge_radius) * width + x) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                            || abs(*testFrame.offset(((y + edge_radius) * width + x) as isize)
                                as libc::c_int
                                - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                                >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    x += edge_step;
                }
                y += edge_step;
            }
        } else {
            y = clogoMinY;
            while y <= clogoMaxY {
                x = clogoMinX;
                while x <= clogoMaxX {
                    index = y * width + x;
                    if choriz_edgemask[index as usize] != 0 {
                        if abs(*testFrame.offset((y * width + x - edge_radius) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                            || abs(*testFrame.offset((y * width + x + edge_radius) as isize)
                                as libc::c_int
                                - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                                >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    if cvert_edgemask[index as usize] != 0 {
                        if abs(*testFrame.offset(((y - edge_radius) * width + x) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                            || abs(*testFrame.offset(((y + edge_radius) * width + x) as isize)
                                as libc::c_int
                                - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                                >= edge_level_threshold
                        {
                            goodEdges += 1;
                        }
                        testEdges += 1;
                    }
                    x += edge_step;
                }
                y += edge_step;
            }
        }
    }
    if testEdges == 0 as libc::c_int {
        return 0.5f64;
    }
    return goodEdges as libc::c_double / testEdges as libc::c_double;
}
#[no_mangle]
pub unsafe extern "C" fn DoubleCheckStationLogoEdge(
    mut testFrame: *mut libc::c_uchar,
) -> libc::c_double {
    let mut index: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut testEdges: libc::c_int = 0 as libc::c_int;
    let mut goodEdges: libc::c_int = 0 as libc::c_int;
    currentGoodEdge = 0.0f64;
    if aggressive_logo_rejection == 1 as libc::c_int {
        y = tlogoMinY;
        while y <= tlogoMaxY {
            x = tlogoMinX;
            while x <= tlogoMaxX {
                index = y * width + x;
                if thoriz_edgemask[index as usize] != 0 {
                    if abs(
                        *testFrame.offset((y * width + x - edge_radius) as isize) as libc::c_int
                            - *testFrame.offset((y * width + x + edge_radius) as isize)
                                as libc::c_int,
                    ) >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                if tvert_edgemask[index as usize] != 0 {
                    if abs(*testFrame.offset(((y - edge_radius) * width + x) as isize)
                        as libc::c_int
                        - *testFrame.offset(((y + edge_radius) * width + x) as isize)
                            as libc::c_int)
                        >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                x += edge_step;
            }
            y += edge_step;
        }
    } else if aggressive_logo_rejection == 2 as libc::c_int {
        y = tlogoMinY;
        while y <= tlogoMaxY {
            x = tlogoMinX;
            while x <= tlogoMaxX {
                index = y * width + x;
                if thoriz_edgemask[index as usize] != 0 {
                    if abs(*testFrame
                        .offset((y * width + x - edge_radius - 1 as libc::c_int) as isize)
                        as libc::c_int
                        + *testFrame.offset((y * width + x - edge_radius) as isize) as libc::c_int
                        + *testFrame
                            .offset((y * width + x - edge_radius + 1 as libc::c_int) as isize)
                            as libc::c_int
                        - (*testFrame
                            .offset((y * width + x + edge_radius - 1 as libc::c_int) as isize)
                            as libc::c_int
                            + *testFrame.offset((y * width + x + edge_radius) as isize)
                                as libc::c_int
                            + *testFrame
                                .offset((y * width + x + edge_radius + 1 as libc::c_int) as isize)
                                as libc::c_int))
                        / 3 as libc::c_int
                        >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                if tvert_edgemask[index as usize] != 0 {
                    if abs(*testFrame
                        .offset(((y - edge_radius - 1 as libc::c_int) * width + x) as isize)
                        as libc::c_int
                        + *testFrame.offset(((y - edge_radius) * width + x) as isize)
                            as libc::c_int
                        + *testFrame
                            .offset(((y - edge_radius + 1 as libc::c_int) * width + x) as isize)
                            as libc::c_int
                        - (*testFrame
                            .offset(((y + edge_radius - 1 as libc::c_int) * width + x) as isize)
                            as libc::c_int
                            + *testFrame.offset(((y + edge_radius) * width + x) as isize)
                                as libc::c_int
                            + *testFrame
                                .offset(((y + edge_radius + 1 as libc::c_int) * width + x) as isize)
                                as libc::c_int))
                        / 3 as libc::c_int
                        >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                x += edge_step;
            }
            y += edge_step;
        }
    } else if aggressive_logo_rejection == 3 as libc::c_int {
        y = tlogoMinY;
        while y <= tlogoMaxY {
            x = tlogoMinX;
            while x <= tlogoMaxX {
                index = y * width + x;
                if thoriz_edgemask[index as usize] != 0 {
                    if abs(
                        *testFrame.offset(((y - edge_radius) * width + x - edge_radius) as isize)
                            as libc::c_int
                            - *testFrame
                                .offset(((y - edge_radius) * width + x + edge_radius) as isize)
                                as libc::c_int
                            + *testFrame.offset((y * width + x - edge_radius) as isize)
                                as libc::c_int
                            - *testFrame.offset((y * width + x + edge_radius) as isize)
                                as libc::c_int
                            + *testFrame
                                .offset(((y + edge_radius) * width + x - edge_radius) as isize)
                                as libc::c_int
                            - *testFrame
                                .offset(((y + edge_radius) * width + x + edge_radius) as isize)
                                as libc::c_int,
                    ) >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                if tvert_edgemask[index as usize] != 0 {
                    if abs(
                        *testFrame.offset(((y - edge_radius) * width + x - edge_radius) as isize)
                            as libc::c_int
                            - *testFrame
                                .offset(((y + edge_radius) * width + x - edge_radius) as isize)
                                as libc::c_int
                            + *testFrame.offset(((y - edge_radius) * width + x) as isize)
                                as libc::c_int
                            - *testFrame.offset(((y + edge_radius) * width + x) as isize)
                                as libc::c_int
                            + *testFrame
                                .offset(((y - edge_radius) * width + x + edge_radius) as isize)
                                as libc::c_int
                            - *testFrame
                                .offset(((y + edge_radius) * width + x + edge_radius) as isize)
                                as libc::c_int,
                    ) >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                x += edge_step;
            }
            y += edge_step;
        }
    } else if aggressive_logo_rejection == 4 as libc::c_int {
        y = tlogoMinY;
        while y <= tlogoMaxY {
            x = tlogoMinX;
            while x <= tlogoMaxX {
                index = y * width + x;
                if thoriz_edgemask[index as usize] as libc::c_int != 0
                    && (*testFrame.offset(index as isize) as libc::c_int) < 200 as libc::c_int
                {
                    if abs(
                        *testFrame.offset((y * width + x - edge_radius) as isize) as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int,
                    ) >= edge_level_threshold
                        || abs(*testFrame.offset((y * width + x + edge_radius) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                if tvert_edgemask[index as usize] as libc::c_int != 0
                    && (*testFrame.offset(index as isize) as libc::c_int) < 200 as libc::c_int
                {
                    if abs(*testFrame.offset(((y - edge_radius) * width + x) as isize)
                        as libc::c_int
                        - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                        >= edge_level_threshold
                        || abs(*testFrame.offset(((y + edge_radius) * width + x) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                x += edge_step;
            }
            y += edge_step;
        }
    } else {
        y = tlogoMinY;
        while y <= tlogoMaxY {
            x = tlogoMinX;
            while x <= tlogoMaxX {
                index = y * width + x;
                if thoriz_edgemask[index as usize] != 0 {
                    if abs(
                        *testFrame.offset((y * width + x - edge_radius) as isize) as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int,
                    ) >= edge_level_threshold
                        || abs(*testFrame.offset((y * width + x + edge_radius) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                if tvert_edgemask[index as usize] != 0 {
                    if abs(*testFrame.offset(((y - edge_radius) * width + x) as isize)
                        as libc::c_int
                        - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                        >= edge_level_threshold
                        || abs(*testFrame.offset(((y + edge_radius) * width + x) as isize)
                            as libc::c_int
                            - *testFrame.offset((y * width + x) as isize) as libc::c_int)
                            >= edge_level_threshold
                    {
                        goodEdges += 1;
                    }
                    testEdges += 1;
                }
                x += edge_step;
            }
            y += edge_step;
        }
    }
    if testEdges == 0 as libc::c_int {
        return 0.5f64;
    }
    return goodEdges as libc::c_double / testEdges as libc::c_double;
}
#[no_mangle]
pub unsafe extern "C" fn InitProcessLogoTest() {
    logo_block_count = 0 as libc::c_int as libc::c_long;
    logoTrendCounter = 0 as libc::c_int;
    frames_with_logo = 0 as libc::c_int;
    lastLogoTest = 0 as libc::c_int != 0;
    curLogoTest = 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ProcessLogoTest(
    mut framenum_real_0: libc::c_int,
    mut curLogoTest_0: libc::c_int,
    mut close_0: libc::c_int,
) -> bool {
    let mut i: libc::c_int = 0;
    let mut s1: libc::c_double = 0.;
    let mut s2: libc::c_double = 0.;
    if logo_filter > 0 as libc::c_int {
        if close_0 == 0 {
            if framenum_real_0 > logo_filter * 2 as libc::c_int * (fps * logoFreq) as libc::c_int {
                s2 = 0.0f64;
                s1 = s2;
                i = 0 as libc::c_int;
                while i < logo_filter {
                    s1 += (if (*frame.offset(
                        (framenum_real_0
                            - i * (fps * logoFreq) as libc::c_int
                            - logo_filter * (fps * logoFreq) as libc::c_int)
                            as isize,
                    ))
                    .currentGoodEdge
                        - logo_threshold
                        > 0 as libc::c_int as libc::c_double
                    {
                        1 as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    }) as libc::c_double;
                    s2 += (if (*frame
                        .offset((framenum_real_0 - i * (fps * logoFreq) as libc::c_int) as isize))
                    .currentGoodEdge
                        - logo_threshold
                        > 0 as libc::c_int as libc::c_double
                    {
                        1 as libc::c_int
                    } else {
                        -(1 as libc::c_int)
                    }) as libc::c_double;
                    i += 1;
                }
                s1 /= logo_filter as libc::c_double;
                s2 /= logo_filter as libc::c_double;
                i = 0 as libc::c_int;
                while i < (fps * logoFreq) as libc::c_int {
                    (*frame.offset(
                        (framenum_real_0 - logo_filter * (fps * logoFreq) as libc::c_int - i)
                            as isize,
                    ))
                    .logo_filter = s1 + s2;
                    i += 1;
                }
            }
            i = 0 as libc::c_int;
            while i < (fps * logoFreq) as libc::c_int {
                (*frame.offset((framenum_real_0 - i) as isize)).logo_filter = 0.0f64;
                i += 1;
            }
            framenum_real_0 -= logo_filter * (fps * logoFreq) as libc::c_int;
            if framenum_real_0 < 0 as libc::c_int {
                framenum_real_0 = 1 as libc::c_int;
            }
            curLogoTest_0 = if (*frame.offset(framenum_real_0 as isize)).logo_filter > 0.0f64 {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            };
        } else {
            curLogoTest_0 = 0 as libc::c_int;
        }
    }
    if curLogoTest_0 != lastLogoTest as libc::c_int {
        if curLogoTest_0 == 0 {
            lastLogoTest = 0 as libc::c_int != 0;
            logoTrendCounter = 0 as libc::c_int;
            (*logo_block.offset(logo_block_count as isize)).end =
                framenum_real_0 - 1 as libc::c_int * (fps * logoFreq) as libc::c_int;
            if ((*logo_block.offset(logo_block_count as isize)).end
                - (*logo_block.offset(logo_block_count as isize)).start)
                as libc::c_double
                > (2 as libc::c_int * (shrink_logo * fps) as libc::c_int) as libc::c_double
                    + shrink_logo_tail as libc::c_double * fps
            {
                (*logo_block.offset(logo_block_count as isize)).end -= (shrink_logo * fps)
                    as libc::c_int
                    + (shrink_logo_tail as libc::c_double * fps) as libc::c_int;
                (*logo_block.offset(logo_block_count as isize)).start +=
                    (shrink_logo * fps) as libc::c_int;
                frames_with_logo -= 2 as libc::c_int * (fps * logoFreq) as libc::c_int
                    + 2 as libc::c_int * (shrink_logo * fps) as libc::c_int
                    + (shrink_logo_tail as libc::c_double * fps) as libc::c_int;
                if framearray {
                    i = (*logo_block.offset(logo_block_count as isize)).end;
                    if i < 0 as libc::c_int {
                        i = 0 as libc::c_int;
                    }
                    while i < framenum_real_0 {
                        (*frame.offset(i as isize)).logo_present = 0 as libc::c_int != 0;
                        i += 1;
                    }
                }
                Debug(
                    3 as libc::c_int,
                    b"\nEnd logo block %i\tframe %i\tLength - %s\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    logo_block_count,
                    (*logo_block.offset(logo_block_count as isize)).end,
                    dblSecondsToStrMinutes(
                        (if !frame.is_null() {
                            (if (*logo_block.offset(logo_block_count as isize)).end
                                <= 0 as libc::c_int
                            {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if (*logo_block.offset(logo_block_count as isize)).end
                                    >= framenum_real_0
                                {
                                    (*frame.offset((framenum_real_0 - 1 as libc::c_int) as isize))
                                        .pts
                                } else {
                                    (*frame.offset(
                                        (*logo_block.offset(logo_block_count as isize)).end
                                            as isize,
                                    ))
                                    .pts
                                })
                            })
                        } else {
                            (*logo_block.offset(logo_block_count as isize)).end as libc::c_double
                                / fps
                        }) - (if !frame.is_null() {
                            (if (*logo_block.offset(logo_block_count as isize)).start
                                <= 0 as libc::c_int
                            {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if (*logo_block.offset(logo_block_count as isize)).start
                                    >= framenum_real_0
                                {
                                    (*frame.offset((framenum_real_0 - 1 as libc::c_int) as isize))
                                        .pts
                                } else {
                                    (*frame.offset(
                                        (*logo_block.offset(logo_block_count as isize)).start
                                            as isize,
                                    ))
                                    .pts
                                })
                            })
                        } else {
                            (*logo_block.offset(logo_block_count as isize)).start as libc::c_double
                                / fps
                        }),
                    ),
                );
                logo_block_count += 1;
                InitializeLogoBlockArray(logo_block_count);
            } else {
                (*logo_block.offset(logo_block_count as isize)).start = -(1 as libc::c_int);
            }
        } else {
            logoTrendCounter += 1;
            if logoTrendCounter == minHitsForTrend {
                lastLogoTest = 1 as libc::c_int != 0;
                logoTrendCounter = 0 as libc::c_int;
                InitializeLogoBlockArray(logo_block_count + 2 as libc::c_int as libc::c_long);
                (*logo_block
                    .offset((logo_block_count + 1 as libc::c_int as libc::c_long) as isize))
                .start = -(1 as libc::c_int);
                (*logo_block.offset(logo_block_count as isize)).start = framenum_real_0
                    - (fps * logoFreq) as libc::c_int * (minHitsForTrend - 1 as libc::c_int);
                frames_with_logo +=
                    (fps * logoFreq) as libc::c_int * (minHitsForTrend - 1 as libc::c_int);
                if framearray {
                    i = (*logo_block.offset(logo_block_count as isize)).start;
                    while i < framenum_real_0 {
                        (*frame.offset(i as isize)).logo_present = 1 as libc::c_int != 0;
                        i += 1;
                    }
                }
                if logo_block_count == 0 {
                    Debug(
                        3 as libc::c_int,
                        b"\t\t\t\tStart logo cblock %i\tframe %i\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        logo_block_count,
                        (*logo_block.offset(logo_block_count as isize)).start,
                    );
                } else {
                    Debug(
                        3 as libc::c_int,
                        b"\n\t\t\t\tNonlogo Length - %s\nStart logo cblock %i\tframe %i\n\0"
                            as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        dblSecondsToStrMinutes(
                            (if !frame.is_null() {
                                (if (*logo_block.offset(logo_block_count as isize)).start
                                    <= 0 as libc::c_int
                                {
                                    (*frame.offset(1 as libc::c_int as isize)).pts
                                } else {
                                    (if (*logo_block.offset(logo_block_count as isize)).start
                                        >= framenum_real_0
                                    {
                                        (*frame
                                            .offset((framenum_real_0 - 1 as libc::c_int) as isize))
                                        .pts
                                    } else {
                                        (*frame.offset(
                                            (*logo_block.offset(logo_block_count as isize)).start
                                                as isize,
                                        ))
                                        .pts
                                    })
                                })
                            } else {
                                (*logo_block.offset(logo_block_count as isize)).start
                                    as libc::c_double
                                    / fps
                            }) - (if !frame.is_null() {
                                (if (*logo_block.offset(
                                    (logo_block_count - 1 as libc::c_int as libc::c_long) as isize,
                                ))
                                .end <= 0 as libc::c_int
                                {
                                    (*frame.offset(1 as libc::c_int as isize)).pts
                                } else {
                                    (if (*logo_block.offset(
                                        (logo_block_count - 1 as libc::c_int as libc::c_long)
                                            as isize,
                                    ))
                                    .end >= framenum_real_0
                                    {
                                        (*frame
                                            .offset((framenum_real_0 - 1 as libc::c_int) as isize))
                                        .pts
                                    } else {
                                        (*frame.offset(
                                            (*logo_block.offset(
                                                (logo_block_count
                                                    - 1 as libc::c_int as libc::c_long)
                                                    as isize,
                                            ))
                                            .end
                                                as isize,
                                        ))
                                        .pts
                                    })
                                })
                            } else {
                                (*logo_block.offset(
                                    (logo_block_count - 1 as libc::c_int as libc::c_long) as isize,
                                ))
                                .end as libc::c_double
                                    / fps
                            }),
                        ),
                        logo_block_count,
                        (*logo_block.offset(logo_block_count as isize)).start,
                    );
                }
            }
        }
    } else {
        logoTrendCounter = 0 as libc::c_int;
    }
    return lastLogoTest;
}
#[no_mangle]
pub unsafe extern "C" fn ResetLogoBuffers() {
    oldestLogoBuffer = 0 as libc::c_int;
    newestLogoBuffer = oldestLogoBuffer;
    if !logoFrameNum.is_null() {
        if newestLogoBuffer == num_logo_buffers {
            newestLogoBuffer = 0 as libc::c_int;
        }
        *logoFrameNum.offset(newestLogoBuffer as isize) = framenum_real;
        oldestLogoBuffer = 0 as libc::c_int;
    }
}
#[no_mangle]
pub unsafe extern "C" fn FillLogoBuffer() {
    let mut i: libc::c_int = 0;
    newestLogoBuffer += 1;
    if newestLogoBuffer == num_logo_buffers {
        newestLogoBuffer = 0 as libc::c_int;
    }
    *logoFrameNum.offset(newestLogoBuffer as isize) = framenum_real;
    oldestLogoBuffer = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < num_logo_buffers {
        if *logoFrameNum.offset(i as isize) != 0
            && *logoFrameNum.offset(i as isize) < *logoFrameNum.offset(oldestLogoBuffer as isize)
        {
            oldestLogoBuffer = i;
        }
        i += 1;
    }
    i = min(
        logoFrameBufferSize as libc::c_uint as libc::c_int,
        ((width * height) as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
            as libc::c_int,
    );
    memcpy(
        *logoFrameBuffer.offset(newestLogoBuffer as isize) as *mut libc::c_void,
        frame_ptr as *const libc::c_void,
        i as libc::c_ulong,
    );
    EdgeDetect(
        *logoFrameBuffer.offset(newestLogoBuffer as isize),
        newestLogoBuffer,
    );
    if !logoBuffersFull && newestLogoBuffer == num_logo_buffers - 1 as libc::c_int {
        logoBuffersFull = 1 as libc::c_int != 0;
    }
}
#[no_mangle]
pub unsafe extern "C" fn SearchForLogoEdges() -> bool {
    let mut i: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut scale: libc::c_double = height as libc::c_double / 572 as libc::c_int as libc::c_double
        * (videowidth as libc::c_double / 720 as libc::c_int as libc::c_double);
    let mut logoPercentageOfScreen: libc::c_double = 0.;
    let mut LogoIsThere: bool = false;
    let mut sum: libc::c_int = 0;
    let mut tempMinX: libc::c_int = 0;
    let mut tempMaxX: libc::c_int = 0;
    let mut tempMinY: libc::c_int = 0;
    let mut tempMaxY: libc::c_int = 0;
    let mut last_non_logo_frame: libc::c_int = 0;
    let mut logoFound: libc::c_int = 0 as libc::c_int;
    tlogoMinX = edge_radius + border;
    tlogoMaxX = videowidth - edge_radius - border;
    tlogoMinY = edge_radius + border;
    tlogoMaxY = height - edge_radius - border;
    memset(
        thoriz_edgemask.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        (width * height) as libc::c_ulong,
    );
    memset(
        tvert_edgemask.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        (width * height) as libc::c_ulong,
    );
    x = edge_radius + border + 4 as libc::c_int * edge_step;
    while x < videowidth - edge_radius - border - 4 as libc::c_int * edge_step {
        let mut y_max_test: libc::c_int = if subtitles != 0 {
            height / 2 as libc::c_int
        } else {
            height - edge_radius - border - 4 as libc::c_int * edge_step
        };
        let mut y_step_test: libc::c_int = height / 3 as libc::c_int;
        y = if logo_at_bottom != 0 {
            height / 2 as libc::c_int
        } else {
            edge_radius + border + 4 as libc::c_int * edge_step
        };
        while y < y_max_test {
            if hor_edgecount[(y * width + x) as usize] as libc::c_int as libc::c_double
                >= num_logo_buffers as libc::c_double * 0.95f64
            {
                thoriz_edgemask[(y * width + x) as usize] = 1 as libc::c_int as libc::c_uchar;
            }
            if ver_edgecount[(y * width + x) as usize] as libc::c_int as libc::c_double
                >= num_logo_buffers as libc::c_double * 0.95f64
            {
                tvert_edgemask[(y * width + x) as usize] = 1 as libc::c_int as libc::c_uchar;
            }
            y = if y == y_step_test {
                2 as libc::c_int * height / 3 as libc::c_int
            } else {
                y + edge_step
            };
        }
        x = if x == videowidth / 3 as libc::c_int {
            2 as libc::c_int * videowidth / 3 as libc::c_int
        } else {
            x + edge_step
        };
    }
    ClearEdgeMaskArea(thoriz_edgemask.as_mut_ptr(), tvert_edgemask.as_mut_ptr());
    ClearEdgeMaskArea(tvert_edgemask.as_mut_ptr(), thoriz_edgemask.as_mut_ptr());
    SetEdgeMaskArea(thoriz_edgemask.as_mut_ptr());
    tempMinX = tlogoMinX;
    tempMaxX = tlogoMaxX;
    tempMinY = tlogoMinY;
    tempMaxY = tlogoMaxY;
    tlogoMinX = edge_radius + border;
    tlogoMaxX = videowidth - edge_radius - border;
    tlogoMinY = edge_radius + border;
    tlogoMaxY = height - edge_radius - border;
    SetEdgeMaskArea(tvert_edgemask.as_mut_ptr());
    if tempMinX < tlogoMinX {
        tlogoMinX = tempMinX;
    }
    if tempMaxX > tlogoMaxX {
        tlogoMaxX = tempMaxX;
    }
    if tempMinY < tlogoMinY {
        tlogoMinY = tempMinY;
    }
    if tempMaxY > tlogoMaxY {
        tlogoMaxY = tempMaxY;
    }
    edgemask_filled = 1 as libc::c_int;
    logoPercentageOfScreen = ((tlogoMaxY - tlogoMinY) * (tlogoMaxX - tlogoMinX)) as libc::c_double
        / (height * width) as libc::c_double;
    logoPercentageOfScreen > logo_max_percentage_of_screen;
    i = CountEdgePixels();
    if i as libc::c_double
        > 150 as libc::c_int as libc::c_double * scale / edge_step as libc::c_double
    {
        logoPercentageOfScreen = ((tlogoMaxY - tlogoMinY) * (tlogoMaxX - tlogoMinX))
            as libc::c_double
            / (height * width) as libc::c_double;
        if i > 40000 as libc::c_int || logoPercentageOfScreen > logo_max_percentage_of_screen {
            Debug(
                3 as libc::c_int,
                b"Edge count - %i\tPercentage of screen - %.2f%% TOO BIG, CAN'T BE A LOGO.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
                logoPercentageOfScreen * 100 as libc::c_int as libc::c_double,
            );
        } else if logo_min_percentage_of_screen > 0 as libc::c_int as libc::c_double
            && logoPercentageOfScreen < logo_min_percentage_of_screen
        {
            Debug(
                3 as libc::c_int,
                b"Edge count - %i\tPercentage of screen - %.2f%% TOO SMALL, CAN'T BE A LOGO.\n\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                i,
                logoPercentageOfScreen * 100 as libc::c_int as libc::c_double,
            );
        } else {
            Debug(
                3 as libc::c_int,
                b"Edge count - %i\tPercentage of screen - %.2f%%, Check: %i\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                i,
                logoPercentageOfScreen * 100 as libc::c_int as libc::c_double,
                doublCheckLogoCount,
            );
            logoFound = 1 as libc::c_int;
        }
    } else {
        Debug(
            3 as libc::c_int,
            b"Not enough edge count - %i\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            i,
        );
    }
    if logoFound != 0 {
        doublCheckLogoCount += 1;
        Debug(
            3 as libc::c_int,
            b"Double checking - %i\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            doublCheckLogoCount,
        );
        if !(doublCheckLogoCount > 1 as libc::c_int) {
            logoFound = 0 as libc::c_int;
        }
    } else {
        doublCheckLogoCount = 0 as libc::c_int;
    }
    sum = 0 as libc::c_int;
    oldestLogoBuffer = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < num_logo_buffers {
        if *logoFrameNum.offset(i as isize) != 0
            && *logoFrameNum.offset(i as isize) < *logoFrameNum.offset(oldestLogoBuffer as isize)
        {
            oldestLogoBuffer = i;
        }
        i += 1;
    }
    last_non_logo_frame = *logoFrameNum.offset(oldestLogoBuffer as isize);
    if logoFound != 0 {
        Debug(
            3 as libc::c_int,
            b"Doublechecking frames %i to %i for logo.\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            *logoFrameNum.offset(oldestLogoBuffer as isize),
            *logoFrameNum.offset(newestLogoBuffer as isize),
        );
        i = 0 as libc::c_int;
        while i < num_logo_buffers {
            currentGoodEdge = DoubleCheckStationLogoEdge(*logoFrameBuffer.offset(i as isize));
            LogoIsThere = currentGoodEdge > logo_threshold;
            x = *logoFrameNum.offset(i as isize);
            while x < *logoFrameNum.offset(i as isize) + (logoFreq * fps) as libc::c_int {
                (*frame.offset(x as isize)).currentGoodEdge = currentGoodEdge;
                (*frame.offset(x as isize)).logo_present = LogoIsThere;
                if !LogoIsThere {
                    if x > last_non_logo_frame {
                        last_non_logo_frame = x;
                    }
                }
                x += 1;
            }
            if LogoIsThere {
                sum += 1;
            } else {
                Debug(
                    7 as libc::c_int,
                    b"Logo not present in frame %i.\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    *logoFrameNum.offset(i as isize),
                );
            }
            i += 1;
        }
    }
    if logoFound != 0 && sum >= (num_logo_buffers as libc::c_double * 0.9f64) as libc::c_int {
        clogoMinX = tlogoMinX;
        clogoMaxX = tlogoMaxX;
        clogoMinY = tlogoMinY;
        clogoMaxY = tlogoMaxY;
        memcpy(
            choriz_edgemask.as_mut_ptr() as *mut libc::c_void,
            thoriz_edgemask.as_mut_ptr() as *const libc::c_void,
            (width * height) as libc::c_ulong,
        );
        memcpy(
            cvert_edgemask.as_mut_ptr() as *mut libc::c_void,
            tvert_edgemask.as_mut_ptr() as *const libc::c_void,
            (width * height) as libc::c_ulong,
        );
        logoTrendCounter = num_logo_buffers;
        lastLogoTest = 1 as libc::c_int != 0;
        curLogoTest = 1 as libc::c_int != 0;
        (*logo_block.offset(logo_block_count as isize)).start =
            last_non_logo_frame + 1 as libc::c_int;
        DumpEdgeMasks();
        InitScanLines();
        InitHasLogo();
        logoInfoAvailable = 1 as libc::c_int != 0;
    } else {
        currentGoodEdge = 0.0f64;
    }
    if !logoInfoAvailable
        && startOverAfterLogoInfoAvail as libc::c_int != 0
        && framenum_real > (giveUpOnLogoSearch as libc::c_double * fps) as libc::c_int
    {
        Debug(
            1 as libc::c_int,
            b"No logo was found after %i frames.\nGiving up\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            framenum_real,
        );
        commDetectMethod -= 2 as libc::c_int;
    }
    if added_recording > 0 as libc::c_int {
        giveUpOnLogoSearch += added_recording * 60 as libc::c_int;
    }
    if logoInfoAvailable as libc::c_int != 0 && startOverAfterLogoInfoAvail as libc::c_int != 0 {
        Debug(
            3 as libc::c_int,
            b"Logo found at frame %i\tlogoMinX=%i\tlogoMaxX=%i\tlogoMinY=%i\tlogoMaxY=%i\n\0"
                as *const u8 as *const libc::c_char as *mut libc::c_char,
            framenum_real,
            clogoMinX,
            clogoMaxX,
            clogoMinY,
            clogoMaxY,
        );
        SaveLogoMaskData();
        Debug(
            3 as libc::c_int,
            b"******************* End of Logo Processing ***************\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        return 0 as libc::c_int != 0;
    }
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn ClearEdgeMaskArea(
    mut temp: *mut libc::c_uchar,
    mut test: *mut libc::c_uchar,
) -> libc::c_int {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut valid: libc::c_int = 0 as libc::c_int;
    let mut offset: libc::c_int = 0;
    let mut ix: libc::c_int = 0;
    let mut iy: libc::c_int = 0;
    x = edge_radius + border + 4 as libc::c_int * edge_step;
    while x < videowidth - edge_radius - border - 4 as libc::c_int * edge_step {
        let mut y_max_test: libc::c_int = if subtitles != 0 {
            height / 2 as libc::c_int
        } else {
            height - edge_radius - border - 4 as libc::c_int * edge_step
        };
        let mut y_step_test: libc::c_int = height / 3 as libc::c_int;
        let mut current_block_27: u64;
        y = if logo_at_bottom != 0 {
            height / 2 as libc::c_int
        } else {
            edge_radius + border + 4 as libc::c_int * edge_step
        };
        while y < y_max_test {
            count = 0 as libc::c_int;
            if *temp.offset((y * width + x) as isize) as libc::c_int == 1 as libc::c_int {
                if *test.offset((y * width + x) as isize) as libc::c_int == 1 as libc::c_int {
                    count += 1;
                }
                offset = edge_step;
                loop {
                    if !(offset < (0.02f64 * width as libc::c_double) as libc::c_int) {
                        current_block_27 = 2873832966593178012;
                        break;
                    }
                    iy = min(y + offset, height - 1 as libc::c_int);
                    ix = max(x - offset, 0 as libc::c_int);
                    while ix <= min(x + offset, width - 1 as libc::c_int) {
                        if *test.offset((iy * width + ix) as isize) as libc::c_int
                            == 1 as libc::c_int
                        {
                            count += 1;
                        }
                        ix += edge_step;
                    }
                    iy = max(y - offset, 0 as libc::c_int);
                    ix = max(x - offset, 0 as libc::c_int);
                    while ix <= min(x + offset, width - 1 as libc::c_int) {
                        if *test.offset((iy * width + ix) as isize) as libc::c_int
                            == 1 as libc::c_int
                        {
                            count += 1;
                        }
                        ix += edge_step;
                    }
                    ix = min(x + offset, width - 1 as libc::c_int);
                    iy = max(y - offset + edge_step, 0 as libc::c_int);
                    while iy <= min(y + offset - edge_step, height - 1 as libc::c_int) {
                        if *test.offset((iy * width + ix) as isize) as libc::c_int
                            == 1 as libc::c_int
                        {
                            count += 1;
                        }
                        iy += edge_step;
                    }
                    ix = max(x - offset, 0 as libc::c_int);
                    iy = max(y - offset + edge_step, 0 as libc::c_int);
                    while iy <= min(y + offset - edge_step, height - 1 as libc::c_int) {
                        if *test.offset((iy * width + ix) as isize) as libc::c_int
                            == 1 as libc::c_int
                        {
                            count += 1;
                        }
                        iy += edge_step;
                    }
                    if count >= edge_weight {
                        current_block_27 = 18375296260089402345;
                        break;
                    }
                    offset += edge_step;
                }
                match current_block_27 {
                    2873832966593178012 => {
                        *temp.offset((y * width + x) as isize) = 0 as libc::c_int as libc::c_uchar;
                    }
                    _ => {
                        valid += 1;
                    }
                }
            }
            y = if y == y_step_test {
                2 as libc::c_int * height / 3 as libc::c_int
            } else {
                y + edge_step
            };
        }
        x = if x == videowidth / 3 as libc::c_int {
            2 as libc::c_int * videowidth / 3 as libc::c_int
        } else {
            x + edge_step
        };
    }
    return valid;
}
#[no_mangle]
pub unsafe extern "C" fn SetEdgeMaskArea(mut temp: *mut libc::c_uchar) {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    tlogoMinX = videowidth - 1 as libc::c_int;
    tlogoMaxX = 0 as libc::c_int;
    tlogoMinY = height - 1 as libc::c_int;
    tlogoMaxY = 0 as libc::c_int;
    x = edge_radius + border + 4 as libc::c_int * edge_step;
    while x < videowidth - edge_radius - border - 4 as libc::c_int * edge_step {
        let mut y_max_test: libc::c_int = if subtitles != 0 {
            height / 2 as libc::c_int
        } else {
            height - edge_radius - border - 4 as libc::c_int * edge_step
        };
        let mut y_step_test: libc::c_int = height / 3 as libc::c_int;
        y = if logo_at_bottom != 0 {
            height / 2 as libc::c_int
        } else {
            edge_radius + border + 4 as libc::c_int * edge_step
        };
        while y < y_max_test {
            if *temp.offset((y * width + x) as isize) as libc::c_int == 1 as libc::c_int {
                if x - 4 as libc::c_int * edge_step < tlogoMinX {
                    tlogoMinX = x - 4 as libc::c_int * edge_step;
                }
                if y - 4 as libc::c_int * edge_step < tlogoMinY {
                    tlogoMinY = y - 4 as libc::c_int * edge_step;
                }
                if x + 4 as libc::c_int * edge_step > tlogoMaxX {
                    tlogoMaxX = x + 4 as libc::c_int * edge_step;
                }
                if y + 4 as libc::c_int * edge_step > tlogoMaxY {
                    tlogoMaxY = y + 4 as libc::c_int * edge_step;
                }
            }
            y = if y == y_step_test {
                2 as libc::c_int * height / 3 as libc::c_int
            } else {
                y + edge_step
            };
        }
        x = if x == videowidth / 3 as libc::c_int {
            2 as libc::c_int * videowidth / 3 as libc::c_int
        } else {
            x + edge_step
        };
    }
    if tlogoMinX < edge_radius {
        tlogoMinX = edge_radius;
    }
    if tlogoMaxX > videowidth - edge_radius {
        tlogoMaxX = videowidth - edge_radius;
    }
    if tlogoMinY < edge_radius {
        tlogoMinY = edge_radius;
    }
    if tlogoMaxY > height - edge_radius {
        tlogoMaxY = height - edge_radius;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CountEdgePixels() -> libc::c_int {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut hcount: libc::c_int = 0 as libc::c_int;
    let mut vcount: libc::c_int = 0 as libc::c_int;
    y = tlogoMinY;
    while y <= tlogoMaxY {
        x = tlogoMinX;
        while x <= tlogoMaxX {
            if thoriz_edgemask[(y * width + x) as usize] != 0 {
                hcount += 1;
            }
            if tvert_edgemask[(y * width + x) as usize] != 0 {
                vcount += 1;
            }
            x += 1;
        }
        y += 1;
    }
    count = hcount + vcount;
    return count;
}
#[no_mangle]
pub unsafe extern "C" fn DumpEdgeMask(mut buffer: *mut libc::c_uchar, mut direction: libc::c_int) {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut outbuf: [libc::c_char; 3841] = [0; 3841];
    match direction {
        0 => {
            Debug(
                1 as libc::c_int,
                b"\nHorizontal Logo Mask \n     \0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
        }
        1 => {
            Debug(
                1 as libc::c_int,
                b"\nVertical Logo Mask \n     \0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
        }
        2 => {
            Debug(
                1 as libc::c_int,
                b"\nDiagonal 1 Logo Mask \n     \0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
        }
        3 => {
            Debug(
                1 as libc::c_int,
                b"\nDiagonal 2 Logo Mask \n     \0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
        }
        _ => {}
    }
    x = clogoMinX;
    while x <= clogoMaxX {
        outbuf[(x - clogoMinX) as usize] = ('0' as i32 + x % 10 as libc::c_int) as libc::c_char;
        x += 1;
    }
    outbuf[(x - clogoMinX) as usize] = 0 as libc::c_int as libc::c_char;
    Debug(
        1 as libc::c_int,
        b"%s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        outbuf.as_mut_ptr(),
    );
    Debug(
        1 as libc::c_int,
        b"\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    y = clogoMinY;
    while y <= clogoMaxY {
        Debug(
            1 as libc::c_int,
            b"%3d: \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            y,
        );
        x = clogoMinX;
        while x <= clogoMaxX {
            match *buffer.offset((y * width + x) as isize) as libc::c_int {
                0 => {
                    outbuf[(x - clogoMinX) as usize] = ' ' as i32 as libc::c_char;
                }
                1 => {
                    outbuf[(x - clogoMinX) as usize] = '*' as i32 as libc::c_char;
                }
                _ => {}
            }
            x += 1;
        }
        outbuf[(x - clogoMinX) as usize] = 0 as libc::c_int as libc::c_char;
        Debug(
            1 as libc::c_int,
            b"%s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            outbuf.as_mut_ptr(),
        );
        y += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn DumpEdgeMasks() {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut outbuf: [libc::c_char; 3841] = [0; 3841];
    x = clogoMinX;
    while x <= clogoMaxX {
        outbuf[(x - clogoMinX) as usize] = ('0' as i32 + x % 10 as libc::c_int) as libc::c_char;
        x += 1;
    }
    outbuf[(x - clogoMinX) as usize] = 0 as libc::c_int as libc::c_char;
    Debug(
        1 as libc::c_int,
        b"%s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        outbuf.as_mut_ptr(),
    );
    y = clogoMinY;
    while y <= clogoMaxY {
        Debug(
            1 as libc::c_int,
            b"%3d: \0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            y,
        );
        x = clogoMinX;
        while x <= clogoMaxX {
            match choriz_edgemask[(y * width + x) as usize] as libc::c_int {
                0 => {
                    if cvert_edgemask[(y * width + x) as usize] as libc::c_int == 1 as libc::c_int {
                        outbuf[(x - clogoMinX) as usize] = '-' as i32 as libc::c_char;
                    } else {
                        outbuf[(x - clogoMinX) as usize] = ' ' as i32 as libc::c_char;
                    }
                }
                1 => {
                    if cvert_edgemask[(y * width + x) as usize] as libc::c_int == 1 as libc::c_int {
                        outbuf[(x - clogoMinX) as usize] = '+' as i32 as libc::c_char;
                    } else {
                        outbuf[(x - clogoMinX) as usize] = '|' as i32 as libc::c_char;
                    }
                }
                _ => {}
            }
            x += 1;
        }
        outbuf[(x - clogoMinX) as usize] = 0 as libc::c_int as libc::c_char;
        Debug(
            1 as libc::c_int,
            b"%s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            outbuf.as_mut_ptr(),
        );
        y += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn CheckFramesForLogo(mut start: libc::c_int, mut end: libc::c_int) -> bool {
    let mut i: libc::c_int = 0;
    let mut sum: libc::c_double = 0.0f64;
    i = start;
    while i <= end {
        sum += (if (*frame.offset(i as isize)).currentGoodEdge > logo_threshold {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_double;
        i += 1;
    }
    sum = sum / (end - start + 1 as libc::c_int) as libc::c_double;
    if sum > logo_percentage_threshold {
        return 1 as libc::c_int != 0;
    }
    return 0 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn CalculateLogoFraction(
    mut start: libc::c_int,
    mut end: libc::c_int,
) -> libc::c_double {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    j = 0 as libc::c_int;
    i = start;
    while i <= end {
        while (j as libc::c_long) < logo_block_count && i > (*logo_block.offset(j as isize)).end {
            j += 1;
        }
        if (j as libc::c_long) < logo_block_count
            && i >= (*logo_block.offset(j as isize)).start
            && i <= (*logo_block.offset(j as isize)).end
        {
            count += 1;
        }
        i += 1;
    }
    if reverseLogoLogic {
        return 1.0f64
            - count as libc::c_double / (end - start + 1 as libc::c_int) as libc::c_double;
    }
    return count as libc::c_double / (end - start + 1 as libc::c_int) as libc::c_double;
}
#[no_mangle]
pub unsafe extern "C" fn CheckFrameForLogo(mut i: libc::c_int) -> bool {
    let mut j: libc::c_int = 0 as libc::c_int;
    while (j as libc::c_long) < logo_block_count && i > (*logo_block.offset(j as isize)).end {
        j += 1;
    }
    if (j as libc::c_long) < logo_block_count
        && i <= (*logo_block.offset(j as isize)).end
        && i >= (*logo_block.offset(j as isize)).start
    {
        return !reverseLogoLogic;
    }
    return reverseLogoLogic;
}
#[no_mangle]
pub unsafe extern "C" fn CheckFramesForCommercial(
    mut start: libc::c_int,
    mut end: libc::c_int,
) -> libc::c_char {
    let mut i: libc::c_int = 0;
    if start >= end {
        return '0' as i32 as libc::c_char;
    }
    i = 0 as libc::c_int;
    while i <= commercial_count && start as libc::c_long > commercial[i as usize].end_frame {
        i += 1;
    }
    if i <= commercial_count {
        if (end as libc::c_long) < commercial[i as usize].start_frame {
            return '+' as i32 as libc::c_char;
        }
        if (start as libc::c_long) < commercial[i as usize].start_frame {
            return '0' as i32 as libc::c_char;
        }
        return '-' as i32 as libc::c_char;
    }
    return '+' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn CheckFramesForReffer(
    mut start: libc::c_int,
    mut end: libc::c_int,
) -> libc::c_char {
    let mut i: libc::c_int = 0;
    if reffer_count < 0 as libc::c_int {
        return ' ' as i32 as libc::c_char;
    }
    if start >= end {
        return '0' as i32 as libc::c_char;
    }
    i = 0 as libc::c_int;
    while i <= reffer_count
        && (reffer[i as usize].end_frame as libc::c_double) < start as libc::c_double + fps
    {
        i += 1;
    }
    if i <= reffer_count {
        if (reffer[i as usize].start_frame as libc::c_double) < start as libc::c_double + fps {
            return '-' as i32 as libc::c_char;
        }
        if reffer[i as usize].start_frame as libc::c_double > end as libc::c_double - fps {
            return '+' as i32 as libc::c_char;
        }
        if (reffer[i as usize].start_frame as libc::c_double) < end as libc::c_double + fps {
            return '0' as i32 as libc::c_char;
        }
        return '-' as i32 as libc::c_char;
    }
    return '+' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn SaveLogoMaskData() {
    let mut logo_file: *mut FILE = 0 as *mut FILE;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    logo_file = myfopen(
        logofilename.as_mut_ptr(),
        b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if logo_file.is_null() {
        fprintf(
            __stderrp,
            b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
            strerror(*__error()),
            logofilename.as_mut_ptr(),
        );
        Debug(
            1 as libc::c_int,
            b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            strerror(*__error()),
            logofilename.as_mut_ptr(),
        );
        if startOverAfterLogoInfoAvail {
            exit(7 as libc::c_int);
        }
    }
    fprintf(
        logo_file,
        b"logoMinX=%i\n\0" as *const u8 as *const libc::c_char,
        clogoMinX,
    );
    fprintf(
        logo_file,
        b"logoMaxX=%i\n\0" as *const u8 as *const libc::c_char,
        clogoMaxX,
    );
    fprintf(
        logo_file,
        b"logoMinY=%i\n\0" as *const u8 as *const libc::c_char,
        clogoMinY,
    );
    fprintf(
        logo_file,
        b"logoMaxY=%i\n\0" as *const u8 as *const libc::c_char,
        clogoMaxY,
    );
    fprintf(
        logo_file,
        b"picWidth=%i\n\0" as *const u8 as *const libc::c_char,
        width,
    );
    fprintf(
        logo_file,
        b"picHeight=%i\n\0" as *const u8 as *const libc::c_char,
        height,
    );
    fprintf(
        logo_file,
        b"\nCombined Logo Mask\n\0" as *const u8 as *const libc::c_char,
    );
    fprintf(logo_file, b"\x82\n\0" as *const u8 as *const libc::c_char);
    y = clogoMinY;
    while y <= clogoMaxY {
        x = clogoMinX;
        while x <= clogoMaxX {
            match choriz_edgemask[(y * width + x) as usize] as libc::c_int {
                0 => {
                    if cvert_edgemask[(y * width + x) as usize] as libc::c_int == 1 as libc::c_int {
                        fprintf(logo_file, b"-\0" as *const u8 as *const libc::c_char);
                    } else {
                        fprintf(logo_file, b" \0" as *const u8 as *const libc::c_char);
                    }
                }
                1 => {
                    if cvert_edgemask[(y * width + x) as usize] as libc::c_int == 1 as libc::c_int {
                        fprintf(logo_file, b"+\0" as *const u8 as *const libc::c_char);
                    } else {
                        fprintf(logo_file, b"|\0" as *const u8 as *const libc::c_char);
                    }
                }
                _ => {}
            }
            x += 1;
        }
        fprintf(logo_file, b"\n\0" as *const u8 as *const libc::c_char);
        y += 1;
    }
    fclose(logo_file);
}
#[no_mangle]
pub unsafe extern "C" fn LoadLogoMaskData() {
    let mut logo_file: *mut FILE = 0 as *mut FILE;
    let mut txt_file: *mut FILE = 0 as *mut FILE;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut tmp: libc::c_double = 0.;
    let mut temp: libc::c_char = 0;
    let mut data: [libc::c_char; 2000] = [0; 2000];
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmpLong: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut len: size_t = 0 as libc::c_int as size_t;
    logo_file = myfopen(
        logofilename.as_mut_ptr(),
        b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if !logo_file.is_null() {
        Debug(
            1 as libc::c_int,
            b"Using %s for logo data.\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            logofilename.as_mut_ptr(),
        );
        len = fread(
            data.as_mut_ptr() as *mut libc::c_void,
            1 as libc::c_int as libc::c_ulong,
            1999 as libc::c_int as libc::c_ulong,
            logo_file,
        );
        fclose(logo_file);
        data[len as usize] = '\0' as i32 as libc::c_char;
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"picWidth=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            width as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            width = tmp as libc::c_int;
            videowidth = width;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"picHeight=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            height as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            height = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logoMinX=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            clogoMinX as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            clogoMinX = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logoMaxX=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            clogoMaxX as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            clogoMaxX = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logoMinY=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            clogoMinY as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            clogoMinY = tmp as libc::c_int;
        }
        tmp = FindNumber(
            data.as_mut_ptr(),
            b"logoMaxY=\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            clogoMaxY as libc::c_double,
        );
        if tmp > -(1 as libc::c_int) as libc::c_double {
            clogoMaxY = tmp as libc::c_int;
        }
    } else {
        Debug(
            0 as libc::c_int,
            b"Could not find the logo file.\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        logoInfoAvailable = 0 as libc::c_int != 0;
        return;
    }
    logo_file = myfopen(
        logofilename.as_mut_ptr(),
        b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    loop {
        temp = getc(logo_file) as libc::c_char;
        if !(temp as libc::c_int != -128i32 && feof(logo_file) == 0) {
            break;
        }
    }
    y = clogoMinY;
    while y <= clogoMaxY {
        x = clogoMinX;
        while x <= clogoMaxX {
            temp = getc(logo_file) as libc::c_char;
            if temp as libc::c_int == '\n' as i32 {
                temp = getc(logo_file) as libc::c_char;
            }
            match temp as libc::c_int {
                32 => {
                    choriz_edgemask[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                }
                124 => {
                    choriz_edgemask[(y * width + x) as usize] = 1 as libc::c_int as libc::c_uchar;
                }
                _ => {}
            }
            x += 1;
        }
        y += 1;
    }
    fclose(logo_file);
    logo_file = myfopen(
        logofilename.as_mut_ptr(),
        b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    loop {
        temp = getc(logo_file) as libc::c_char;
        if !(temp as libc::c_int != -127i32 && feof(logo_file) == 0) {
            break;
        }
    }
    y = clogoMinY;
    while y <= clogoMaxY {
        x = clogoMinX;
        while x <= clogoMaxX {
            temp = getc(logo_file) as libc::c_char;
            if temp as libc::c_int == '\n' as i32 {
                temp = getc(logo_file) as libc::c_char;
            }
            match temp as libc::c_int {
                32 => {
                    cvert_edgemask[(y * width + x) as usize] = 0 as libc::c_int as libc::c_uchar;
                }
                45 => {
                    cvert_edgemask[(y * width + x) as usize] = 1 as libc::c_int as libc::c_uchar;
                }
                _ => {}
            }
            x += 1;
        }
        y += 1;
    }
    fclose(logo_file);
    logo_file = myfopen(
        logofilename.as_mut_ptr(),
        b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    loop {
        temp = getc(logo_file) as libc::c_char;
        if !(temp as libc::c_int != -126i32 && feof(logo_file) == 0) {
            break;
        }
    }
    if feof(logo_file) == 0 {
        y = clogoMinY;
        while y <= clogoMaxY {
            x = clogoMinX;
            while x <= clogoMaxX {
                temp = getc(logo_file) as libc::c_char;
                if temp as libc::c_int == '\n' as i32 {
                    temp = getc(logo_file) as libc::c_char;
                }
                match temp as libc::c_int {
                    32 => {
                        choriz_edgemask[(y * width + x) as usize] =
                            0 as libc::c_int as libc::c_uchar;
                        cvert_edgemask[(y * width + x) as usize] =
                            0 as libc::c_int as libc::c_uchar;
                    }
                    45 => {
                        choriz_edgemask[(y * width + x) as usize] =
                            0 as libc::c_int as libc::c_uchar;
                        cvert_edgemask[(y * width + x) as usize] =
                            1 as libc::c_int as libc::c_uchar;
                    }
                    124 => {
                        choriz_edgemask[(y * width + x) as usize] =
                            1 as libc::c_int as libc::c_uchar;
                        cvert_edgemask[(y * width + x) as usize] =
                            0 as libc::c_int as libc::c_uchar;
                    }
                    43 => {
                        choriz_edgemask[(y * width + x) as usize] =
                            1 as libc::c_int as libc::c_uchar;
                        cvert_edgemask[(y * width + x) as usize] =
                            1 as libc::c_int as libc::c_uchar;
                    }
                    _ => {}
                }
                x += 1;
            }
            y += 1;
        }
    }
    fclose(logo_file);
    logoInfoAvailable = 1 as libc::c_int != 0;
    startOverAfterLogoInfoAvail = 1 as libc::c_int != 0;
    secondLogoSearch = 1 as libc::c_int != 0;
    InitScanLines();
    InitHasLogo();
    isSecondPass = 1 as libc::c_int != 0;
    if !loadingCSV {
        DumpEdgeMasks();
    }
    memset(
        data.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<[libc::c_char; 2000]>() as libc::c_ulong,
    );
    fflush(0 as *mut FILE);
    if output_default {
        txt_file = myfopen(
            out_filename.as_mut_ptr(),
            b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if txt_file.is_null() {
            usleep((50 as libc::c_long * 1000 as libc::c_long) as useconds_t);
            txt_file = myfopen(
                out_filename.as_mut_ptr(),
                b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            if txt_file.is_null() {
                Debug(
                    0 as libc::c_int,
                    b"ERROR reading from %s\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    out_filename.as_mut_ptr(),
                );
                isSecondPass = 0 as libc::c_int != 0;
                return;
            }
        }
        if fseek(txt_file, 0 as libc::c_long, 0 as libc::c_int) != 0 {
            Debug(
                0 as libc::c_int,
                b"ERROR SEEKING\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
        }
        while !(fgets(data.as_mut_ptr(), 1999 as libc::c_int, txt_file)).is_null() {
            if !(strstr(
                data.as_mut_ptr(),
                b"FILE PROCESSING COMPLETE\0" as *const u8 as *const libc::c_char,
            ))
            .is_null()
            {
                lastFrame = 0 as libc::c_int as libc::c_long;
                break;
            } else {
                ptr = strchr(data.as_mut_ptr(), '\t' as i32);
                if !ptr.is_null() {
                    ptr = ptr.offset(1);
                    tmpLong = strtol(ptr, 0 as *mut *mut libc::c_char, 10 as libc::c_int);
                    if tmpLong > lastFrame {
                        lastFrame = tmpLong;
                    }
                }
            }
        }
        fclose(txt_file);
    }
    Debug(
        10 as libc::c_int,
        b"The last frame found in %s was %i\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        out_filename.as_mut_ptr(),
        lastFrame,
    );
}
#[no_mangle]
pub unsafe extern "C" fn CountSceneChanges(
    mut StartFrame: libc::c_int,
    mut EndFrame: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut p: libc::c_double = 0 as libc::c_int as libc::c_double;
    let mut count: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < schange_count {
        if (*schange.offset(i as isize)).frame > StartFrame as libc::c_long
            && (*schange.offset(i as isize)).frame < EndFrame as libc::c_long
        {
            count += 1;
            p += (100 as libc::c_int - (*schange.offset(i as isize)).percentage) as libc::c_double
                / (100 as libc::c_int - schange_threshold) as libc::c_double;
        }
        i += 1;
    }
    count = p as libc::c_int;
    return count;
}
#[no_mangle]
pub unsafe extern "C" fn Debug(mut level: libc::c_int, mut fmt: *mut libc::c_char, mut args: ...) {
    let mut ap: ::std::ffi::VaListImpl;
    let mut log_file_0: *mut FILE = 0 as *mut FILE;
    if verbose < level {
        return;
    }
    ap = args.clone();
    vsprintf(debugText.as_mut_ptr(), fmt, ap.as_va_list());
    if output_console {
        printf(
            b"%s\0" as *const u8 as *const libc::c_char,
            debugText.as_mut_ptr(),
        );
    }
    if log_file_0.is_null() {
        log_file_0 = myfopen(
            logfilename.as_mut_ptr(),
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if !log_file_0.is_null() {
        fprintf(
            log_file_0,
            b"%s\0" as *const u8 as *const libc::c_char,
            debugText.as_mut_ptr(),
        );
        fclose(log_file_0);
        log_file_0 = 0 as *mut FILE;
    }
    debugText[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn InitLogoBuffers() {
    let mut i: libc::c_int = 0;
    if logoFrameNum.is_null() {
        logoFrameNum = malloc(
            (num_logo_buffers as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
    }
    if logoFrameNum.is_null() {
        Debug(
            0 as libc::c_int,
            b"Could not allocate memory for logo buffer frame number array\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        exit(14 as libc::c_int);
    }
    memset(
        logoFrameNum as *mut libc::c_void,
        0 as libc::c_int,
        (num_logo_buffers as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    if logoFrameBuffer.is_null() {
        logoFrameBuffer = malloc(
            (num_logo_buffers as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<*mut libc::c_uchar>() as libc::c_ulong),
        ) as *mut *mut libc::c_uchar;
        if !logoFrameBuffer.is_null() {
            lheight = 1200 as libc::c_int;
            lwidth = 3840 as libc::c_int;
            logoFrameBufferSize = ((lwidth * lheight) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong)
                as libc::c_int;
            i = 0 as libc::c_int;
            while i < num_logo_buffers {
                let ref mut fresh85 = *logoFrameBuffer.offset(i as isize);
                *fresh85 = malloc(logoFrameBufferSize as libc::c_ulong) as *mut libc::c_uchar;
                if (*logoFrameBuffer.offset(i as isize)).is_null() {
                    Debug(
                        0 as libc::c_int,
                        b"Could not allocate memory for logo frame buffer %i\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        i,
                    );
                    exit(16 as libc::c_int);
                }
                i += 1;
            }
        } else {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for logo frame buffers\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            exit(16 as libc::c_int);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn InitComSkip() {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    min_brightness_found = 255 as libc::c_int;
    max_logo_gap = -(1 as libc::c_int);
    max_nonlogo_block_length = -(1 as libc::c_int);
    logo_overshoot = 0.0f64;
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        brightHistogram[i as usize] = 0 as libc::c_int;
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        uniformHistogram[i as usize] = 0 as libc::c_int;
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        volumeHistogram[i as usize] = 0 as libc::c_int;
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        silenceHistogram[i as usize] = 0 as libc::c_int;
        i += 1;
    }
    if framearray {
        if !initialized {
            max_frame_count = (((60 as libc::c_int * 60 as libc::c_int) as libc::c_double * fps)
                as libc::c_int
                + 1 as libc::c_int) as libc::c_long;
            frame = malloc(
                ((max_frame_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<frame_info>() as libc::c_ulong)
                    as libc::c_int as libc::c_ulong,
            ) as *mut frame_info;
        }
        if frame.is_null() {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for frame array\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            exit(10 as libc::c_int);
        }
    }
    if !initialized {
        max_black_count = 500 as libc::c_int as libc::c_long;
        black = malloc(
            ((max_black_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<black_frame_info>() as libc::c_ulong)
                as libc::c_int as libc::c_ulong,
        ) as *mut black_frame_info;
    }
    if black.is_null() {
        Debug(
            0 as libc::c_int,
            b"Could not allocate memory for black frame array\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        exit(11 as libc::c_int);
    }
    if commDetectMethod & 2 as libc::c_int != 0 {
        if !initialized {
            max_logo_block_count = 1000 as libc::c_int as libc::c_long;
            logo_block = malloc(
                ((max_logo_block_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<logo_block_info>() as libc::c_ulong)
                    as libc::c_int as libc::c_ulong,
            ) as *mut logo_block_info;
        }
        if logo_block.is_null() {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for logo cblock array\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            exit(13 as libc::c_int);
        }
        InitLogoBuffers();
        memset(
            max_br.as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<[libc::c_uchar; 4608000]>() as libc::c_ulong,
        );
        memset(
            min_br.as_mut_ptr() as *mut libc::c_void,
            255 as libc::c_int,
            ::std::mem::size_of::<[libc::c_uchar; 4608000]>() as libc::c_ulong,
        );
    }
    if commDetectMethod & 4 as libc::c_int != 0 {
        if !initialized {
            max_schange_count = 2000 as libc::c_int as libc::c_long;
            schange = malloc(
                ((max_schange_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<schange_info>() as libc::c_ulong)
                    as libc::c_int as libc::c_ulong,
            ) as *mut schange_info;
        }
        if schange.is_null() {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for scene change array\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            exit(12 as libc::c_int);
        }
    }
    if processCC {
        if !initialized {
            max_cc_block_count = 500 as libc::c_int as libc::c_long;
            cc_block = malloc(
                ((max_cc_block_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<cc_block_info>() as libc::c_ulong),
            ) as *mut cc_block_info;
        }
        if cc_block.is_null() {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for cc blocks\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            exit(22 as libc::c_int);
        }
        (*cc_block.offset(0 as libc::c_int as isize)).start_frame =
            0 as libc::c_int as libc::c_long;
        (*cc_block.offset(0 as libc::c_int as isize)).end_frame =
            -(1 as libc::c_int) as libc::c_long;
        (*cc_block.offset(0 as libc::c_int as isize)).type_0 = 0 as libc::c_int;
        i = 1 as libc::c_int;
        while (i as libc::c_long) < max_cc_block_count {
            (*cc_block.offset(i as isize)).start_frame = -(1 as libc::c_int) as libc::c_long;
            (*cc_block.offset(i as isize)).end_frame = -(1 as libc::c_int) as libc::c_long;
            (*cc_block.offset(i as isize)).type_0 = 0 as libc::c_int;
            i += 1;
        }
        if !initialized {
            cc_memory = malloc(
                (15 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<*mut libc::c_uchar>() as libc::c_ulong),
            ) as *mut *mut libc::c_uchar;
            cc_screen = malloc(
                (15 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<*mut libc::c_uchar>() as libc::c_ulong),
            ) as *mut *mut libc::c_uchar;
            i = 0 as libc::c_int;
            while i < 15 as libc::c_int {
                let ref mut fresh86 = *cc_memory.offset(i as isize);
                *fresh86 = malloc(
                    (32 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong),
                ) as *mut libc::c_uchar;
                let ref mut fresh87 = *cc_screen.offset(i as isize);
                *fresh87 = malloc(
                    (32 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong),
                ) as *mut libc::c_uchar;
                i += 1;
            }
        }
        i = 0 as libc::c_int;
        while i < 15 as libc::c_int {
            j = 0 as libc::c_int;
            while j < 32 as libc::c_int {
                *(*cc_memory.offset(i as isize)).offset(j as isize) =
                    0 as libc::c_int as libc::c_uchar;
                *(*cc_screen.offset(i as isize)).offset(j as isize) =
                    0 as libc::c_int as libc::c_uchar;
                j += 1;
            }
            i += 1;
        }
        if !initialized {
            max_cc_text_count = 1 as libc::c_int as libc::c_long;
            cc_text = malloc(
                ((max_cc_text_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<cc_text_info>() as libc::c_ulong),
            ) as *mut cc_text_info;
        }
        if cc_text.is_null() {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for cc text groups\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            exit(22 as libc::c_int);
        }
        (*cc_text.offset(0 as libc::c_int as isize)).start_frame = 1 as libc::c_int as libc::c_long;
        (*cc_text.offset(0 as libc::c_int as isize)).end_frame =
            -(1 as libc::c_int) as libc::c_long;
        (*cc_text.offset(0 as libc::c_int as isize)).text[0 as libc::c_int as usize] =
            '\0' as i32 as libc::c_uchar;
        (*cc_text.offset(0 as libc::c_int as isize)).text_len = 0 as libc::c_int as libc::c_long;
        i = 1 as libc::c_int;
        while (i as libc::c_long) < max_cc_text_count {
            (*cc_text.offset(i as isize)).start_frame = -(1 as libc::c_int) as libc::c_long;
            (*cc_text.offset(i as isize)).end_frame = -(1 as libc::c_int) as libc::c_long;
            (*cc_text.offset(i as isize)).text[0 as libc::c_int as usize] =
                '\0' as i32 as libc::c_uchar;
            (*cc_text.offset(i as isize)).text_len = 0 as libc::c_int as libc::c_long;
            i += 1;
        }
    }
    if !initialized {
        max_ar_block_count = 100 as libc::c_int as libc::c_long;
        ar_block = malloc(
            ((max_ar_block_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<ar_block_info>() as libc::c_ulong)
                as libc::c_int as libc::c_ulong,
        ) as *mut ar_block_info;
        max_ac_block_count = 100 as libc::c_int as libc::c_long;
        ac_block = malloc(
            ((max_ac_block_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<ac_block_info>() as libc::c_ulong)
                as libc::c_int as libc::c_ulong,
        ) as *mut ac_block_info;
    }
    if ar_block.is_null() {
        Debug(
            0 as libc::c_int,
            b"Could not allocate memory for aspect ratio block array\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        exit(31 as libc::c_int);
    }
    if ac_block.is_null() {
        Debug(
            0 as libc::c_int,
            b"Could not allocate memory for audio channel block array\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
        );
        exit(31 as libc::c_int);
    }
    cc.cc1[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    cc.cc1[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    cc.cc2[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    cc.cc2[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    lastcc.cc1[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    lastcc.cc1[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    lastcc.cc2[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    lastcc.cc2[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
    Init_XDS_block();
    if max_avg_brightness == 0 as libc::c_int {
        if fps == 25.00f64 {
            max_avg_brightness = 19 as libc::c_int;
        } else {
            max_avg_brightness = 19 as libc::c_int;
        }
    }
    schange_count = 0 as libc::c_int as libc::c_long;
    frame_count = 0 as libc::c_int as libc::c_long;
    framesprocessed = 0 as libc::c_int;
    black_count = 0 as libc::c_int as libc::c_long;
    block_count = 0 as libc::c_int as libc::c_long;
    ar_block_count = 0 as libc::c_int as libc::c_long;
    ac_block_count = 0 as libc::c_int as libc::c_long;
    framenum_real = 0 as libc::c_int;
    frames_with_logo = 0 as libc::c_int;
    framenum = 0 as libc::c_int;
    lastLogoTest = 0 as libc::c_int != 0;
    commercial_count = -(1 as libc::c_int);
    logoTrendCounter = 0 as libc::c_int;
    cc_block_count = 0 as libc::c_int as libc::c_long;
    cc_text_count = 0 as libc::c_int as libc::c_long;
    logo_block_count = 0 as libc::c_int as libc::c_long;
    scr = 0 as libc::c_int;
    ascr = scr;
    InitScanLines();
    InitHasLogo();
    initialized = 1 as libc::c_int != 0;
    close_dump();
}
#[no_mangle]
pub unsafe extern "C" fn FindIniFile() {}
#[no_mangle]
pub unsafe extern "C" fn FindScoreThreshold(mut percentile: libc::c_double) -> libc::c_double {
    let mut i: libc::c_int = 0;
    let mut counter: libc::c_int = 0;
    let mut score: *mut libc::c_double = 0 as *mut libc::c_double;
    let mut count: *mut libc::c_long = 0 as *mut libc::c_long;
    let mut start: *mut libc::c_long = 0 as *mut libc::c_long;
    let mut percent: *mut libc::c_double = 0 as *mut libc::c_double;
    let mut blocknr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tempScore: libc::c_double = 0.;
    let mut tempCount: libc::c_long = 0;
    let mut tempStart: libc::c_long = 0;
    let mut tempBlocknr: libc::c_int = 0;
    let mut targetCount: libc::c_long = 0;
    let mut totalframes: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut hadToSwap: bool = 0 as libc::c_int != 0;
    score = malloc(
        (::std::mem::size_of::<libc::c_double>() as libc::c_ulong)
            .wrapping_mul(block_count as libc::c_ulong),
    ) as *mut libc::c_double;
    count = malloc(
        (::std::mem::size_of::<libc::c_long>() as libc::c_ulong)
            .wrapping_mul(block_count as libc::c_ulong),
    ) as *mut libc::c_long;
    start = malloc(
        (::std::mem::size_of::<libc::c_long>() as libc::c_ulong)
            .wrapping_mul(block_count as libc::c_ulong),
    ) as *mut libc::c_long;
    blocknr = malloc(
        (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
            .wrapping_mul(block_count as libc::c_ulong),
    ) as *mut libc::c_int;
    percent = malloc(
        (::std::mem::size_of::<libc::c_double>() as libc::c_ulong)
            .wrapping_mul(block_count as libc::c_ulong),
    ) as *mut libc::c_double;
    if score.is_null()
        || count.is_null()
        || start.is_null()
        || blocknr.is_null()
        || percent.is_null()
    {
        Debug(
            1 as libc::c_int,
            b"Could not allocate memory.  Exiting program.\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        exit(21 as libc::c_int);
    }
    counter = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        *blocknr.offset(i as isize) = i;
        *score.offset(i as isize) = cblock[i as usize].score;
        *count.offset(i as isize) = cblock[i as usize].f_end - cblock[i as usize].f_start
            + 1 as libc::c_int as libc::c_long;
        *start.offset(i as isize) = cblock[i as usize].f_start;
        i += 1;
    }
    loop {
        hadToSwap = 0 as libc::c_int != 0;
        counter += 1;
        i = 0 as libc::c_int;
        while (i as libc::c_long) < block_count - 1 as libc::c_int as libc::c_long {
            if *score.offset(i as isize) > *score.offset((i + 1 as libc::c_int) as isize) {
                hadToSwap = 1 as libc::c_int != 0;
                tempScore = *score.offset(i as isize);
                tempCount = *count.offset(i as isize);
                tempStart = *start.offset(i as isize);
                tempBlocknr = *blocknr.offset(i as isize);
                *score.offset(i as isize) = *score.offset((i + 1 as libc::c_int) as isize);
                *count.offset(i as isize) = *count.offset((i + 1 as libc::c_int) as isize);
                *start.offset(i as isize) = *start.offset((i + 1 as libc::c_int) as isize);
                *blocknr.offset(i as isize) = *blocknr.offset((i + 1 as libc::c_int) as isize);
                *score.offset((i + 1 as libc::c_int) as isize) = tempScore;
                *count.offset((i + 1 as libc::c_int) as isize) = tempCount;
                *start.offset((i + 1 as libc::c_int) as isize) = tempStart;
                *blocknr.offset((i + 1 as libc::c_int) as isize) = tempBlocknr;
            }
            i += 1;
        }
        if !hadToSwap {
            break;
        }
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        totalframes += *count.offset(i as isize);
        i += 1;
    }
    tempCount = 0 as libc::c_int as libc::c_long;
    Debug(
        10 as libc::c_int,
        b"\n\nAfter Sorting - %i\n--------------\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        counter,
    );
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        tempCount += *count.offset(i as isize);
        Debug(
            10 as libc::c_int,
            b"Block %3i - %.3f\t%6i\t%6i\t%6i\t%3.1f%c\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            *blocknr.offset(i as isize),
            *score.offset(i as isize),
            *start.offset(i as isize),
            cblock[*blocknr.offset(i as isize) as usize].f_end,
            *count.offset(i as isize),
            tempCount as libc::c_double / totalframes as libc::c_double
                * 100 as libc::c_int as libc::c_double,
            '%' as i32,
        );
        i += 1;
    }
    targetCount = (totalframes as libc::c_double * percentile) as libc::c_long;
    i = -(1 as libc::c_int);
    tempCount = 0 as libc::c_int as libc::c_long;
    loop {
        i += 1;
        tempCount += *count.offset(i as isize);
        if !(tempCount < targetCount) {
            break;
        }
    }
    tempScore = *score.offset(i as isize);
    free(score as *mut libc::c_void);
    free(count as *mut libc::c_void);
    free(percent as *mut libc::c_void);
    Debug(
        6 as libc::c_int,
        b"The %.2f percentile of %i frames is %.2f\n\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        percentile * 100.0f64,
        totalframes,
        tempScore,
    );
    return tempScore;
}
#[no_mangle]
pub unsafe extern "C" fn OutputLogoHistogram(mut buckets: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut max_0: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut columns: libc::c_int = 200 as libc::c_int;
    let mut divisor: libc::c_double = 0.;
    let mut stars: [libc::c_char; 256] = [0; 256];
    let mut counter: libc::c_long = 0 as libc::c_int as libc::c_long;
    i = 0 as libc::c_int;
    while i < buckets {
        if max_0 < logoHistogram[i as usize] as libc::c_long {
            max_0 = logoHistogram[i as usize] as libc::c_long;
        }
        i += 1;
    }
    divisor = columns as libc::c_double / max_0 as libc::c_double;
    Debug(
        8 as libc::c_int,
        b"Logo Histogram - %.5f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        divisor,
    );
    i = 0 as libc::c_int;
    while i < buckets {
        counter += logoHistogram[i as usize] as libc::c_long;
        stars[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        if logoHistogram[i as usize] > 0 as libc::c_int {
            j = 0 as libc::c_int;
            while j <= (logoHistogram[i as usize] as libc::c_double * divisor) as libc::c_int {
                stars[j as usize] = '*' as i32 as libc::c_char;
                j += 1;
            }
            stars[j as usize] = 0 as libc::c_int as libc::c_char;
        }
        Debug(
            8 as libc::c_int,
            b"%.3f - %6i - %.5f %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            i as libc::c_double / buckets as libc::c_double,
            logoHistogram[i as usize],
            counter as libc::c_double / frame_count as libc::c_double,
            stars.as_mut_ptr(),
        );
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OutputbrightHistogram() {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut max_0: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut columns: libc::c_int = 200 as libc::c_int;
    let mut divisor: libc::c_double = 0.;
    let mut counter: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut stars: [libc::c_char; 256] = [0; 256];
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        if max_0 < brightHistogram[i as usize] as libc::c_long {
            max_0 = brightHistogram[i as usize] as libc::c_long;
        }
        i += 1;
    }
    divisor = columns as libc::c_double / max_0 as libc::c_double;
    Debug(
        1 as libc::c_int,
        b"Show Histogram - %.5f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        divisor,
    );
    i = 0 as libc::c_int;
    while i < 30 as libc::c_int {
        counter += brightHistogram[i as usize] as libc::c_long;
        stars[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        if brightHistogram[i as usize] > 0 as libc::c_int {
            j = 0 as libc::c_int;
            while j <= (brightHistogram[i as usize] as libc::c_double * divisor) as libc::c_int {
                stars[j as usize] = '*' as i32 as libc::c_char;
                j += 1;
            }
            stars[j as usize] = 0 as libc::c_int as libc::c_char;
        }
        Debug(
            1 as libc::c_int,
            b"%3i - %6i - %.5f %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            i,
            brightHistogram[i as usize],
            counter as libc::c_double / framesprocessed as libc::c_double,
            stars.as_mut_ptr(),
        );
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OutputuniformHistogram() {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut max_0: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut columns: libc::c_int = 200 as libc::c_int;
    let mut divisor: libc::c_double = 0.;
    let mut counter: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut stars: [libc::c_char; 256] = [0; 256];
    i = 0 as libc::c_int;
    while i < 30 as libc::c_int {
        if max_0 < uniformHistogram[i as usize] as libc::c_long {
            max_0 = uniformHistogram[i as usize] as libc::c_long;
        }
        i += 1;
    }
    divisor = columns as libc::c_double / max_0 as libc::c_double;
    Debug(
        1 as libc::c_int,
        b"Show Uniform - %.5f\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        divisor,
    );
    i = 0 as libc::c_int;
    while i < 30 as libc::c_int {
        counter += uniformHistogram[i as usize] as libc::c_long;
        stars[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        if uniformHistogram[i as usize] > 0 as libc::c_int {
            j = 0 as libc::c_int;
            while j <= (uniformHistogram[i as usize] as libc::c_double * divisor) as libc::c_int {
                stars[j as usize] = '*' as i32 as libc::c_char;
                j += 1;
            }
            stars[j as usize] = 0 as libc::c_int as libc::c_char;
        }
        Debug(
            1 as libc::c_int,
            b"%3i - %6i - %.5f %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            i * 100 as libc::c_int,
            uniformHistogram[i as usize],
            counter as libc::c_double / framesprocessed as libc::c_double,
            stars.as_mut_ptr(),
        );
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn OutputHistogram(
    mut histogram_0: *mut libc::c_int,
    mut scale: libc::c_int,
    mut title: *mut libc::c_char,
    mut truncate: bool,
) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut max_0: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut columns: libc::c_int = 70 as libc::c_int;
    let mut divisor: libc::c_double = 0.;
    let mut counter: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut stars: [libc::c_char; 256] = [0; 256];
    i = 0 as libc::c_int;
    while i
        < (if truncate as libc::c_int != 0 {
            255 as libc::c_int
        } else {
            256 as libc::c_int
        })
    {
        if max_0 < *histogram_0.offset(i as isize) as libc::c_long {
            max_0 = *histogram_0.offset(i as isize) as libc::c_long;
        }
        i += 1;
    }
    divisor = columns as libc::c_double / max_0 as libc::c_double;
    Debug(
        8 as libc::c_int,
        b"Show %s Histogram\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        title,
    );
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        counter += *histogram_0.offset(i as isize) as libc::c_long;
        stars[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        if *histogram_0.offset(i as isize) > 0 as libc::c_int {
            j = 0 as libc::c_int;
            while j <= (*histogram_0.offset(i as isize) as libc::c_double * divisor) as libc::c_int
                && j <= columns
            {
                stars[j as usize] = '*' as i32 as libc::c_char;
                j += 1;
            }
            stars[j as usize] = 0 as libc::c_int as libc::c_char;
        }
        Debug(
            8 as libc::c_int,
            b"%3i - %6i - %.5f %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            i * scale,
            *histogram_0.offset(i as isize),
            counter as libc::c_double / framesprocessed as libc::c_double,
            stars.as_mut_ptr(),
        );
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn FindBlackThreshold(mut percentile: libc::c_double) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut tempCount: libc::c_long = 0;
    let mut targetCount: libc::c_long = 0;
    let mut totalframes: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut raw: *mut FILE = 0 as *mut FILE;
    if output_training != 0 {
        raw = myfopen(
            b"black.csv\0" as *const u8 as *const libc::c_char,
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if !raw.is_null() {
        fprintf(
            raw,
            b"\"%s\"\0" as *const u8 as *const libc::c_char,
            inbasename.as_mut_ptr(),
        );
    }
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        totalframes += brightHistogram[i as usize] as libc::c_long;
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < 35 as libc::c_int {
        if !raw.is_null() {
            fprintf(
                raw,
                b",%6.2f\0" as *const u8 as *const libc::c_char,
                1000.0f64 * brightHistogram[i as usize] as libc::c_double
                    / totalframes as libc::c_double,
            );
        }
        i += 1;
    }
    if !raw.is_null() {
        fprintf(raw, b"\n\0" as *const u8 as *const libc::c_char);
    }
    if !raw.is_null() {
        fclose(raw);
    }
    tempCount = 0 as libc::c_int as libc::c_long;
    targetCount = (totalframes as libc::c_double * percentile) as libc::c_long;
    i = -(1 as libc::c_int);
    tempCount = 0 as libc::c_int as libc::c_long;
    loop {
        i += 1;
        tempCount += brightHistogram[i as usize] as libc::c_long;
        if !(tempCount < targetCount) {
            break;
        }
    }
    return i;
}
#[no_mangle]
pub unsafe extern "C" fn FindUniformThreshold(mut percentile: libc::c_double) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut tempCount: libc::c_long = 0;
    let mut targetCount: libc::c_long = 0;
    let mut totalframes: libc::c_long = 0 as libc::c_int as libc::c_long;
    let mut raw: *mut FILE = 0 as *mut FILE;
    if output_training != 0 {
        raw = myfopen(
            b"uniform.csv\0" as *const u8 as *const libc::c_char,
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if !raw.is_null() {
        fprintf(
            raw,
            b"\"%s\"\0" as *const u8 as *const libc::c_char,
            inbasename.as_mut_ptr(),
        );
    }
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        totalframes += uniformHistogram[i as usize] as libc::c_long;
        i += 1;
    }
    i = 0 as libc::c_int;
    while i < 35 as libc::c_int {
        if !raw.is_null() {
            fprintf(
                raw,
                b",%6.2f\0" as *const u8 as *const libc::c_char,
                1000.0f64 * uniformHistogram[i as usize] as libc::c_double
                    / totalframes as libc::c_double,
            );
        }
        i += 1;
    }
    if !raw.is_null() {
        fprintf(raw, b"\n\0" as *const u8 as *const libc::c_char);
    }
    if !raw.is_null() {
        fclose(raw);
    }
    tempCount = 0 as libc::c_int as libc::c_long;
    targetCount = (totalframes as libc::c_double * percentile) as libc::c_long;
    i = -(1 as libc::c_int);
    tempCount = 0 as libc::c_int as libc::c_long;
    loop {
        i += 1;
        tempCount += uniformHistogram[i as usize] as libc::c_long;
        if !(tempCount < targetCount) {
            break;
        }
    }
    if i == 0 as libc::c_int {
        i = 1 as libc::c_int;
    }
    return (i + 1 as libc::c_int) * 100 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn OutputFrame(mut frame_number: libc::c_int) {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut raw: *mut FILE = 0 as *mut FILE;
    let mut array: [libc::c_char; 1024] = [0; 1024];
    sprintf(
        array.as_mut_ptr(),
        b"%.*s%i.frm\0" as *const u8 as *const libc::c_char,
        (strlen(logfilename.as_mut_ptr())).wrapping_sub(4 as libc::c_int as libc::c_ulong)
            as libc::c_int,
        logfilename.as_mut_ptr(),
        frame_number,
    );
    Debug(
        5 as libc::c_int,
        b"Sending frame to file\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    raw = myfopen(
        array.as_mut_ptr(),
        b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if raw.is_null() {
        Debug(
            1 as libc::c_int,
            b"Could not open frame output file.\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return;
    }
    fprintf(raw, b"0;\0" as *const u8 as *const libc::c_char);
    x = 0 as libc::c_int;
    while x < videowidth {
        fprintf(raw, b";%3i\0" as *const u8 as *const libc::c_char, x);
        x += 1;
    }
    fprintf(raw, b"\n\0" as *const u8 as *const libc::c_char);
    y = 0 as libc::c_int;
    while y < height {
        fprintf(raw, b"%3i\0" as *const u8 as *const libc::c_char, y);
        x = 0 as libc::c_int;
        while x < videowidth {
            if (*frame_ptr.offset((y * width + x) as isize) as libc::c_int) < 30 as libc::c_int {
                fprintf(raw, b";   \0" as *const u8 as *const libc::c_char);
            } else {
                fprintf(
                    raw,
                    b";%3i\0" as *const u8 as *const libc::c_char,
                    *frame_ptr.offset((y * width + x) as isize) as libc::c_int,
                );
            }
            x += 1;
        }
        fprintf(raw, b"\n\0" as *const u8 as *const libc::c_char);
        y += 1;
    }
    fclose(raw);
}
#[no_mangle]
pub unsafe extern "C" fn FindFrameWithPts(mut t: libc::c_double) -> libc::c_int {
    let mut mx: libc::c_int = 0;
    let mut mn: libc::c_int = 0;
    mx = frame_count as libc::c_int;
    mn = 1 as libc::c_int;
    if !frame.is_null() {
        while mx > mn + 1 as libc::c_int {
            if t < (*frame.offset(((mx + mn) / 2 as libc::c_int) as isize)).pts {
                mx = (((mx + mn) as libc::c_double + 0.5f64) / 2 as libc::c_int as libc::c_double)
                    as libc::c_int;
            } else if t > (*frame.offset(((mx + mn) / 2 as libc::c_int) as isize)).pts {
                mn = (((mx + mn) as libc::c_double + 0.5f64) / 2 as libc::c_int as libc::c_double)
                    as libc::c_int;
            } else {
                return (((mx + mn) as libc::c_double + 0.5f64) / 2 as libc::c_int as libc::c_double)
                    as libc::c_int;
            }
        }
        return (mx + mn) / 2 as libc::c_int;
    } else {
        return (t * fps) as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn InputReffer(
    mut extension: *mut libc::c_char,
    mut setfps: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_long = 0;
    let mut k: libc::c_int = 0;
    let mut pk: libc::c_int = 0;
    let mut fpos: libc::c_double = 0.0f64;
    let mut fneg: libc::c_double = 0.0f64;
    let mut total: libc::c_double = 0.0f64;
    let mut t: libc::c_double = 0 as libc::c_int as libc::c_double;
    let mut state: C2RustUnnamed_3 = both_show;
    let mut line: [libc::c_char; 2048] = [0; 2048];
    let mut split: [libc::c_char; 256] = [0; 256];
    let mut array: [libc::c_char; 1024] = [0; 1024];
    let mut raw: *mut FILE = 0 as *mut FILE;
    let mut x: libc::c_int = 0;
    let mut col: libc::c_int = 0;
    let mut lineProcessed: bool = false;
    let mut frames: libc::c_int = 0 as libc::c_int;
    let mut co: libc::c_char = 0;
    let mut re: libc::c_char = 0;
    let mut raw2: *mut FILE = 0 as *mut FILE;
    sprintf(
        array.as_mut_ptr(),
        b"%.*s%s\0" as *const u8 as *const libc::c_char,
        (strlen(logfilename.as_mut_ptr())).wrapping_sub(4 as libc::c_int as libc::c_ulong)
            as libc::c_int,
        logfilename.as_mut_ptr(),
        extension,
    );
    raw = myfopen(
        array.as_mut_ptr(),
        b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if raw.is_null() {
        if !output_live {
            return 0 as libc::c_int;
        }
    } else {
        fgets(
            line.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong as libc::c_int,
            raw,
        );
        frames = 0 as libc::c_int;
        if strlen(line.as_mut_ptr()) > 27 as libc::c_int as libc::c_ulong {
            frames = strtol(
                &mut *line.as_mut_ptr().offset(25 as libc::c_int as isize),
                0 as *mut *mut libc::c_char,
                10 as libc::c_int,
            ) as libc::c_int;
        }
        if setfps != 0 {
            if strlen(line.as_mut_ptr()) > 42 as libc::c_int as libc::c_ulong {
                t = strtol(
                    &mut *line.as_mut_ptr().offset(42 as libc::c_int as isize),
                    0 as *mut *mut libc::c_char,
                    10 as libc::c_int,
                ) as libc::c_double
                    / 100 as libc::c_int as libc::c_double;
            }
            if t > 99 as libc::c_int as libc::c_double {
                t = t / 10.0f64;
            }
            if t > 0 as libc::c_int as libc::c_double {
                fps = t * 1.00000000000001f64;
                avg_fps = fps;
            }
            if t != 59.94f64 {
                sage_framenumber_bug = 0 as libc::c_int != 0;
            }
        }
        reffer_count = -(1 as libc::c_int);
        fgets(
            line.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong as libc::c_int,
            raw,
        );
        while !(fgets(
            line.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong as libc::c_int,
            raw,
        ))
        .is_null()
            && strlen(line.as_mut_ptr()) > 1 as libc::c_int as libc::c_ulong
        {
            if line[(strlen(line.as_mut_ptr())).wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as usize] as libc::c_int
                != '\n' as i32
            {
                strcat(
                    &mut *line.as_mut_ptr().offset((strlen
                        as unsafe extern "C" fn(*const libc::c_char) -> libc::c_ulong)(
                        line.as_mut_ptr(),
                    ) as isize),
                    b"\n\0" as *const u8 as *const libc::c_char,
                );
            }
            i = 0 as libc::c_int;
            x = 0 as libc::c_int;
            col = 0 as libc::c_int;
            lineProcessed = 0 as libc::c_int != 0;
            reffer_count += 1;
            while line[i as usize] as libc::c_int != '\0' as i32
                && i < ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong as libc::c_int
                && !lineProcessed
            {
                if line[i as usize] as libc::c_int == ' ' as i32
                    || line[i as usize] as libc::c_int == '\t' as i32
                    || line[i as usize] as libc::c_int == '\n' as i32
                {
                    split[x as usize] = '\0' as i32 as libc::c_char;
                    match col {
                        0 => {
                            reffer[reffer_count as usize].start_frame = FindFrameWithPts(
                                strtol(
                                    split.as_mut_ptr(),
                                    0 as *mut *mut libc::c_char,
                                    10 as libc::c_int,
                                ) as libc::c_double
                                    / fps,
                            )
                                as libc::c_long;
                            if sage_framenumber_bug {
                                reffer[reffer_count as usize].start_frame *=
                                    2 as libc::c_int as libc::c_long;
                            }
                        }
                        1 => {
                            reffer[reffer_count as usize].end_frame = FindFrameWithPts(
                                strtol(
                                    split.as_mut_ptr(),
                                    0 as *mut *mut libc::c_char,
                                    10 as libc::c_int,
                                ) as libc::c_double
                                    / fps,
                            )
                                as libc::c_long;
                            if reffer[reffer_count as usize].end_frame
                                < reffer[reffer_count as usize].start_frame
                            {
                                Debug(
                                    0 as libc::c_int,
                                    b"Error in .ref file, end < start frame\n\0" as *const u8
                                        as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                                reffer[reffer_count as usize].end_frame =
                                    reffer[reffer_count as usize].start_frame
                                        + 10 as libc::c_int as libc::c_long;
                            }
                            if sage_framenumber_bug {
                                reffer[reffer_count as usize].end_frame *=
                                    2 as libc::c_int as libc::c_long;
                            }
                            lineProcessed = 1 as libc::c_int != 0;
                        }
                        _ => {}
                    }
                    col += 1;
                    x = 0 as libc::c_int;
                    split[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
                } else {
                    split[x as usize] = line[i as usize];
                    x += 1;
                }
                i += 1;
            }
        }
        fclose(raw);
    }
    if reffer_count >= 0 as libc::c_int {
        if frames == 0 as libc::c_int {
            frames = reffer[reffer_count as usize].end_frame as libc::c_int;
        }
        if reffer[reffer_count as usize].end_frame
            == reffer[reffer_count as usize].start_frame + 1 as libc::c_int as libc::c_long
            && reffer[reffer_count as usize].end_frame == frames as libc::c_long
        {
            reffer_count -= 1;
        }
    }
    if *extension.offset(1 as libc::c_int as isize) as libc::c_int == 't' as i32 {
        return frames;
    }
    sprintf(
        array.as_mut_ptr(),
        b"%.*s.dif\0" as *const u8 as *const libc::c_char,
        (strlen(logfilename.as_mut_ptr())).wrapping_sub(4 as libc::c_int as libc::c_ulong)
            as libc::c_int,
        logfilename.as_mut_ptr(),
    );
    raw = myfopen(
        array.as_mut_ptr(),
        b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if raw.is_null() {
        return 0 as libc::c_int;
    }
    j = 0 as libc::c_int as libc::c_long;
    i = 0 as libc::c_int;
    state = both_show;
    k = 0 as libc::c_int;
    commercial[(commercial_count + 1 as libc::c_int) as usize].end_frame =
        commercial[commercial_count as usize].end_frame + 2 as libc::c_int as libc::c_long;
    commercial[(commercial_count + 1 as libc::c_int) as usize].start_frame =
        commercial[commercial_count as usize].end_frame + 1 as libc::c_int as libc::c_long;
    reffer[(reffer_count + 1 as libc::c_int) as usize].end_frame =
        commercial[commercial_count as usize].end_frame + 2 as libc::c_int as libc::c_long;
    reffer[(reffer_count + 1 as libc::c_int) as usize].start_frame =
        commercial[commercial_count as usize].end_frame + 1 as libc::c_int as libc::c_long;
    if reffer[i as usize].end_frame - reffer[i as usize].start_frame
        > 2 as libc::c_int as libc::c_long
    {
        if output_training > 1 as libc::c_int {
            raw2 = myfopen(
                b"quality.csv\0" as *const u8 as *const libc::c_char,
                b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
        }
        if !raw2.is_null() {
            fprintf(
                raw2,
                b"\"%s\", %6ld, %6.1f, %6.1f, %6.1f\n\0" as *const u8 as *const libc::c_char,
                inbasename.as_mut_ptr(),
                reffer[i as usize].start_frame,
                0.0f64,
                0.0f64,
                (if !frame.is_null() {
                    (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if reffer[i as usize].end_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                        })
                    })
                } else {
                    reffer[i as usize].end_frame as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if reffer[i as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if reffer[i as usize].start_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                        })
                    })
                } else {
                    reffer[i as usize].start_frame as libc::c_double / fps
                }),
            );
        }
        total += (if !frame.is_null() {
            (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if reffer[i as usize].end_frame >= framenum_real as libc::c_long {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                })
            })
        } else {
            reffer[i as usize].end_frame as libc::c_double / fps
        }) - (if !frame.is_null() {
            (if reffer[i as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                (*frame.offset(1 as libc::c_int as isize)).pts
            } else {
                (if reffer[i as usize].start_frame >= framenum_real as libc::c_long {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                })
            })
        } else {
            reffer[i as usize].start_frame as libc::c_double / fps
        });
        if !raw2.is_null() {
            fclose(raw2);
        }
    }
    while (k as libc::c_long) < commercial[commercial_count as usize].end_frame
        && (i <= reffer_count || j <= commercial_count as libc::c_long)
    {
        pk = k;
        match state as libc::c_uint {
            0 => {
                if i <= reffer_count
                    && j <= commercial_count as libc::c_long
                    && labs(reffer[i as usize].start_frame - commercial[j as usize].start_frame)
                        < 40 as libc::c_int as libc::c_long
                {
                    state = both_commercial;
                    k = commercial[j as usize].start_frame as libc::c_int;
                } else if i > reffer_count
                    || j <= commercial_count as libc::c_long
                        && commercial[j as usize].start_frame < reffer[i as usize].start_frame
                {
                    state = only_commercial;
                    k = commercial[j as usize].start_frame as libc::c_int;
                } else {
                    state = only_reffer;
                    k = reffer[i as usize].start_frame as libc::c_int;
                }
            }
            1 => {
                if i <= reffer_count
                    && j <= commercial_count as libc::c_long
                    && labs(reffer[i as usize].end_frame - commercial[j as usize].end_frame)
                        < 40 as libc::c_int as libc::c_long
                {
                    state = both_show;
                    k = commercial[j as usize].end_frame as libc::c_int;
                    if i <= reffer_count {
                        i += 1;
                        if reffer[i as usize].end_frame - reffer[i as usize].start_frame
                            > 2 as libc::c_int as libc::c_long
                        {
                            if output_training > 1 as libc::c_int {
                                raw2 = myfopen(
                                    b"quality.csv\0" as *const u8 as *const libc::c_char,
                                    b"a+\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                            }
                            if !raw2.is_null() {
                                fprintf(
                                    raw2,
                                    b"\"%s\", %6ld, %6.1f, %6.1f, %6.1f\n\0" as *const u8
                                        as *const libc::c_char,
                                    inbasename.as_mut_ptr(),
                                    reffer[i as usize].start_frame,
                                    0.0f64,
                                    0.0f64,
                                    (if !frame.is_null() {
                                        (if reffer[i as usize].end_frame
                                            <= 0 as libc::c_int as libc::c_long
                                        {
                                            (*frame.offset(1 as libc::c_int as isize)).pts
                                        } else {
                                            (if reffer[i as usize].end_frame
                                                >= framenum_real as libc::c_long
                                            {
                                                (*frame.offset(
                                                    (framenum_real - 1 as libc::c_int) as isize,
                                                ))
                                                .pts
                                            } else {
                                                (*frame
                                                    .offset(reffer[i as usize].end_frame as isize))
                                                .pts
                                            })
                                        })
                                    } else {
                                        reffer[i as usize].end_frame as libc::c_double / fps
                                    }) - (if !frame.is_null() {
                                        (if reffer[i as usize].start_frame
                                            <= 0 as libc::c_int as libc::c_long
                                        {
                                            (*frame.offset(1 as libc::c_int as isize)).pts
                                        } else {
                                            (if reffer[i as usize].start_frame
                                                >= framenum_real as libc::c_long
                                            {
                                                (*frame.offset(
                                                    (framenum_real - 1 as libc::c_int) as isize,
                                                ))
                                                .pts
                                            } else {
                                                (*frame.offset(
                                                    reffer[i as usize].start_frame as isize,
                                                ))
                                                .pts
                                            })
                                        })
                                    } else {
                                        reffer[i as usize].start_frame as libc::c_double / fps
                                    }),
                                );
                            }
                            total += (if !frame.is_null() {
                                (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long
                                {
                                    (*frame.offset(1 as libc::c_int as isize)).pts
                                } else {
                                    (if reffer[i as usize].end_frame
                                        >= framenum_real as libc::c_long
                                    {
                                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                            .pts
                                    } else {
                                        (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                                    })
                                })
                            } else {
                                reffer[i as usize].end_frame as libc::c_double / fps
                            }) - (if !frame.is_null() {
                                (if reffer[i as usize].start_frame
                                    <= 0 as libc::c_int as libc::c_long
                                {
                                    (*frame.offset(1 as libc::c_int as isize)).pts
                                } else {
                                    (if reffer[i as usize].start_frame
                                        >= framenum_real as libc::c_long
                                    {
                                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                            .pts
                                    } else {
                                        (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                                    })
                                })
                            } else {
                                reffer[i as usize].start_frame as libc::c_double / fps
                            });
                            if !raw2.is_null() {
                                fclose(raw2);
                            }
                        }
                    }
                    if j <= commercial_count as libc::c_long {
                        j += 1;
                    }
                } else if i > reffer_count
                    || j <= commercial_count as libc::c_long
                        && commercial[j as usize].end_frame < reffer[i as usize].end_frame
                {
                    state = only_reffer;
                    k = commercial[j as usize].end_frame as libc::c_int;
                    if j <= commercial_count as libc::c_long {
                        j += 1;
                    }
                } else {
                    state = only_commercial;
                    k = reffer[i as usize].end_frame as libc::c_int;
                    if i <= reffer_count {
                        i += 1;
                        if reffer[i as usize].end_frame - reffer[i as usize].start_frame
                            > 2 as libc::c_int as libc::c_long
                        {
                            if output_training > 1 as libc::c_int {
                                raw2 = myfopen(
                                    b"quality.csv\0" as *const u8 as *const libc::c_char,
                                    b"a+\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                            }
                            if !raw2.is_null() {
                                fprintf(
                                    raw2,
                                    b"\"%s\", %6ld, %6.1f, %6.1f, %6.1f\n\0" as *const u8
                                        as *const libc::c_char,
                                    inbasename.as_mut_ptr(),
                                    reffer[i as usize].start_frame,
                                    0.0f64,
                                    0.0f64,
                                    (if !frame.is_null() {
                                        (if reffer[i as usize].end_frame
                                            <= 0 as libc::c_int as libc::c_long
                                        {
                                            (*frame.offset(1 as libc::c_int as isize)).pts
                                        } else {
                                            (if reffer[i as usize].end_frame
                                                >= framenum_real as libc::c_long
                                            {
                                                (*frame.offset(
                                                    (framenum_real - 1 as libc::c_int) as isize,
                                                ))
                                                .pts
                                            } else {
                                                (*frame
                                                    .offset(reffer[i as usize].end_frame as isize))
                                                .pts
                                            })
                                        })
                                    } else {
                                        reffer[i as usize].end_frame as libc::c_double / fps
                                    }) - (if !frame.is_null() {
                                        (if reffer[i as usize].start_frame
                                            <= 0 as libc::c_int as libc::c_long
                                        {
                                            (*frame.offset(1 as libc::c_int as isize)).pts
                                        } else {
                                            (if reffer[i as usize].start_frame
                                                >= framenum_real as libc::c_long
                                            {
                                                (*frame.offset(
                                                    (framenum_real - 1 as libc::c_int) as isize,
                                                ))
                                                .pts
                                            } else {
                                                (*frame.offset(
                                                    reffer[i as usize].start_frame as isize,
                                                ))
                                                .pts
                                            })
                                        })
                                    } else {
                                        reffer[i as usize].start_frame as libc::c_double / fps
                                    }),
                                );
                            }
                            total += (if !frame.is_null() {
                                (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long
                                {
                                    (*frame.offset(1 as libc::c_int as isize)).pts
                                } else {
                                    (if reffer[i as usize].end_frame
                                        >= framenum_real as libc::c_long
                                    {
                                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                            .pts
                                    } else {
                                        (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                                    })
                                })
                            } else {
                                reffer[i as usize].end_frame as libc::c_double / fps
                            }) - (if !frame.is_null() {
                                (if reffer[i as usize].start_frame
                                    <= 0 as libc::c_int as libc::c_long
                                {
                                    (*frame.offset(1 as libc::c_int as isize)).pts
                                } else {
                                    (if reffer[i as usize].start_frame
                                        >= framenum_real as libc::c_long
                                    {
                                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                            .pts
                                    } else {
                                        (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                                    })
                                })
                            } else {
                                reffer[i as usize].start_frame as libc::c_double / fps
                            });
                            if !raw2.is_null() {
                                fclose(raw2);
                            }
                        }
                    }
                }
            }
            2 => {
                if j > commercial_count as libc::c_long
                    || reffer[i as usize].end_frame < commercial[j as usize].start_frame
                {
                    state = both_show;
                    if i <= reffer_count {
                        k = reffer[i as usize].end_frame as libc::c_int;
                    } else {
                        k = commercial[commercial_count as usize].end_frame as libc::c_int;
                    }
                    if i <= reffer_count {
                        i += 1;
                        if reffer[i as usize].end_frame - reffer[i as usize].start_frame
                            > 2 as libc::c_int as libc::c_long
                        {
                            if output_training > 1 as libc::c_int {
                                raw2 = myfopen(
                                    b"quality.csv\0" as *const u8 as *const libc::c_char,
                                    b"a+\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                            }
                            if !raw2.is_null() {
                                fprintf(
                                    raw2,
                                    b"\"%s\", %6ld, %6.1f, %6.1f, %6.1f\n\0" as *const u8
                                        as *const libc::c_char,
                                    inbasename.as_mut_ptr(),
                                    reffer[i as usize].start_frame,
                                    0.0f64,
                                    0.0f64,
                                    (if !frame.is_null() {
                                        (if reffer[i as usize].end_frame
                                            <= 0 as libc::c_int as libc::c_long
                                        {
                                            (*frame.offset(1 as libc::c_int as isize)).pts
                                        } else {
                                            (if reffer[i as usize].end_frame
                                                >= framenum_real as libc::c_long
                                            {
                                                (*frame.offset(
                                                    (framenum_real - 1 as libc::c_int) as isize,
                                                ))
                                                .pts
                                            } else {
                                                (*frame
                                                    .offset(reffer[i as usize].end_frame as isize))
                                                .pts
                                            })
                                        })
                                    } else {
                                        reffer[i as usize].end_frame as libc::c_double / fps
                                    }) - (if !frame.is_null() {
                                        (if reffer[i as usize].start_frame
                                            <= 0 as libc::c_int as libc::c_long
                                        {
                                            (*frame.offset(1 as libc::c_int as isize)).pts
                                        } else {
                                            (if reffer[i as usize].start_frame
                                                >= framenum_real as libc::c_long
                                            {
                                                (*frame.offset(
                                                    (framenum_real - 1 as libc::c_int) as isize,
                                                ))
                                                .pts
                                            } else {
                                                (*frame.offset(
                                                    reffer[i as usize].start_frame as isize,
                                                ))
                                                .pts
                                            })
                                        })
                                    } else {
                                        reffer[i as usize].start_frame as libc::c_double / fps
                                    }),
                                );
                            }
                            total += (if !frame.is_null() {
                                (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long
                                {
                                    (*frame.offset(1 as libc::c_int as isize)).pts
                                } else {
                                    (if reffer[i as usize].end_frame
                                        >= framenum_real as libc::c_long
                                    {
                                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                            .pts
                                    } else {
                                        (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                                    })
                                })
                            } else {
                                reffer[i as usize].end_frame as libc::c_double / fps
                            }) - (if !frame.is_null() {
                                (if reffer[i as usize].start_frame
                                    <= 0 as libc::c_int as libc::c_long
                                {
                                    (*frame.offset(1 as libc::c_int as isize)).pts
                                } else {
                                    (if reffer[i as usize].start_frame
                                        >= framenum_real as libc::c_long
                                    {
                                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize))
                                            .pts
                                    } else {
                                        (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                                    })
                                })
                            } else {
                                reffer[i as usize].start_frame as libc::c_double / fps
                            });
                            if !raw2.is_null() {
                                fclose(raw2);
                            }
                        }
                    }
                } else {
                    state = both_commercial;
                    k = commercial[j as usize].start_frame as libc::c_int;
                }
                if output_training > 1 as libc::c_int {
                    raw2 = myfopen(
                        b"quality.csv\0" as *const u8 as *const libc::c_char,
                        b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    );
                }
                if !raw2.is_null() {
                    fprintf(
                        raw2,
                        b"\"%s\", %6d, %6.1f, %6.1f, %6.1f\n\0" as *const u8 as *const libc::c_char,
                        inbasename.as_mut_ptr(),
                        pk,
                        (if !frame.is_null() {
                            (if k <= 0 as libc::c_int {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if k >= framenum_real {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                                } else {
                                    (*frame.offset(k as isize)).pts
                                })
                            })
                        } else {
                            k as libc::c_double / fps
                        }) - (if !frame.is_null() {
                            (if pk <= 0 as libc::c_int {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if pk >= framenum_real {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                                } else {
                                    (*frame.offset(pk as isize)).pts
                                })
                            })
                        } else {
                            pk as libc::c_double / fps
                        }),
                        0.0f64,
                        0.0f64,
                    );
                }
                fneg += (if !frame.is_null() {
                    (if k <= 0 as libc::c_int {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if k >= framenum_real {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(k as isize)).pts
                        })
                    })
                } else {
                    k as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if pk <= 0 as libc::c_int {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if pk >= framenum_real {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(pk as isize)).pts
                        })
                    })
                } else {
                    pk as libc::c_double / fps
                });
                if !raw2.is_null() {
                    fclose(raw2);
                }
                raw2 = 0 as *mut FILE;
            }
            3 => {
                if i > reffer_count
                    || commercial[j as usize].end_frame < reffer[i as usize].start_frame
                {
                    state = both_show;
                    k = commercial[j as usize].end_frame as libc::c_int;
                    if j <= commercial_count as libc::c_long {
                        j += 1;
                    }
                } else {
                    state = both_commercial;
                    k = reffer[i as usize].start_frame as libc::c_int;
                }
                if output_training > 1 as libc::c_int {
                    raw2 = myfopen(
                        b"quality.csv\0" as *const u8 as *const libc::c_char,
                        b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    );
                }
                if !raw2.is_null() {
                    fprintf(
                        raw2,
                        b"\"%s\", %6d, %6.1f, %6.1f, %6.1f\n\0" as *const u8 as *const libc::c_char,
                        inbasename.as_mut_ptr(),
                        pk,
                        0.0f64,
                        (if !frame.is_null() {
                            (if k <= 0 as libc::c_int {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if k >= framenum_real {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                                } else {
                                    (*frame.offset(k as isize)).pts
                                })
                            })
                        } else {
                            k as libc::c_double / fps
                        }) - (if !frame.is_null() {
                            (if pk <= 0 as libc::c_int {
                                (*frame.offset(1 as libc::c_int as isize)).pts
                            } else {
                                (if pk >= framenum_real {
                                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                                } else {
                                    (*frame.offset(pk as isize)).pts
                                })
                            })
                        } else {
                            pk as libc::c_double / fps
                        }),
                        0.0f64,
                    );
                }
                fpos += (if !frame.is_null() {
                    (if k <= 0 as libc::c_int {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if k >= framenum_real {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(k as isize)).pts
                        })
                    })
                } else {
                    k as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if pk <= 0 as libc::c_int {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if pk >= framenum_real {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(pk as isize)).pts
                        })
                    })
                } else {
                    pk as libc::c_double / fps
                });
                if !raw2.is_null() {
                    fclose(raw2);
                }
                raw2 = 0 as *mut FILE;
            }
            _ => {}
        }
    }
    if output_training != 0 {
        raw2 = myfopen(
            b"quality.csv\0" as *const u8 as *const libc::c_char,
            b"a+\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if !raw2.is_null() {
        fprintf(
            raw2,
            b"\"%s\", %6d, %6.1f, %6.1f, %6.1f\n\0" as *const u8 as *const libc::c_char,
            inbasename.as_mut_ptr(),
            -(1 as libc::c_int),
            fneg,
            fpos,
            total,
        );
    }
    if !raw2.is_null() {
        fclose(raw2);
    }
    j = 0 as libc::c_int as libc::c_long;
    i = 0 as libc::c_int;
    while i <= reffer_count && j <= commercial_count as libc::c_long {
        k = min(
            reffer[i as usize].start_frame as libc::c_int,
            commercial[j as usize].start_frame as libc::c_int,
        );
        if commercial[j as usize].end_frame < reffer[i as usize].start_frame {
            fprintf(
                raw,
                b"Found %6ld %6ld    Reference %6ld %6ld    Difference %+6.1f    %+6.1f\n\0"
                    as *const u8 as *const libc::c_char,
                commercial[j as usize].start_frame,
                commercial[j as usize].end_frame,
                0 as libc::c_long,
                0 as libc::c_long,
                (if !frame.is_null() {
                    (if commercial[j as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if commercial[j as usize].end_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(commercial[j as usize].end_frame as isize)).pts
                        })
                    })
                } else {
                    commercial[j as usize].end_frame as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if commercial[j as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if commercial[j as usize].start_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(commercial[j as usize].start_frame as isize)).pts
                        })
                    })
                } else {
                    commercial[j as usize].start_frame as libc::c_double / fps
                }),
                (if !frame.is_null() {
                    (if commercial[j as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if commercial[j as usize].end_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(commercial[j as usize].end_frame as isize)).pts
                        })
                    })
                } else {
                    commercial[j as usize].end_frame as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if commercial[j as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if commercial[j as usize].start_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(commercial[j as usize].start_frame as isize)).pts
                        })
                    })
                } else {
                    commercial[j as usize].start_frame as libc::c_double / fps
                }),
            );
            j += 1;
        } else if commercial[j as usize].start_frame > reffer[i as usize].end_frame {
            fprintf(
                raw,
                b"Found %6ld %6ld    Reference %6ld %6ld    Difference %+6.1f    %+6.1f\n\0"
                    as *const u8 as *const libc::c_char,
                0 as libc::c_long,
                0 as libc::c_long,
                reffer[i as usize].start_frame,
                reffer[i as usize].end_frame,
                -((if !frame.is_null() {
                    (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if reffer[i as usize].end_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                        })
                    })
                } else {
                    reffer[i as usize].end_frame as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if reffer[i as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if reffer[i as usize].start_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                        })
                    })
                } else {
                    reffer[i as usize].start_frame as libc::c_double / fps
                })),
                -((if !frame.is_null() {
                    (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if reffer[i as usize].end_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                        })
                    })
                } else {
                    reffer[i as usize].end_frame as libc::c_double / fps
                }) - (if !frame.is_null() {
                    (if reffer[i as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if reffer[i as usize].start_frame >= framenum_real as libc::c_long {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                        })
                    })
                } else {
                    reffer[i as usize].start_frame as libc::c_double / fps
                })),
            );
            i += 1;
        } else {
            if labs(reffer[i as usize].start_frame - commercial[j as usize].start_frame)
                > 40 as libc::c_int as libc::c_long
                || labs(reffer[i as usize].end_frame - commercial[j as usize].end_frame)
                    > 40 as libc::c_int as libc::c_long
            {
                fprintf(
                    raw,
                    b"Found %6ld %6ld    Reference %6ld %6ld    Difference %+6.1f    %+6.1f\n\0"
                        as *const u8 as *const libc::c_char,
                    commercial[j as usize].start_frame,
                    commercial[j as usize].end_frame,
                    reffer[i as usize].start_frame,
                    reffer[i as usize].end_frame,
                    (if !frame.is_null() {
                        (if reffer[i as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if reffer[i as usize].start_frame >= framenum_real as libc::c_long {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                            })
                        })
                    } else {
                        reffer[i as usize].start_frame as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if commercial[j as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if commercial[j as usize].start_frame >= framenum_real as libc::c_long
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(commercial[j as usize].start_frame as isize)).pts
                            })
                        })
                    } else {
                        commercial[j as usize].start_frame as libc::c_double / fps
                    }),
                    (if !frame.is_null() {
                        (if commercial[j as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if commercial[j as usize].end_frame >= framenum_real as libc::c_long {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(commercial[j as usize].end_frame as isize)).pts
                            })
                        })
                    } else {
                        commercial[j as usize].end_frame as libc::c_double / fps
                    }) - (if !frame.is_null() {
                        (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if reffer[i as usize].end_frame >= framenum_real as libc::c_long {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                            })
                        })
                    } else {
                        reffer[i as usize].end_frame as libc::c_double / fps
                    }),
                );
            }
            i += 1;
            j += 1;
        }
    }
    while j <= commercial_count as libc::c_long {
        fprintf(
            raw,
            b"Found %6ld %6ld    Reference %6ld %6ld    Difference %+6.1f    %+6.1f\n\0"
                as *const u8 as *const libc::c_char,
            commercial[j as usize].start_frame,
            commercial[j as usize].end_frame,
            0 as libc::c_long,
            0 as libc::c_long,
            (if !frame.is_null() {
                (if commercial[j as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[j as usize].end_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[j as usize].end_frame as isize)).pts
                    })
                })
            } else {
                commercial[j as usize].end_frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if commercial[j as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[j as usize].start_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[j as usize].start_frame as isize)).pts
                    })
                })
            } else {
                commercial[j as usize].start_frame as libc::c_double / fps
            }),
            (if !frame.is_null() {
                (if commercial[j as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[j as usize].end_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[j as usize].end_frame as isize)).pts
                    })
                })
            } else {
                commercial[j as usize].end_frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if commercial[j as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if commercial[j as usize].start_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(commercial[j as usize].start_frame as isize)).pts
                    })
                })
            } else {
                commercial[j as usize].start_frame as libc::c_double / fps
            }),
        );
        j += 1;
    }
    while i <= reffer_count {
        fprintf(
            raw,
            b"Found %6ld %6ld    Reference %6ld %6ld    Difference %+6.1f    %+6.1f\n\0"
                as *const u8 as *const libc::c_char,
            0 as libc::c_long,
            0 as libc::c_long,
            reffer[i as usize].start_frame,
            reffer[i as usize].end_frame,
            -((if !frame.is_null() {
                (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if reffer[i as usize].end_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                    })
                })
            } else {
                reffer[i as usize].end_frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if reffer[i as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if reffer[i as usize].start_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                    })
                })
            } else {
                reffer[i as usize].start_frame as libc::c_double / fps
            })),
            -((if !frame.is_null() {
                (if reffer[i as usize].end_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if reffer[i as usize].end_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(reffer[i as usize].end_frame as isize)).pts
                    })
                })
            } else {
                reffer[i as usize].end_frame as libc::c_double / fps
            }) - (if !frame.is_null() {
                (if reffer[i as usize].start_frame <= 0 as libc::c_int as libc::c_long {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else {
                    (if reffer[i as usize].start_frame >= framenum_real as libc::c_long {
                        (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                    } else {
                        (*frame.offset(reffer[i as usize].start_frame as isize)).pts
                    })
                })
            } else {
                reffer[i as usize].start_frame as libc::c_double / fps
            })),
        );
        i += 1;
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        co = CheckFramesForCommercial(
            (cblock[i as usize].f_start + cblock[i as usize].b_head as libc::c_long) as libc::c_int,
            (cblock[i as usize].f_end - cblock[i as usize].b_tail as libc::c_long) as libc::c_int,
        );
        re = CheckFramesForReffer(
            (cblock[i as usize].f_start + cblock[i as usize].b_head as libc::c_long) as libc::c_int,
            (cblock[i as usize].f_end - cblock[i as usize].b_tail as libc::c_long) as libc::c_int,
        );
        if co as libc::c_int != re as libc::c_int {
            fprintf(
                raw,
                b"Block %6d has mismatch %c%c with cause %s\n\0" as *const u8
                    as *const libc::c_char,
                i,
                co as libc::c_int,
                re as libc::c_int,
                CauseString(cblock[i as usize].cause),
            );
        }
        cblock[i as usize].reffer = re;
        i += 1;
    }
    fclose(raw);
    return frames;
}
#[no_mangle]
pub unsafe extern "C" fn OutputAspect() {
    let mut i: libc::c_int = 0;
    let mut array: [libc::c_char; 1024] = [0; 1024];
    let mut raw: *mut FILE = 0 as *mut FILE;
    if !output_aspect {
        return;
    }
    sprintf(
        array.as_mut_ptr(),
        b"%.*s.aspects\0" as *const u8 as *const libc::c_char,
        (strlen(logfilename.as_mut_ptr())).wrapping_sub(4 as libc::c_int as libc::c_ulong)
            as libc::c_int,
        logfilename.as_mut_ptr(),
    );
    raw = myfopen(
        array.as_mut_ptr(),
        b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if raw.is_null() {
        Debug(
            1 as libc::c_int,
            b"Could not open aspect output file.\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return;
    }
    i = 0 as libc::c_int;
    while (i as libc::c_long) < ar_block_count {
        fprintf(
            raw,
            b"%s %4dx%4d %.2f minX=%4d, minY=%4d, maxX=%4d, maxY=%4d\n\0" as *const u8
                as *const libc::c_char,
            dblSecondsToStrMinutes(if !frame.is_null() {
                if (*ar_block.offset(i as isize)).start <= 0 as libc::c_int {
                    (*frame.offset(1 as libc::c_int as isize)).pts
                } else if (*ar_block.offset(i as isize)).start >= framenum_real {
                    (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                } else {
                    (*frame.offset((*ar_block.offset(i as isize)).start as isize)).pts
                }
            } else {
                (*ar_block.offset(i as isize)).start as libc::c_double / fps
            }),
            (*ar_block.offset(i as isize)).width,
            (*ar_block.offset(i as isize)).height,
            (*ar_block.offset(i as isize)).ar_ratio,
            (*ar_block.offset(i as isize)).minX,
            (*ar_block.offset(i as isize)).minY,
            (*ar_block.offset(i as isize)).maxX,
            (*ar_block.offset(i as isize)).maxY,
        );
        i += 1;
    }
    fclose(raw);
}
#[no_mangle]
pub unsafe extern "C" fn OutputBlackArray() {
    let mut i: libc::c_int = 0;
    let mut array: [libc::c_char; 1024] = [0; 1024];
    let mut raw: *mut FILE = 0 as *mut FILE;
}
#[no_mangle]
pub unsafe extern "C" fn OutputFrameArray(mut screenOnly: bool) {
    let mut i: libc::c_int = 0;
    let mut array: [libc::c_char; 1024] = [0; 1024];
    let mut raw: *mut FILE = 0 as *mut FILE;
    let mut lp: [libc::c_char; 10] = [0; 10];
    sprintf(
        array.as_mut_ptr(),
        b"%.*s.csv\0" as *const u8 as *const libc::c_char,
        (strlen(logfilename.as_mut_ptr())).wrapping_sub(4 as libc::c_int as libc::c_ulong)
            as libc::c_int,
        logfilename.as_mut_ptr(),
    );
    raw = myfopen(
        array.as_mut_ptr(),
        b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if raw.is_null() {
        Debug(
            1 as libc::c_int,
            b"Could not open raw output file.\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        return;
    }
    fprintf(
        raw,
        b"sep=,\nframe,brightness,scene_change,logo,uniform,sound,minY,MaxY,ar_ratio,goodEdge,isblack,cutscene, MinX, MaxX, hasBright, Dimcount,PTS,%f\0"
            as *const u8 as *const libc::c_char,
        fps,
    );
    fprintf(raw, b"\n\0" as *const u8 as *const libc::c_char);
    if screenOnly {
        Debug(
            1 as libc::c_int,
            b"Frame\tBlack\tBrightness\tS_Change\tS_Change Perc\tLogo Present\t%i\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            frame_count,
        );
    }
    i = 1 as libc::c_int;
    while (i as libc::c_long) < frame_count {
        if screenOnly {
            printf(
                b"%i\t%i\t%i\t%s\tHistogram\n\0" as *const u8 as *const libc::c_char,
                i,
                (*frame.offset(i as isize)).brightness,
                (*frame.offset(i as isize)).schange_percent,
                lp.as_mut_ptr(),
            );
        } else {
            fprintf(
                raw,
                b"%i,%i,%i,%i,%i,%i,%i,%i,%f,%f,%i,%i,%i,%i,%i,%i,%f,%i,%i\0" as *const u8
                    as *const libc::c_char,
                i,
                (*frame.offset(i as isize)).brightness,
                (*frame.offset(i as isize)).schange_percent * 5 as libc::c_int,
                (*frame.offset(i as isize)).logo_present as libc::c_int,
                (*frame.offset(i as isize)).uniform,
                (*frame.offset(i as isize)).volume,
                (*frame.offset(i as isize)).minY,
                (*frame.offset(i as isize)).maxY,
                (*frame.offset(i as isize)).ar_ratio,
                (*frame.offset(i as isize)).currentGoodEdge,
                (*frame.offset(i as isize)).isblack as libc::c_int,
                (*frame.offset(i as isize)).cutscenematch,
                (*frame.offset(i as isize)).minX,
                (*frame.offset(i as isize)).maxX,
                (*frame.offset(i as isize)).hasBright,
                (*frame.offset(i as isize)).dimCount,
                (*frame.offset(i as isize)).pts,
                (*frame.offset(i as isize)).cur_segment,
                (*frame.offset(i as isize)).audio_channels,
            );
            fprintf(raw, b"\n\0" as *const u8 as *const libc::c_char);
        }
        i += 1;
    }
    fclose(raw);
}
#[no_mangle]
pub unsafe extern "C" fn InitializeFrameArray(mut i: libc::c_long) {
    if frame_count + 1000 as libc::c_int as libc::c_long >= max_frame_count {
        max_frame_count +=
            (60 as libc::c_int * 60 as libc::c_int * 25 as libc::c_int) as libc::c_long;
        frame = realloc(
            frame as *mut libc::c_void,
            (max_frame_count as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<frame_info>() as libc::c_ulong),
        ) as *mut frame_info;
        Debug(
            9 as libc::c_int,
            b"Resizing frame array to accomodate %i frames.\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            max_frame_count,
        );
        if frame.is_null() {
            Debug(
                0 as libc::c_int,
                b"Failed to allocated space for the frame array, quitting \n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            exit(1 as libc::c_int);
        }
    }
    (*frame.offset(i as isize)).brightness = 0 as libc::c_int;
    (*frame.offset(i as isize)).logo_present = 0 as libc::c_int != 0;
    (*frame.offset(i as isize)).schange_percent = 100 as libc::c_int;
    (*frame.offset(i as isize)).cutscenematch = 0 as libc::c_int;
    (*frame.offset(i as isize)).uniform = 0 as libc::c_int;
    (*frame.offset(i as isize)).ar_ratio = 0.0f64;
    (*frame.offset(i as isize)).audio_channels = 0 as libc::c_int;
    (*frame.offset(i as isize)).minY = 0 as libc::c_int;
    (*frame.offset(i as isize)).maxY = 0 as libc::c_int;
    (*frame.offset(i as isize)).isblack = 0 as libc::c_int != 0;
    if i > 0 as libc::c_int as libc::c_long {
        (*frame.offset(i as isize)).xds =
            (*frame.offset((i - 1 as libc::c_int as libc::c_long) as isize)).xds;
    } else {
        (*frame.offset(i as isize)).xds = 0 as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn InitializeBlackArray(mut i: libc::c_long) {
    if black_count >= max_black_count {
        max_black_count += 500 as libc::c_int as libc::c_long;
        black = realloc(
            black as *mut libc::c_void,
            ((max_black_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<black_frame_info>() as libc::c_ulong),
        ) as *mut black_frame_info;
        Debug(
            9 as libc::c_int,
            b"Resizing black frame array to accomodate %i frames.\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            max_black_count,
        );
    }
    (*black.offset(i as isize)).brightness = 255 as libc::c_int;
    (*black.offset(i as isize)).uniform = 0 as libc::c_int as libc::c_long;
    (*black.offset(i as isize)).volume = curvolume;
}
#[no_mangle]
pub unsafe extern "C" fn InitializeSchangeArray(mut i: libc::c_long) {
    if i >= max_schange_count {
        max_schange_count += 2000 as libc::c_int as libc::c_long;
        let mut ptr: *mut libc::c_void = realloc(
            schange as *mut libc::c_void,
            ((max_schange_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<schange_info>() as libc::c_ulong),
        );
        if ptr.is_null() {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for %i scene change frames.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                max_schange_count,
            );
            exit(12 as libc::c_int);
        }
        schange = ptr as *mut schange_info;
        Debug(
            9 as libc::c_int,
            b"Resizing scene change array to accomodate %i frames.\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            max_schange_count,
        );
    }
    (*schange.offset(i as isize)).frame = i;
    (*schange.offset(i as isize)).percentage = 100 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn InitializeLogoBlockArray(mut i: libc::c_long) {
    if logo_block_count >= max_logo_block_count {
        max_logo_block_count += 20 as libc::c_int as libc::c_long;
        logo_block = realloc(
            logo_block as *mut libc::c_void,
            ((max_logo_block_count + 2 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<logo_block_info>() as libc::c_ulong),
        ) as *mut logo_block_info;
        Debug(
            9 as libc::c_int,
            b"Resizing logo cblock array to accomodate %i logo groups.\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            max_logo_block_count,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn InitializeARBlockArray(mut i: libc::c_long) {
    if ar_block_count >= max_ar_block_count {
        max_ar_block_count += 20 as libc::c_int as libc::c_long;
        ar_block = realloc(
            ar_block as *mut libc::c_void,
            ((max_ar_block_count + 2 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<ar_block_info>() as libc::c_ulong),
        ) as *mut ar_block_info;
        Debug(
            9 as libc::c_int,
            b"Resizing aspect ratio cblock array to accomodate %i AR groups.\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            max_ar_block_count,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn InitializeACBlockArray(mut i: libc::c_long) {
    if ac_block_count >= max_ac_block_count {
        max_ac_block_count += 20 as libc::c_int as libc::c_long;
        ac_block = realloc(
            ac_block as *mut libc::c_void,
            ((max_ac_block_count + 2 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<ac_block_info>() as libc::c_ulong),
        ) as *mut ac_block_info;
        Debug(
            9 as libc::c_int,
            b"Resizing audio channel block array to accomodate %i AC groups.\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            max_ac_block_count,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn InitializeBlockArray(mut i: libc::c_long) {
    if block_count >= max_block_count {
        Debug(
            0 as libc::c_int,
            b"Panic, too many blocks\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        exit(102 as libc::c_int);
    }
    cblock[i as usize].f_start = 0 as libc::c_int as libc::c_long;
    cblock[i as usize].f_end = 0 as libc::c_int as libc::c_long;
    cblock[i as usize].b_head = 0 as libc::c_int as libc::c_uint;
    cblock[i as usize].b_tail = 0 as libc::c_int as libc::c_uint;
    cblock[i as usize].bframe_count = 0 as libc::c_int as libc::c_uint;
    cblock[i as usize].schange_count = 0 as libc::c_int as libc::c_uint;
    cblock[i as usize].schange_rate = 0 as libc::c_int as libc::c_double;
    cblock[i as usize].length = 0 as libc::c_int as libc::c_double;
    cblock[i as usize].score = 1.0f64;
    cblock[i as usize].combined_count = 0 as libc::c_int;
    cblock[i as usize].ar_ratio = 0.0f64;
    cblock[i as usize].audio_channels = 0 as libc::c_int;
    cblock[i as usize].brightness = 0 as libc::c_int;
    cblock[i as usize].volume = 0 as libc::c_int;
    cblock[i as usize].silence = 0 as libc::c_int;
    cblock[i as usize].stdev = 0 as libc::c_int;
    cblock[i as usize].cause = 0 as libc::c_int;
    cblock[i as usize].less = 0 as libc::c_int;
    cblock[i as usize].more = 0 as libc::c_int;
    cblock[i as usize].uniform = 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn InitializeCCBlockArray(mut i: libc::c_long) {
    if cc_block_count >= max_cc_block_count {
        max_cc_block_count += 100 as libc::c_int as libc::c_long;
        cc_block = realloc(
            cc_block as *mut libc::c_void,
            ((max_cc_block_count + 2 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<cc_block_info>() as libc::c_ulong),
        ) as *mut cc_block_info;
        Debug(
            9 as libc::c_int,
            b"Resizing cc cblock array to accomodate %i cc blocks.\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            max_cc_block_count,
        );
    }
    (*cc_block.offset(i as isize)).start_frame = -(1 as libc::c_int) as libc::c_long;
    (*cc_block.offset(i as isize)).end_frame = -(1 as libc::c_int) as libc::c_long;
    (*cc_block.offset(i as isize)).type_0 = 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn InitializeCCTextArray(mut i: libc::c_long) {
    if cc_text_count >= max_cc_text_count {
        max_cc_text_count += 100 as libc::c_int as libc::c_long;
        cc_text = realloc(
            cc_text as *mut libc::c_void,
            ((max_cc_text_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<cc_text_info>() as libc::c_ulong),
        ) as *mut cc_text_info;
        Debug(
            9 as libc::c_int,
            b"Resizing cc text array to accomodate %i cc text groups.\n\0" as *const u8
                as *const libc::c_char as *mut libc::c_char,
            max_cc_text_count,
        );
    }
    (*cc_text.offset(i as isize)).text[0 as libc::c_int as usize] = '\0' as i32 as libc::c_uchar;
    (*cc_text.offset(i as isize)).text_len = 0 as libc::c_int as libc::c_long;
}
#[no_mangle]
pub unsafe extern "C" fn PrintArgs() {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < argument_count {
        printf(
            b"%i\t%s\n\0" as *const u8 as *const libc::c_char,
            i,
            *argument.offset(i as isize),
        );
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn ProcessCSV(mut in_file_0: *mut FILE) {
    let mut lineProcessed: bool = 0 as libc::c_int != 0;
    let mut lastLogoTest_0: bool = 0 as libc::c_int != 0;
    let mut curLogoTest_0: bool = 0 as libc::c_int != 0;
    let mut line: [libc::c_char; 2048] = [0; 2048];
    let mut split: [libc::c_char; 256] = [0; 256];
    let mut cont: libc::c_int = 0 as libc::c_int;
    let mut minminY: libc::c_int = 10000 as libc::c_int;
    let mut maxmaxY: libc::c_int = 0 as libc::c_int;
    let mut minminX: libc::c_int = 10000 as libc::c_int;
    let mut maxmaxX: libc::c_int = 0 as libc::c_int;
    let mut cutscene_nonzero_count: libc::c_int = 0 as libc::c_int;
    let mut old_format: libc::c_int = 1 as libc::c_int;
    let mut use_bright: libc::c_int = 0 as libc::c_int;
    let mut t: libc::c_double = 0.;
    let mut i: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut f: libc::c_int = 0;
    let mut col: libc::c_int = 0;
    let mut ccDataFrame: libc::c_int = 0;
    loop {
        logoInfoAvailable = 1 as libc::c_int != 0;
        if in_file_0.is_null() {
            Debug(
                0 as libc::c_int,
                b"Something went wrong... Exiting...\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            exit(22 as libc::c_int);
        }
        fgets(
            line.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong as libc::c_int,
            in_file_0,
        );
        if strcmp(
            line.as_mut_ptr(),
            b"sep=,\n\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
        {
            fgets(
                line.as_mut_ptr(),
                ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong as libc::c_int,
                in_file_0,
            );
        }
        t = 0.0f64;
        if line[85 as libc::c_int as usize] as libc::c_int == ';' as i32 {
            line[85 as libc::c_int as usize] = '+' as i32 as libc::c_char;
        }
        if strlen(line.as_mut_ptr()) > 85 as libc::c_int as libc::c_ulong {
            t = strtol(
                &mut *line.as_mut_ptr().offset(85 as libc::c_int as isize),
                0 as *mut *mut libc::c_char,
                10 as libc::c_int,
            ) as libc::c_double
                / 100 as libc::c_int as libc::c_double;
            if t > 99 as libc::c_int as libc::c_double {
                t = t / 10.0f64;
            }
        }
        if t > 0 as libc::c_int as libc::c_double {
            fps = t * 1.00000000000001f64;
        }
        if strlen(line.as_mut_ptr()) > 94 as libc::c_int as libc::c_ulong {
            t = strtol(
                &mut *line.as_mut_ptr().offset(94 as libc::c_int as isize),
                0 as *mut *mut libc::c_char,
                10 as libc::c_int,
            ) as libc::c_double
                / 100 as libc::c_int as libc::c_double;
            if t > 99 as libc::c_int as libc::c_double {
                t = t / 10.0f64;
            }
        }
        if t > 0 as libc::c_int as libc::c_double {
            fps = t * 1.00000000000001f64;
        }
        if strlen(line.as_mut_ptr()) > 131 as libc::c_int as libc::c_ulong {
            t = strtod(
                &mut *line.as_mut_ptr().offset(131 as libc::c_int as isize),
                0 as *mut *mut libc::c_char,
            );
            if (strchr(
                &mut *line.as_mut_ptr().offset(131 as libc::c_int as isize),
                '.' as i32,
            ))
            .is_null()
            {
                t /= 100.0f64;
                if t > 99 as libc::c_int as libc::c_double {
                    t /= 10.0f64;
                }
                if t > 0 as libc::c_int as libc::c_double {
                    fps = t * 1.00000000000001f64;
                }
            } else if t > 0 as libc::c_int as libc::c_double {
                fps = t;
            }
        }
        InitComSkip();
        frame_count = 1 as libc::c_int as libc::c_long;
        pict_type = '?' as i32 as libc::c_char;
        while !(fgets(
            line.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong as libc::c_int,
            in_file_0,
        ))
        .is_null()
        {
            i = 0 as libc::c_int;
            x = 0 as libc::c_int;
            col = 0 as libc::c_int;
            lineProcessed = 0 as libc::c_int != 0;
            InitializeFrameArray(frame_count);
            (*frame.offset(frame_count as isize)).minX = 0 as libc::c_int;
            (*frame.offset(frame_count as isize)).maxX = 0 as libc::c_int;
            (*frame.offset(frame_count as isize)).hasBright = 0 as libc::c_int;
            (*frame.offset(frame_count as isize)).dimCount = 0 as libc::c_int;
            (*frame.offset(frame_count as isize)).pts =
                (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_double / fps;
            (*frame.offset(frame_count as isize)).pict_type = '?' as i32 as libc::c_char;
            (*frame.offset(frame_count as isize)).audio_channels = 2 as libc::c_int;
            while line[i as usize] as libc::c_int != '\0' as i32
                && i < ::std::mem::size_of::<[libc::c_char; 2048]>() as libc::c_ulong as libc::c_int
                && !lineProcessed
            {
                if line[i as usize] as libc::c_int == ';' as i32
                    || line[i as usize] as libc::c_int == ',' as i32
                    || line[i as usize] as libc::c_int == '\n' as i32
                {
                    split[x as usize] = '\0' as i32 as libc::c_char;
                    match col {
                        0 => {
                            f = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            ) as libc::c_int;
                            if f as libc::c_long != frame_count {
                                Debug(
                                    0 as libc::c_int,
                                    b"Shit!!!!\n\0" as *const u8 as *const libc::c_char
                                        as *mut libc::c_char,
                                );
                                exit(23 as libc::c_int);
                            }
                        }
                        1 => {
                            (*frame.offset(frame_count as isize)).brightness = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                        }
                        2 => {
                            (*frame.offset(frame_count as isize)).schange_percent =
                                (strtol(
                                    split.as_mut_ptr(),
                                    0 as *mut *mut libc::c_char,
                                    10 as libc::c_int,
                                ) / 5 as libc::c_int as libc::c_long)
                                    as libc::c_int;
                        }
                        3 => {
                            (*frame.offset(frame_count as isize)).logo_present = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            ) != 0;
                        }
                        4 => {
                            (*frame.offset(frame_count as isize)).uniform = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                        }
                        5 => {
                            (*frame.offset(frame_count as isize)).volume = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                        }
                        6 => {
                            (*frame.offset(frame_count as isize)).minY = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                            if minminY > (*frame.offset(frame_count as isize)).minY {
                                minminY = (*frame.offset(frame_count as isize)).minY;
                            }
                        }
                        7 => {
                            (*frame.offset(frame_count as isize)).maxY = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                            if maxmaxY < (*frame.offset(frame_count as isize)).maxY {
                                maxmaxY = (*frame.offset(frame_count as isize)).maxY;
                            }
                        }
                        8 => {
                            (*frame.offset(frame_count as isize)).ar_ratio =
                                strtod(split.as_mut_ptr(), 0 as *mut *mut libc::c_char);
                            if (strchr(split.as_mut_ptr(), '.' as i32)).is_null() {
                                (*frame.offset(frame_count as isize)).ar_ratio /=
                                    100 as libc::c_int as libc::c_double;
                            }
                        }
                        9 => {
                            (*frame.offset(frame_count as isize)).currentGoodEdge =
                                strtod(split.as_mut_ptr(), 0 as *mut *mut libc::c_char);
                            if (strchr(split.as_mut_ptr(), '.' as i32)).is_null() {
                                (*frame.offset(frame_count as isize)).currentGoodEdge /=
                                    500 as libc::c_int as libc::c_double;
                            }
                        }
                        10 => {
                            (*frame.offset(frame_count as isize)).isblack = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            ) != 0;
                            if !((*frame.offset(frame_count as isize)).isblack as libc::c_int
                                == 0 as libc::c_int
                                || (*frame.offset(frame_count as isize)).isblack as libc::c_int
                                    == 1 as libc::c_int)
                            {
                                old_format = 0 as libc::c_int;
                            }
                        }
                        11 => {
                            (*frame.offset(frame_count as isize)).cutscenematch = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                            if (*frame.offset(frame_count as isize)).cutscenematch
                                > 0 as libc::c_int
                            {
                                cutscene_nonzero_count += 1;
                            }
                        }
                        12 => {
                            (*frame.offset(frame_count as isize)).minX = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                            if minminX > (*frame.offset(frame_count as isize)).minX {
                                minminX = (*frame.offset(frame_count as isize)).minX;
                            }
                        }
                        13 => {
                            (*frame.offset(frame_count as isize)).maxX = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                            if maxmaxX < (*frame.offset(frame_count as isize)).maxX {
                                maxmaxX = (*frame.offset(frame_count as isize)).maxX;
                            }
                        }
                        14 => {
                            (*frame.offset(frame_count as isize)).hasBright = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                        }
                        15 => {
                            (*frame.offset(frame_count as isize)).dimCount = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                        }
                        16 => {
                            (*frame.offset(frame_count as isize)).pts =
                                strtod(split.as_mut_ptr(), 0 as *mut *mut libc::c_char);
                        }
                        17 => {
                            (*frame.offset(frame_count as isize)).cur_segment = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                        }
                        18 => {
                            (*frame.offset(frame_count as isize)).audio_channels = strtol(
                                split.as_mut_ptr(),
                                0 as *mut *mut libc::c_char,
                                10 as libc::c_int,
                            )
                                as libc::c_int;
                        }
                        _ => {}
                    }
                    col += 1;
                    x = 0 as libc::c_int;
                    split[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
                    if col > 256 as libc::c_int + 9 as libc::c_int {
                        lineProcessed = 1 as libc::c_int != 0;
                    }
                } else {
                    split[x as usize] = line[i as usize];
                    x += 1;
                }
                i += 1;
            }
            if frame_count == 1 as libc::c_int as libc::c_long {
                (*frame.offset(0 as libc::c_int as isize)).pts =
                    (*frame.offset(1 as libc::c_int as isize)).pts;
            }
            frame_count += 1;
        }
        (*frame.offset(frame_count as isize)).pts =
            (frame_count - 1 as libc::c_int as libc::c_long) as libc::c_double / fps;
        if dump_data_file.is_null() {
            sprintf(
                line.as_mut_ptr(),
                b"%s.data\0" as *const u8 as *const libc::c_char,
                workbasename.as_mut_ptr(),
            );
            dump_data_file = myfopen(
                line.as_mut_ptr(),
                b"rb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
        }
        ccDataFrame = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < 1000 as libc::c_int && (i as libc::c_long) < frame_count {
            if (*frame.offset(i as isize)).hasBright > 0 as libc::c_int {
                use_bright = 1 as libc::c_int;
            }
            i += 1;
        }
        height = maxmaxY + minminY;
        width = maxmaxX + minminX;
        videowidth = width;
        last_brightness = (*frame.offset(1 as libc::c_int as isize)).brightness;
        Debug(
            8 as libc::c_int,
            b"CSV file loaded into memory.\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
        fclose(in_file_0);
        in_file_0 = 0 as *mut FILE;
        black_count = 0 as libc::c_int as libc::c_long;
        logo_block_count = 0 as libc::c_int as libc::c_long;
        black_count = 0 as libc::c_int as libc::c_long;
        schange_count = 0 as libc::c_int as libc::c_long;
        min_brightness_found = 255 as libc::c_int;
        i = 1 as libc::c_int;
        while (i as libc::c_long) < frame_count {
            framenum_real = i;
            loop {
                if !dump_data_file.is_null() && ccDataFrame == 0 as libc::c_int {
                    cont = fread(
                        line.as_mut_ptr() as *mut libc::c_void,
                        8 as libc::c_int as libc::c_ulong,
                        1 as libc::c_int as libc::c_ulong,
                        dump_data_file,
                    ) as libc::c_int;
                    line[8 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
                    sscanf(
                        line.as_mut_ptr(),
                        b"%7d:\0" as *const u8 as *const libc::c_char,
                        &mut ccDataFrame as *mut libc::c_int,
                    );
                }
                if dump_data_file.is_null() {
                    break;
                }
                if !(cont != 0 && ccDataFrame <= i) {
                    break;
                }
                cont = fread(
                    line.as_mut_ptr() as *mut libc::c_void,
                    4 as libc::c_int as libc::c_ulong,
                    1 as libc::c_int as libc::c_ulong,
                    dump_data_file,
                ) as libc::c_int;
                if cont == 0 {
                    break;
                }
                line[4 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
                sscanf(
                    line.as_mut_ptr(),
                    b"%4d\0" as *const u8 as *const libc::c_char,
                    &mut ccDataLen as *mut libc::c_int,
                );
                cont = fread(
                    ccData.as_mut_ptr() as *mut libc::c_void,
                    ccDataLen as libc::c_ulong,
                    1 as libc::c_int as libc::c_ulong,
                    dump_data_file,
                ) as libc::c_int;
                if cont == 0 {
                    break;
                }
                framenum = ccDataFrame;
                if processCC {
                    ProcessCCData();
                }
                if output_srt as libc::c_int != 0 || output_smi as libc::c_int != 0 {
                    process_block(ccData.as_mut_ptr(), ccDataLen as libc::c_long);
                }
                ccDataFrame = 0 as libc::c_int;
            }
            if old_format != 0 {
                if (*frame.offset(i as isize)).isblack {
                    if (*frame.offset(i as isize)).brightness <= 5 as libc::c_int {
                        if (*frame.offset(i as isize)).brightness == 5 as libc::c_int {
                            (*frame.offset(i as isize)).isblack =
                                (1 as libc::c_int) << 5 as libc::c_int != 0;
                        }
                        if (*frame.offset(i as isize)).brightness == 4 as libc::c_int {
                            (*frame.offset(i as isize)).isblack =
                                (1 as libc::c_int) << 3 as libc::c_int != 0;
                        }
                        if (*frame.offset(i as isize)).brightness == 3 as libc::c_int {
                            (*frame.offset(i as isize)).isblack =
                                (1 as libc::c_int) << 2 as libc::c_int != 0;
                        }
                        if (*frame.offset(i as isize)).brightness == 2 as libc::c_int {
                            (*frame.offset(i as isize)).isblack =
                                (1 as libc::c_int) << 2 as libc::c_int != 0;
                        }
                        if (*frame.offset(i as isize)).brightness == 1 as libc::c_int {
                            (*frame.offset(i as isize)).isblack =
                                (1 as libc::c_int) << 3 as libc::c_int != 0;
                        }
                        (*frame.offset(i as isize)).brightness =
                            max_avg_brightness + 1 as libc::c_int;
                    } else {
                        (*frame.offset(i as isize)).isblack =
                            (1 as libc::c_int) << 4 as libc::c_int != 0;
                    }
                } else {
                    (*frame.offset(i as isize)).isblack = 0 as libc::c_int != 0;
                }
            }
            if (*frame.offset(i as isize)).brightness > 0 as libc::c_int {
                brightHistogram[(*frame.offset(i as isize)).brightness as usize] += 1;
                if (*frame.offset(i as isize)).brightness < min_brightness_found {
                    min_brightness_found = (*frame.offset(i as isize)).brightness;
                }
                uniformHistogram[(if ((*frame.offset(i as isize)).uniform / 100 as libc::c_int)
                    < 255 as libc::c_int
                {
                    (*frame.offset(i as isize)).uniform / 100 as libc::c_int
                } else {
                    255 as libc::c_int
                }) as usize] += 1;
            }
            if (*frame.offset(i as isize)).volume >= 0 as libc::c_int {
                volumeHistogram[(if (*frame.offset(i as isize)).volume / volumeScale
                    < 255 as libc::c_int
                {
                    (*frame.offset(i as isize)).volume / volumeScale
                } else {
                    255 as libc::c_int
                }) as usize] += 1;
                silenceHistogram[(if (*frame.offset(i as isize)).volume < 255 as libc::c_int {
                    (*frame.offset(i as isize)).volume
                } else {
                    255 as libc::c_int
                }) as usize] += 1;
            }
            if (*frame.offset(i as isize)).maxX == 0 as libc::c_int {
                if i == 1 as libc::c_int {
                    if (*frame.offset(i as isize)).ar_ratio < 0.5f64 {
                        if (*frame.offset(i as isize)).maxY + (*frame.offset(i as isize)).minY
                            < 600 as libc::c_int
                        {
                            width = 720 as libc::c_int;
                            videowidth = width;
                        } else if (*frame.offset(i as isize)).maxY
                            + (*frame.offset(i as isize)).minY
                            < 800 as libc::c_int
                        {
                            width = 1200 as libc::c_int;
                            videowidth = width;
                        } else {
                            width = 1920 as libc::c_int;
                            videowidth = width;
                        }
                    } else {
                        width = (((*frame.offset(i as isize)).maxY
                            + (*frame.offset(i as isize)).minY)
                            as libc::c_double
                            * (*frame.offset(i as isize)).ar_ratio)
                            as libc::c_int;
                        videowidth = width;
                    }
                }
                (*frame.offset(i as isize)).maxX = videowidth - 10 as libc::c_int;
                (*frame.offset(i as isize)).minX = 10 as libc::c_int;
            }
            if i == 1 as libc::c_int {
                ProcessARInfoInit(
                    (*frame.offset(i as isize)).minY,
                    (*frame.offset(i as isize)).maxY,
                    (*frame.offset(i as isize)).minX,
                    (*frame.offset(i as isize)).maxX,
                );
                ProcessACInfoInit((*frame.offset(i as isize)).audio_channels);
            } else {
                ProcessARInfo(
                    (*frame.offset(i as isize)).minY,
                    (*frame.offset(i as isize)).maxY,
                    (*frame.offset(i as isize)).minX,
                    (*frame.offset(i as isize)).maxX,
                );
                ProcessACInfo((*frame.offset(i as isize)).audio_channels);
            }
            (*frame.offset(i as isize)).ar_ratio = last_ar_ratio;
            if !(commDetectMethod & 8 as libc::c_int != 0) {
                let ref mut fresh88 = (*frame.offset(i as isize)).isblack;
                *fresh88 = (*fresh88 as libc::c_long
                    & !((1 as libc::c_int as libc::c_long) << 29 as libc::c_int))
                    != 0;
            }
            if commDetectMethod & 1 as libc::c_int != 0 {
                if (*frame.offset(i as isize)).isblack as libc::c_int
                    & (1 as libc::c_int) << 4 as libc::c_int
                    != 0
                    && (*frame.offset(i as isize)).brightness > max_avg_brightness
                {
                    let ref mut fresh89 = (*frame.offset(i as isize)).isblack;
                    *fresh89 =
                        (*fresh89 as libc::c_int & !((1 as libc::c_int) << 4 as libc::c_int)) != 0;
                }
                if use_bright != 0 {
                    if (*frame.offset(i as isize)).hasBright > 0 as libc::c_int
                        && min_hasBright
                            > (*frame.offset(i as isize)).hasBright
                                * 720 as libc::c_int
                                * 480 as libc::c_int
                                / videowidth
                                / height
                    {
                        min_hasBright = (*frame.offset(i as isize)).hasBright
                            * 720 as libc::c_int
                            * 480 as libc::c_int
                            / videowidth
                            / height;
                    }
                    if (*frame.offset(i as isize)).dimCount > 0 as libc::c_int
                        && min_dimCount
                            > (*frame.offset(i as isize)).dimCount
                                * 720 as libc::c_int
                                * 480 as libc::c_int
                                / videowidth
                                / height
                    {
                        min_dimCount = (*frame.offset(i as isize)).dimCount
                            * 720 as libc::c_int
                            * 480 as libc::c_int
                            / videowidth
                            / height;
                    }
                    if (*frame.offset(i as isize)).brightness <= max_avg_brightness
                        && (*frame.offset(i as isize)).hasBright < maxbright
                        && (*frame.offset(i as isize)).dimCount
                            < (0.05f64 * videowidth as libc::c_double * height as libc::c_double)
                                as libc::c_int
                    {
                        let ref mut fresh90 = (*frame.offset(i as isize)).isblack;
                        *fresh90 =
                            (*fresh90 as libc::c_int | (1 as libc::c_int) << 4 as libc::c_int) != 0;
                    }
                }
                if i > 1 as libc::c_int {
                    let ref mut fresh91 = (*frame.offset(i as isize)).isblack;
                    *fresh91 =
                        (*fresh91 as libc::c_int & !((1 as libc::c_int) << 3 as libc::c_int)) != 0;
                    if (*frame.offset(i as isize)).isblack as libc::c_int
                        & (1 as libc::c_int) << 4 as libc::c_int
                        == 0
                        && non_uniformity > 0 as libc::c_int
                        && (*frame.offset(i as isize)).uniform < non_uniformity
                        && (*frame.offset(i as isize)).brightness < 250 as libc::c_int
                    {
                        let ref mut fresh92 = (*frame.offset(i as isize)).isblack;
                        *fresh92 =
                            (*fresh92 as libc::c_int | (1 as libc::c_int) << 3 as libc::c_int) != 0;
                    }
                }
            } else {
                let ref mut fresh93 = (*frame.offset(i as isize)).isblack;
                *fresh93 = (*fresh93 as libc::c_int
                    & !((1 as libc::c_int) << 3 as libc::c_int
                        | (1 as libc::c_int) << 4 as libc::c_int))
                    != 0;
            }
            if (*frame.offset(i as isize)).isblack as libc::c_int
                & (1 as libc::c_int) << 2 as libc::c_int
                != 0
            {
                let ref mut fresh94 = (*frame.offset(i as isize)).isblack;
                *fresh94 =
                    (*fresh94 as libc::c_int & !((1 as libc::c_int) << 2 as libc::c_int)) != 0;
            }
            if commDetectMethod & 4 as libc::c_int != 0
                && (*frame.offset((i - 1 as libc::c_int) as isize)).isblack as libc::c_int
                    & (1 as libc::c_int) << 4 as libc::c_int
                    == 0
                && (*frame.offset(i as isize)).isblack as libc::c_int
                    & (1 as libc::c_int) << 4 as libc::c_int
                    == 0
            {
                if (*frame.offset(i as isize)).brightness > 5 as libc::c_int
                    && abs((*frame.offset(i as isize)).brightness - last_brightness)
                        > brightness_jump
                {
                    let ref mut fresh95 = (*frame.offset(i as isize)).isblack;
                    *fresh95 =
                        (*fresh95 as libc::c_int | (1 as libc::c_int) << 2 as libc::c_int) != 0;
                }
                if (*frame.offset(i as isize)).brightness > 5 as libc::c_int {
                    last_brightness = (*frame.offset(i as isize)).brightness;
                }
                if (*frame.offset(i as isize)).brightness > 5 as libc::c_int
                    && (*frame.offset(i as isize)).schange_percent < 15 as libc::c_int
                {
                    let ref mut fresh96 = (*frame.offset(i as isize)).isblack;
                    *fresh96 =
                        (*fresh96 as libc::c_int | (1 as libc::c_int) << 2 as libc::c_int) != 0;
                }
            }
            if (*frame.offset(i as isize)).isblack as libc::c_long
                & (1 as libc::c_int as libc::c_long) << 28 as libc::c_int
                != 0
            {
                let ref mut fresh97 = (*frame.offset(i as isize)).isblack;
                *fresh97 = (*fresh97 as libc::c_long
                    & !((1 as libc::c_int as libc::c_long) << 28 as libc::c_int))
                    != 0;
            }
            if commDetectMethod & 128 as libc::c_int != 0
                && cutscene_nonzero_count > 0 as libc::c_int
            {
                if (*frame.offset(i as isize)).cutscenematch < cutscenedelta {
                    let ref mut fresh98 = (*frame.offset(i as isize)).isblack;
                    *fresh98 = (*fresh98 as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 28 as libc::c_int)
                        != 0;
                }
            }
            if (*frame.offset(i as isize)).isblack as libc::c_long
                & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                != 0
            {
                let ref mut fresh99 = (*frame.offset(i as isize)).isblack;
                *fresh99 = (*fresh99 as libc::c_long
                    & !((1 as libc::c_int as libc::c_long) << 18 as libc::c_int))
                    != 0;
            }
            if commDetectMethod & 64 as libc::c_int != 0 {
                if 0 as libc::c_int <= (*frame.offset(i as isize)).volume
                    && (*frame.offset(i as isize)).volume < max_silence
                    && min_silence == 1 as libc::c_int
                {
                    let ref mut fresh100 = (*frame.offset(i as isize)).isblack;
                    *fresh100 = (*fresh100 as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 18 as libc::c_int)
                        != 0;
                }
                if (*frame.offset(i as isize)).volume < 6 as libc::c_int {
                    let ref mut fresh101 = (*frame.offset(i as isize)).isblack;
                    *fresh101 = (*fresh101 as libc::c_long
                        | (1 as libc::c_int as libc::c_long) << 18 as libc::c_int)
                        != 0;
                }
            }
            if (*frame.offset(i as isize)).isblack {
                InsertBlackFrame(
                    i,
                    (*frame.offset(i as isize)).brightness,
                    (*frame.offset(i as isize)).uniform,
                    (*frame.offset(i as isize)).volume,
                    (*frame.offset(i as isize)).isblack as libc::c_int,
                );
            }
            if (*frame.offset(i as isize)).schange_percent < 20 as libc::c_int
                && i > 1 as libc::c_int
                && black_count > 0 as libc::c_int as libc::c_long
                && (*black.offset((black_count - 1 as libc::c_int as libc::c_long) as isize)).frame
                    != i as libc::c_long
            {
                if (*frame.offset(i as isize)).brightness
                    < (*frame.offset((i - 1 as libc::c_int) as isize)).brightness * 2 as libc::c_int
                {
                    InitializeSchangeArray(schange_count);
                    (*schange.offset(schange_count as isize)).percentage =
                        (*frame.offset(i as isize)).schange_percent;
                    (*schange.offset(schange_count as isize)).frame = i as libc::c_long;
                    schange_count += 1;
                }
            } else if (*frame.offset(i as isize)).schange_percent < schange_threshold {
                InitializeSchangeArray(schange_count);
                (*schange.offset(schange_count as isize)).percentage =
                    (*frame.offset(i as isize)).schange_percent;
                (*schange.offset(schange_count as isize)).frame = i as libc::c_long;
                schange_count += 1;
            }
            if commDetectMethod & 2 as libc::c_int != 0
                && i % (fps * logoFreq) as libc::c_int == 0 as libc::c_int
            {
                curLogoTest_0 = (*frame.offset(i as isize)).currentGoodEdge > logo_threshold;
                lastLogoTest_0 = ProcessLogoTest(i, curLogoTest_0 as libc::c_int, 0 as libc::c_int);
                (*frame.offset(i as isize)).logo_present = lastLogoTest_0;
            }
            if lastLogoTest_0 {
                frames_with_logo += 1;
            }
            i += 1;
        }
        framenum_real = frame_count as libc::c_int;
        framesprocessed = frame_count as libc::c_int;
        if output_live {
            OutputBlackArray();
            BuildCommListAsYouGo();
        }
        BuildMasterCommList();
        if !output_debugwindow {
            break;
        }
        skip_B_frames = 0 as libc::c_int;
        processCC = 0 as libc::c_int != 0;
        i = 0 as libc::c_int;
        printf(b"Close window when done\n\0" as *const u8 as *const libc::c_char);
        if !ReviewResult() {
            break;
        }
        LoadIniFile();
    }
    exit(0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn OutputCCBlock(mut i: libc::c_long) {
    if i > 1 as libc::c_int as libc::c_long {
        Debug(
            11 as libc::c_int,
            b"%i\tStart - %6i\tEnd - %6i\tType - %s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            i - 2 as libc::c_int as libc::c_long,
            (*cc_block.offset((i - 2 as libc::c_int as libc::c_long) as isize)).start_frame,
            (*cc_block.offset((i - 2 as libc::c_int as libc::c_long) as isize)).end_frame,
            CCTypeToStr((*cc_block.offset((i - 2 as libc::c_int as libc::c_long) as isize)).type_0),
        );
    }
    if i > 0 as libc::c_int as libc::c_long {
        Debug(
            11 as libc::c_int,
            b"%i\tStart - %6i\tEnd - %6i\tType - %s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            i - 1 as libc::c_int as libc::c_long,
            (*cc_block.offset((i - 1 as libc::c_int as libc::c_long) as isize)).start_frame,
            (*cc_block.offset((i - 1 as libc::c_int as libc::c_long) as isize)).end_frame,
            CCTypeToStr((*cc_block.offset((i - 1 as libc::c_int as libc::c_long) as isize)).type_0),
        );
    }
    if i <= 0 as libc::c_int as libc::c_long {
        Debug(
            11 as libc::c_int,
            b"%i\tStart - %6i\tEnd - %6i\tType - %s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            i,
            (*cc_block.offset(i as isize)).start_frame,
            (*cc_block.offset(i as isize)).end_frame,
            CCTypeToStr((*cc_block.offset((i - 1 as libc::c_int as libc::c_long) as isize)).type_0),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn Init_XDS_block() {
    if XDS_block.is_null() {
        max_XDS_block_count = 2000 as libc::c_int as libc::c_long;
        XDS_block = malloc(
            ((max_XDS_block_count + 1 as libc::c_int as libc::c_long) as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<XDS_block_info>() as libc::c_ulong),
        ) as *mut XDS_block_info;
        if XDS_block.is_null() {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for XDS blocks\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
            );
            exit(22 as libc::c_int);
        }
        XDS_block_count = 0 as libc::c_int as libc::c_long;
        (*XDS_block.offset(XDS_block_count as isize)).frame = 0 as libc::c_int as libc::c_long;
        (*XDS_block.offset(XDS_block_count as isize)).name[0 as libc::c_int as usize] =
            0 as libc::c_int as libc::c_char;
        (*XDS_block.offset(XDS_block_count as isize)).v_chip = 0 as libc::c_int;
        (*XDS_block.offset(XDS_block_count as isize)).duration = 0 as libc::c_int;
        (*XDS_block.offset(XDS_block_count as isize)).position = 0 as libc::c_int;
        (*XDS_block.offset(XDS_block_count as isize)).composite1 = 0 as libc::c_int;
        (*XDS_block.offset(XDS_block_count as isize)).composite2 = 0 as libc::c_int;
    }
}
#[no_mangle]
pub unsafe extern "C" fn Add_XDS_block() {
    if XDS_block_count < max_XDS_block_count {
        XDS_block_count += 1;
        *XDS_block.offset(XDS_block_count as isize) =
            *XDS_block.offset((XDS_block_count - 1 as libc::c_int as libc::c_long) as isize);
        (*XDS_block.offset(XDS_block_count as isize)).frame = framenum as libc::c_long;
        (*frame.offset(framenum as isize)).xds = XDS_block_count as libc::c_int;
    } else {
        Debug(
            0 as libc::c_int,
            b"Too much XDS data, discarded\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
        );
    };
}
#[no_mangle]
pub static mut XDSbuffer: [[libc::c_uchar; 100]; 40] = [[0; 100]; 40];
#[no_mangle]
pub static mut lastXDS: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut firstXDS: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut startXDS: libc::c_int = 1 as libc::c_int;
#[no_mangle]
pub static mut baseXDS: libc::c_int = 0 as libc::c_int;
#[no_mangle]
pub static mut ratingSystem: [*mut libc::c_char; 4] = [
    b"MPAA\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"TPG\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"CE\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    b"CF\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
];
#[no_mangle]
pub unsafe extern "C" fn AddXDS(mut hi: libc::c_uchar, mut lo: libc::c_uchar) {
    static mut XDSbuf: [libc::c_uchar; 1024] = [0; 1024];
    static mut c: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut newXDS: libc::c_int = 0 as libc::c_int;
    Init_XDS_block();
    if startXDS != 0 {
        if hi as libc::c_int & 0x70 as libc::c_int == 0 as libc::c_int
            && hi as libc::c_int != 0x8f as libc::c_int
        {
            startXDS = 0 as libc::c_int;
            c = 0 as libc::c_int;
            baseXDS = hi as libc::c_int & 0xf as libc::c_int;
        } else {
            return;
        }
    } else {
        if hi as libc::c_int & 0x7f as libc::c_int == baseXDS + 1 as libc::c_int {
            return;
        }
        if hi as libc::c_int & 0x70 as libc::c_int == 0 as libc::c_int
            && hi as libc::c_int != 0x8f as libc::c_int
        {
            return;
        }
    }
    if hi as libc::c_int & 0x1 as libc::c_int == 0 as libc::c_int
        && hi as libc::c_int & 0x70 as libc::c_int == 0 as libc::c_int
        && hi as libc::c_int != 0x8f as libc::c_int
    {
        return;
    }
    if hi as libc::c_int == 0x86 as libc::c_int
        && (lo as libc::c_int == 0x2 as libc::c_int || lo as libc::c_int == 1 as libc::c_int)
    {
        return;
    }
    if c >= 1024 as libc::c_int - 4 as libc::c_int {
        i = 0 as libc::c_int;
        while i < 256 as libc::c_int {
            XDSbuf[i as usize] = 0 as libc::c_int as libc::c_uchar;
            i += 1;
        }
        c = 0 as libc::c_int;
        startXDS = 1 as libc::c_int;
        return;
    }
    let fresh102 = c;
    c = c + 1;
    XDSbuf[fresh102 as usize] = hi;
    let fresh103 = c;
    c = c + 1;
    XDSbuf[fresh103 as usize] = lo;
    if hi as libc::c_int == 0x8f as libc::c_int {
        startXDS = 1 as libc::c_int;
        j = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < c {
            j += XDSbuf[i as usize] as libc::c_int;
            i += 1;
        }
        if j & 0x7f as libc::c_int != 0 as libc::c_int {
            c = 0 as libc::c_int;
            return;
        }
        i = 0 as libc::c_int;
        while i < lastXDS {
            if XDSbuffer[i as usize][0 as libc::c_int as usize] as libc::c_int
                == XDSbuf[0 as libc::c_int as usize] as libc::c_int
                && XDSbuffer[i as usize][1 as libc::c_int as usize] as libc::c_int
                    == XDSbuf[1 as libc::c_int as usize] as libc::c_int
            {
                j = 0 as libc::c_int;
                while j < c {
                    if XDSbuffer[i as usize][j as usize] as libc::c_int
                        != XDSbuf[j as usize] as libc::c_int
                    {
                        while j < 100 as libc::c_int {
                            XDSbuffer[i as usize][j as usize] = XDSbuf[j as usize];
                            j += 1;
                        }
                        newXDS = 1 as libc::c_int;
                        break;
                    } else {
                        j += 1;
                    }
                }
                break;
            } else {
                i += 1;
            }
        }
        if i == lastXDS && firstXDS == 0 {
            j = 0 as libc::c_int;
            while j < 100 as libc::c_int {
                XDSbuffer[i as usize][j as usize] = XDSbuf[j as usize];
                j += 1;
            }
            newXDS = 1 as libc::c_int;
            lastXDS += 1;
            i += 1;
        }
        firstXDS = 0 as libc::c_int;
        if newXDS != 0 {
            Debug(
                10 as libc::c_int,
                b"XDS[%i]: %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x \0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                framenum,
                XDSbuf[0 as libc::c_int as usize] as libc::c_int,
                XDSbuf[1 as libc::c_int as usize] as libc::c_int,
                XDSbuf[2 as libc::c_int as usize] as libc::c_int,
                XDSbuf[3 as libc::c_int as usize] as libc::c_int,
                XDSbuf[4 as libc::c_int as usize] as libc::c_int,
                XDSbuf[5 as libc::c_int as usize] as libc::c_int,
                XDSbuf[6 as libc::c_int as usize] as libc::c_int,
                XDSbuf[7 as libc::c_int as usize] as libc::c_int,
                XDSbuf[8 as libc::c_int as usize] as libc::c_int,
                XDSbuf[9 as libc::c_int as usize] as libc::c_int,
                XDSbuf[10 as libc::c_int as usize] as libc::c_int,
                XDSbuf[11 as libc::c_int as usize] as libc::c_int,
            );
            XDSbuf[(c - 2 as libc::c_int) as usize] = 0 as libc::c_int as libc::c_uchar;
            i = 2 as libc::c_int;
            while i < c - 2 as libc::c_int {
                XDSbuf[i as usize] =
                    (XDSbuf[i as usize] as libc::c_int & 0x7f as libc::c_int) as libc::c_uchar;
                i += 1;
            }
            if XDSbuf[0 as libc::c_int as usize] as libc::c_int == 1 as libc::c_int {
                if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x1 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Program Start Time %02d:%02d %d/%d\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        framenum,
                        XDSbuf[3 as libc::c_int as usize] as libc::c_int & 0x3f as libc::c_int,
                        XDSbuf[2 as libc::c_int as usize] as libc::c_int & 0x3f as libc::c_int,
                        XDSbuf[5 as libc::c_int as usize] as libc::c_int & 0x1f as libc::c_int,
                        XDSbuf[4 as libc::c_int as usize] as libc::c_int & 0xf as libc::c_int,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x2 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Program length %d:%d, elapsed %d:%d:%d.%d\n\0" as *const u8
                            as *const libc::c_char as *mut libc::c_char,
                        framenum,
                        XDSbuf[3 as libc::c_int as usize] as libc::c_int & 0x3f as libc::c_int,
                        XDSbuf[2 as libc::c_int as usize] as libc::c_int & 0x3f as libc::c_int,
                        XDSbuf[5 as libc::c_int as usize] as libc::c_int & 0x3f as libc::c_int,
                        XDSbuf[4 as libc::c_int as usize] as libc::c_int & 0x3f as libc::c_int,
                        XDSbuf[6 as libc::c_int as usize] as libc::c_int & 0x3f as libc::c_int,
                    );
                    if ((XDSbuf[2 as libc::c_int as usize] as libc::c_int) << 8 as libc::c_int)
                        + XDSbuf[3 as libc::c_int as usize] as libc::c_int
                        != (*XDS_block.offset(XDS_block_count as isize)).duration
                    {
                        Add_XDS_block();
                        (*XDS_block.offset(XDS_block_count as isize)).duration =
                            ((XDSbuf[3 as libc::c_int as usize] as libc::c_int)
                                << 8 as libc::c_int)
                                + XDSbuf[2 as libc::c_int as usize] as libc::c_int;
                    }
                    if ((XDSbuf[4 as libc::c_int as usize] as libc::c_int) << 8 as libc::c_int)
                        + XDSbuf[5 as libc::c_int as usize] as libc::c_int
                        != (*XDS_block.offset(XDS_block_count as isize)).position
                    {
                        Add_XDS_block();
                        (*XDS_block.offset(XDS_block_count as isize)).position =
                            ((XDSbuf[5 as libc::c_int as usize] as libc::c_int)
                                << 8 as libc::c_int)
                                + XDSbuf[4 as libc::c_int as usize] as libc::c_int;
                    }
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x83 as libc::c_int {
                    let mut n: size_t =
                        ::std::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong;
                    if strncmp(
                        ((*XDS_block.offset(XDS_block_count as isize)).name).as_mut_ptr()
                            as *const libc::c_char,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar as *const libc::c_char,
                        n,
                    ) != 0 as libc::c_int
                    {
                        Add_XDS_block();
                        strncpy(
                            ((*XDS_block.offset(XDS_block_count as isize)).name).as_mut_ptr(),
                            &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                                as *mut libc::c_uchar
                                as *const libc::c_char,
                            n,
                        );
                    }
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Program Name: %s\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x4 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Program Type: %0x\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x85 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: V-Chip: %2x %2x %2x %2x\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        XDSbuf[2 as libc::c_int as usize] as libc::c_int & 0x38 as libc::c_int,
                        XDSbuf[2 as libc::c_int as usize] as libc::c_int & 0x4f as libc::c_int,
                        XDSbuf[3 as libc::c_int as usize] as libc::c_int & 0x4f as libc::c_int,
                        XDSbuf[3 as libc::c_int as usize] as libc::c_int & 0xb0 as libc::c_int,
                    );
                    if ((XDSbuf[2 as libc::c_int as usize] as libc::c_int) << 8 as libc::c_int)
                        + XDSbuf[3 as libc::c_int as usize] as libc::c_int
                        != (*XDS_block.offset(XDS_block_count as isize)).v_chip
                    {
                        Add_XDS_block();
                        (*XDS_block.offset(XDS_block_count as isize)).v_chip =
                            ((XDSbuf[2 as libc::c_int as usize] as libc::c_int)
                                << 8 as libc::c_int)
                                + XDSbuf[3 as libc::c_int as usize] as libc::c_int;
                    }
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x86 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Audio Streams \n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x7 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Caption Stream\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x8 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Copy Management\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x89 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Aspect Ratio\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x8c as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Program Data, Name: %s\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0xd as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Miscellaneous Data: %s\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x10 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Program Description: %s\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                } else {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Unknown\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                }
            } else if XDSbuf[0 as libc::c_int as usize] as libc::c_int == 0x85 as libc::c_int {
                if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x1 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Network Name: %s\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                } else if XDSbuf[1 as libc::c_int as usize] as libc::c_int == 0x2 as libc::c_int {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Network Call Name: %s\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                } else {
                    Debug(
                        10 as libc::c_int,
                        b"XDS[%i]: Unknown\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        framenum,
                        &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                            as *mut libc::c_uchar,
                    );
                }
            } else if XDSbuf[0 as libc::c_int as usize] as libc::c_int == 0xd as libc::c_int {
                Debug(
                    10 as libc::c_int,
                    b"XDS[%i]: Private Data: %s\n\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    framenum,
                    &mut *XDSbuf.as_mut_ptr().offset(2 as libc::c_int as isize)
                        as *mut libc::c_uchar,
                );
            } else {
                i = 0 as libc::c_int;
                while i < 256 as libc::c_int {
                    XDSbuf[i as usize] =
                        (XDSbuf[i as usize] as libc::c_int & 0x7f as libc::c_int) as libc::c_uchar;
                    if (XDSbuf[i as usize] as libc::c_int) < 0x20 as libc::c_int {
                        XDSbuf[i as usize] = ' ' as i32 as libc::c_uchar;
                    } else if XDSbuf[i as usize] as libc::c_int == 0x20 as libc::c_int {
                        XDSbuf[i as usize] = '_' as i32 as libc::c_uchar;
                    }
                    i += 1;
                }
                Debug(
                    10 as libc::c_int,
                    b"XDS[%i]: %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    framenum,
                    XDSbuf.as_mut_ptr(),
                );
            }
        }
        i = 0 as libc::c_int;
        while i < 256 as libc::c_int {
            XDSbuf[i as usize] = 0 as libc::c_int as libc::c_uchar;
            i += 1;
        }
        c = 0 as libc::c_int;
    }
}
#[no_mangle]
pub unsafe extern "C" fn AddCC(mut i: libc::c_int) {
    let mut tempBool: bool = false;
    let mut current_frame: libc::c_long = framenum as libc::c_long;
    let mut hi: libc::c_int = 0;
    let mut lo: libc::c_int = 0;
    let mut charmap: [libc::c_uchar; 96] = [
        ' ' as i32 as libc::c_uchar,
        '!' as i32 as libc::c_uchar,
        '"' as i32 as libc::c_uchar,
        '#' as i32 as libc::c_uchar,
        '$' as i32 as libc::c_uchar,
        '%' as i32 as libc::c_uchar,
        '&' as i32 as libc::c_uchar,
        '\'' as i32 as libc::c_uchar,
        '(' as i32 as libc::c_uchar,
        ')' as i32 as libc::c_uchar,
        -31i32 as libc::c_uchar,
        '+' as i32 as libc::c_uchar,
        ',' as i32 as libc::c_uchar,
        '-' as i32 as libc::c_uchar,
        '.' as i32 as libc::c_uchar,
        '/' as i32 as libc::c_uchar,
        '0' as i32 as libc::c_uchar,
        '1' as i32 as libc::c_uchar,
        '2' as i32 as libc::c_uchar,
        '3' as i32 as libc::c_uchar,
        '4' as i32 as libc::c_uchar,
        '5' as i32 as libc::c_uchar,
        '6' as i32 as libc::c_uchar,
        '7' as i32 as libc::c_uchar,
        '8' as i32 as libc::c_uchar,
        '9' as i32 as libc::c_uchar,
        ':' as i32 as libc::c_uchar,
        ';' as i32 as libc::c_uchar,
        '<' as i32 as libc::c_uchar,
        '=' as i32 as libc::c_uchar,
        '>' as i32 as libc::c_uchar,
        '?' as i32 as libc::c_uchar,
        '@' as i32 as libc::c_uchar,
        'A' as i32 as libc::c_uchar,
        'B' as i32 as libc::c_uchar,
        'C' as i32 as libc::c_uchar,
        'D' as i32 as libc::c_uchar,
        'E' as i32 as libc::c_uchar,
        'F' as i32 as libc::c_uchar,
        'G' as i32 as libc::c_uchar,
        'H' as i32 as libc::c_uchar,
        'I' as i32 as libc::c_uchar,
        'J' as i32 as libc::c_uchar,
        'K' as i32 as libc::c_uchar,
        'L' as i32 as libc::c_uchar,
        'M' as i32 as libc::c_uchar,
        'N' as i32 as libc::c_uchar,
        'O' as i32 as libc::c_uchar,
        'P' as i32 as libc::c_uchar,
        'Q' as i32 as libc::c_uchar,
        'R' as i32 as libc::c_uchar,
        'S' as i32 as libc::c_uchar,
        'T' as i32 as libc::c_uchar,
        'U' as i32 as libc::c_uchar,
        'V' as i32 as libc::c_uchar,
        'W' as i32 as libc::c_uchar,
        'X' as i32 as libc::c_uchar,
        'Y' as i32 as libc::c_uchar,
        'Z' as i32 as libc::c_uchar,
        '[' as i32 as libc::c_uchar,
        -23i32 as libc::c_uchar,
        ']' as i32 as libc::c_uchar,
        -19i32 as libc::c_uchar,
        -13i32 as libc::c_uchar,
        -6i32 as libc::c_uchar,
        'a' as i32 as libc::c_uchar,
        'b' as i32 as libc::c_uchar,
        'c' as i32 as libc::c_uchar,
        'd' as i32 as libc::c_uchar,
        'e' as i32 as libc::c_uchar,
        'f' as i32 as libc::c_uchar,
        'g' as i32 as libc::c_uchar,
        'h' as i32 as libc::c_uchar,
        'i' as i32 as libc::c_uchar,
        'j' as i32 as libc::c_uchar,
        'k' as i32 as libc::c_uchar,
        'l' as i32 as libc::c_uchar,
        'm' as i32 as libc::c_uchar,
        'n' as i32 as libc::c_uchar,
        'o' as i32 as libc::c_uchar,
        'p' as i32 as libc::c_uchar,
        'q' as i32 as libc::c_uchar,
        'r' as i32 as libc::c_uchar,
        's' as i32 as libc::c_uchar,
        't' as i32 as libc::c_uchar,
        'u' as i32 as libc::c_uchar,
        'v' as i32 as libc::c_uchar,
        'w' as i32 as libc::c_uchar,
        'x' as i32 as libc::c_uchar,
        'y' as i32 as libc::c_uchar,
        'z' as i32 as libc::c_uchar,
        -25i32 as libc::c_uchar,
        -9i32 as libc::c_uchar,
        'N' as i32 as libc::c_uchar,
        'n' as i32 as libc::c_uchar,
        '?' as i32 as libc::c_uchar,
    ];
    cc.cc1[0 as libc::c_int as usize] =
        (cc.cc1[0 as libc::c_int as usize] as libc::c_int & 0x7f as libc::c_int) as libc::c_uchar;
    cc.cc1[1 as libc::c_int as usize] =
        (cc.cc1[1 as libc::c_int as usize] as libc::c_int & 0x7f as libc::c_int) as libc::c_uchar;
    if cc.cc1[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int
        && cc.cc1[1 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int
    {
        return;
    }
    current_frame += 1;
    hi = cc.cc1[0 as libc::c_int as usize] as libc::c_int;
    lo = cc.cc1[1 as libc::c_int as usize] as libc::c_int;
    if hi >= 0x18 as libc::c_int && hi <= 0x1f as libc::c_int {
        hi = hi - 8 as libc::c_int;
    }
    match hi {
        17 => {
            if lo >= 0x20 as libc::c_int && lo <= 0x2f as libc::c_int {
                cc.cc1[0 as libc::c_int as usize] = 0x20 as libc::c_int as libc::c_uchar;
                cc.cc1[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
            }
            if lo >= 0x30 as libc::c_int && lo <= 0x3f as libc::c_int {
                cc.cc1[0 as libc::c_int as usize] = 0x20 as libc::c_int as libc::c_uchar;
                cc.cc1[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
            }
            if lo >= 0x40 as libc::c_int && lo <= 0x7f as libc::c_int {
                cc.cc1[0 as libc::c_int as usize] = 0x20 as libc::c_int as libc::c_uchar;
                cc.cc1[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
            }
        }
        18 | 19 => {
            if lo >= 0x20 as libc::c_int && lo <= 0x3f as libc::c_int {
                cc.cc1[0 as libc::c_int as usize] = 0x20 as libc::c_int as libc::c_uchar;
                cc.cc1[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
            }
        }
        20 | 21 => {}
        22 => {}
        23 => {}
        16 | _ => {}
    }
    if cc.cc1[0 as libc::c_int as usize] as libc::c_int >= 0x20 as libc::c_int
        && (cc.cc1[0 as libc::c_int as usize] as libc::c_int) < 0x80 as libc::c_int
    {
        if current_cc_type == 1 as libc::c_int || current_cc_type == 3 as libc::c_int {
            cc_on_screen = 1 as libc::c_int != 0;
        } else if current_cc_type == 2 as libc::c_int {
            cc_in_memory = 1 as libc::c_int != 0;
        }
        Debug(
            11 as libc::c_int,
            b"%i:%i) %i:'%c':%x\t\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            cc_text_count,
            (*cc_text.offset(cc_text_count as isize)).text_len,
            i,
            charmap
                [(cc.cc1[0 as libc::c_int as usize] as libc::c_int - 0x20 as libc::c_int) as usize]
                as libc::c_int,
            cc.cc1[0 as libc::c_int as usize] as libc::c_int,
        );
        (*cc_text.offset(cc_text_count as isize)).text
            [(*cc_text.offset(cc_text_count as isize)).text_len as usize] = charmap
            [(cc.cc1[0 as libc::c_int as usize] as libc::c_int - 0x20 as libc::c_int) as usize];
        let ref mut fresh104 = (*cc_text.offset(cc_text_count as isize)).text_len;
        *fresh104 += 1;
        (*cc_text.offset(cc_text_count as isize)).text
            [(*cc_text.offset(cc_text_count as isize)).text_len as usize] =
            '\0' as i32 as libc::c_uchar;
        if cc.cc1[1 as libc::c_int as usize] as libc::c_int >= 0x20 as libc::c_int
            && (cc.cc1[1 as libc::c_int as usize] as libc::c_int) < 0x80 as libc::c_int
        {
            Debug(
                11 as libc::c_int,
                b"%i:%i) %i:'%c':%x\t\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                cc_text_count,
                (*cc_text.offset(cc_text_count as isize)).text_len,
                i,
                charmap[(cc.cc1[1 as libc::c_int as usize] as libc::c_int - 0x20 as libc::c_int)
                    as usize] as libc::c_int,
                cc.cc1[1 as libc::c_int as usize] as libc::c_int,
            );
            (*cc_text.offset(cc_text_count as isize)).text
                [(*cc_text.offset(cc_text_count as isize)).text_len as usize] = charmap
                [(cc.cc1[1 as libc::c_int as usize] as libc::c_int - 0x20 as libc::c_int) as usize];
            let ref mut fresh105 = (*cc_text.offset(cc_text_count as isize)).text_len;
            *fresh105 += 1;
            (*cc_text.offset(cc_text_count as isize)).text
                [(*cc_text.offset(cc_text_count as isize)).text_len as usize] =
                '\0' as i32 as libc::c_uchar;
            if last_cc_type == 1 as libc::c_int || last_cc_type == 3 as libc::c_int {
                cc_on_screen = 1 as libc::c_int != 0;
            } else if last_cc_type == 2 as libc::c_int {
                cc_in_memory = 1 as libc::c_int != 0;
            }
        }
    }
    if (*cc_text.offset(cc_text_count as isize)).text_len > 200 as libc::c_int as libc::c_long
        && isalpha(
            (*cc_text.offset(cc_text_count as isize)).text
                [((*cc_text.offset(cc_text_count as isize)).text_len - 1) as usize]
                as libc::c_int,
        ) == 0
        || (*cc_text.offset(cc_text_count as isize)).text_len > 245 as libc::c_int as libc::c_long
    {
        (*cc_text.offset(cc_text_count as isize)).end_frame =
            current_frame - 1 as libc::c_int as libc::c_long;
        cc_text_count += 1;
        InitializeCCTextArray(cc_text_count);
        (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
        (*cc_text.offset(cc_text_count as isize)).text_len = 0 as libc::c_int as libc::c_long;
    }
    if cc.cc1[0 as libc::c_int as usize] as libc::c_int == 0x14 as libc::c_int {
        if cc.cc1[0 as libc::c_int as usize] as libc::c_int
            == lastcc.cc1[0 as libc::c_int as usize] as libc::c_int
            && cc.cc1[1 as libc::c_int as usize] as libc::c_int
                == lastcc.cc1[1 as libc::c_int as usize] as libc::c_int
        {
            Debug(
                11 as libc::c_int,
                b"Double code found\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            return;
        }
        match cc.cc1[1 as libc::c_int as usize] as libc::c_int {
            32 => {
                Debug(
                    11 as libc::c_int,
                    b"Frame - %6i Control Code Found:\tResume Caption Loading\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                );
                (*cc_text.offset(cc_text_count as isize)).end_frame =
                    current_frame - 1 as libc::c_int as libc::c_long;
                cc_text_count += 1;
                InitializeCCTextArray(cc_text_count);
                (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                (*cc_text.offset(cc_text_count as isize)).text_len =
                    0 as libc::c_int as libc::c_long;
                last_cc_type = 2 as libc::c_int;
                current_cc_type = 2 as libc::c_int;
                AddNewCCBlock(current_frame, current_cc_type, cc_on_screen, cc_in_memory);
            }
            33 => {}
            34 => {}
            35 => {}
            36 => {}
            37 => {
                Debug(
                    11 as libc::c_int,
                    b"Frame - %6i Control Code Found:\tRoll Up Captions 2 row\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                );
                (*cc_text.offset(cc_text_count as isize)).end_frame =
                    current_frame - 1 as libc::c_int as libc::c_long;
                cc_text_count += 1;
                InitializeCCTextArray(cc_text_count);
                (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                (*cc_text.offset(cc_text_count as isize)).text_len =
                    0 as libc::c_int as libc::c_long;
                last_cc_type = 1 as libc::c_int;
                current_cc_type = 1 as libc::c_int;
                AddNewCCBlock(current_frame, current_cc_type, cc_on_screen, cc_in_memory);
            }
            38 => {
                Debug(
                    11 as libc::c_int,
                    b"Frame - %6i Control Code Found:\tRoll Up Captions 3 row\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                );
                (*cc_text.offset(cc_text_count as isize)).end_frame =
                    current_frame - 1 as libc::c_int as libc::c_long;
                cc_text_count += 1;
                InitializeCCTextArray(cc_text_count);
                (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                (*cc_text.offset(cc_text_count as isize)).text_len =
                    0 as libc::c_int as libc::c_long;
                last_cc_type = 1 as libc::c_int;
                current_cc_type = 1 as libc::c_int;
                AddNewCCBlock(current_frame, current_cc_type, cc_on_screen, cc_in_memory);
            }
            39 => {
                Debug(
                    11 as libc::c_int,
                    b"Frame - %6i Control Code Found:\tRoll Up Captions 4 row\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                );
                (*cc_text.offset(cc_text_count as isize)).end_frame =
                    current_frame - 1 as libc::c_int as libc::c_long;
                cc_text_count += 1;
                InitializeCCTextArray(cc_text_count);
                (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                (*cc_text.offset(cc_text_count as isize)).text_len =
                    0 as libc::c_int as libc::c_long;
                last_cc_type = 1 as libc::c_int;
                current_cc_type = 1 as libc::c_int;
                AddNewCCBlock(current_frame, current_cc_type, cc_on_screen, cc_in_memory);
            }
            40 => {}
            41 => {
                Debug(
                    11 as libc::c_int,
                    b"Frame - %6i Control Code Found:\tResume Direct Captioning\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                );
                (*cc_text.offset(cc_text_count as isize)).end_frame =
                    current_frame - 1 as libc::c_int as libc::c_long;
                cc_text_count += 1;
                InitializeCCTextArray(cc_text_count);
                (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                (*cc_text.offset(cc_text_count as isize)).text_len =
                    0 as libc::c_int as libc::c_long;
                last_cc_type = 3 as libc::c_int;
                current_cc_type = 3 as libc::c_int;
                AddNewCCBlock(current_frame, current_cc_type, cc_on_screen, cc_in_memory);
            }
            42 => {}
            43 => {}
            44 => {
                Debug(
                    11 as libc::c_int,
                    b"Frame - %6i Control Code Found:\tErase Displayed Memory\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                );
                (*cc_text.offset(cc_text_count as isize)).end_frame =
                    current_frame - 1 as libc::c_int as libc::c_long;
                cc_text_count += 1;
                InitializeCCTextArray(cc_text_count);
                (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                (*cc_text.offset(cc_text_count as isize)).text_len =
                    0 as libc::c_int as libc::c_long;
                cc_on_screen = 0 as libc::c_int != 0;
                current_cc_type = 0 as libc::c_int;
                AddNewCCBlock(current_frame, current_cc_type, cc_on_screen, cc_in_memory);
            }
            45 => {
                if (*cc_text.offset(cc_text_count as isize)).text_len
                    > 200 as libc::c_int as libc::c_long
                {
                    (*cc_text.offset(cc_text_count as isize)).end_frame =
                        current_frame - 1 as libc::c_int as libc::c_long;
                    cc_text_count += 1;
                    InitializeCCTextArray(cc_text_count);
                    (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                    (*cc_text.offset(cc_text_count as isize)).text_len =
                        0 as libc::c_int as libc::c_long;
                }
                (*cc_text.offset(cc_text_count as isize)).text
                    [(*cc_text.offset(cc_text_count as isize)).text_len as usize] =
                    ' ' as i32 as libc::c_uchar;
                let ref mut fresh106 = (*cc_text.offset(cc_text_count as isize)).text_len;
                *fresh106 += 1;
                (*cc_text.offset(cc_text_count as isize)).text
                    [(*cc_text.offset(cc_text_count as isize)).text_len as usize] =
                    '\0' as i32 as libc::c_uchar;
                Debug(
                    11 as libc::c_int,
                    b"\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
            }
            46 => {
                Debug(
                    11 as libc::c_int,
                    b"Frame - %6i Control Code Found:\tErase Non-Displayed Memory\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                );
                cc_in_memory = 0 as libc::c_int != 0;
            }
            47 => {
                Debug(
                    11 as libc::c_int,
                    b"Frame - %6i Control Code Found:\tEnd of Caption\tOn Screen - %i\tOff Screen - %i\n\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                    cc_in_memory as libc::c_int,
                    cc_on_screen as libc::c_int,
                );
                (*cc_text.offset(cc_text_count as isize)).end_frame =
                    current_frame - 1 as libc::c_int as libc::c_long;
                cc_text_count += 1;
                InitializeCCTextArray(cc_text_count);
                (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                (*cc_text.offset(cc_text_count as isize)).text_len =
                    0 as libc::c_int as libc::c_long;
                tempBool = cc_in_memory;
                cc_in_memory = cc_on_screen;
                cc_on_screen = tempBool;
                if !cc_on_screen {
                    current_cc_type = 0 as libc::c_int;
                } else if cc_block_count > 0 as libc::c_int as libc::c_long
                    && (*cc_block.offset(cc_block_count as isize)).type_0 == 0 as libc::c_int
                {
                    current_cc_type = last_cc_type;
                }
                AddNewCCBlock(current_frame, current_cc_type, cc_on_screen, cc_in_memory);
            }
            _ => {
                Debug(
                    11 as libc::c_int,
                    b"\nFrame - %6i Control Code Found:\tUnknown code!! - %2X\n\0" as *const u8
                        as *const libc::c_char as *mut libc::c_char,
                    current_frame,
                    cc.cc1[1 as libc::c_int as usize] as libc::c_int,
                );
                if (*cc_text.offset(cc_text_count as isize)).text_len
                    > 200 as libc::c_int as libc::c_long
                {
                    (*cc_text.offset(cc_text_count as isize)).end_frame =
                        current_frame - 1 as libc::c_int as libc::c_long;
                    cc_text_count += 1;
                    InitializeCCTextArray(cc_text_count);
                    (*cc_text.offset(cc_text_count as isize)).start_frame = current_frame;
                    (*cc_text.offset(cc_text_count as isize)).text_len =
                        0 as libc::c_int as libc::c_long;
                }
                (*cc_text.offset(cc_text_count as isize)).text
                    [(*cc_text.offset(cc_text_count as isize)).text_len as usize] =
                    ' ' as i32 as libc::c_uchar;
                let ref mut fresh107 = (*cc_text.offset(cc_text_count as isize)).text_len;
                *fresh107 += 1;
                (*cc_text.offset(cc_text_count as isize)).text
                    [(*cc_text.offset(cc_text_count as isize)).text_len as usize] =
                    '\0' as i32 as libc::c_uchar;
            }
        }
    }
    lastcc.cc1[0 as libc::c_int as usize] = cc.cc1[0 as libc::c_int as usize];
    lastcc.cc1[1 as libc::c_int as usize] = cc.cc1[1 as libc::c_int as usize];
}
#[no_mangle]
pub unsafe extern "C" fn ProcessCCData() {
    let mut i: libc::c_int = 0;
    let mut proceed: libc::c_int = 0 as libc::c_int;
    let mut is_CC: libc::c_int = 0 as libc::c_int;
    let mut is_GA: libc::c_int = 0 as libc::c_int;
    let mut cctype: libc::c_int = 0 as libc::c_int;
    let mut offset: libc::c_int = 0;
    let mut temp: [libc::c_char; 2000] = [0; 2000];
    let mut hex: [libc::c_char; 10] = [0; 10];
    let mut t: libc::c_uchar = 0;
    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut cc1First: bool = 0 as libc::c_int != 0;
    let mut packetCount: libc::c_uchar = 0;
    if !initialized {
        return;
    }
    if framenum == 0 as libc::c_int {
        last_cc_type = 0 as libc::c_int;
        current_cc_type = 0 as libc::c_int;
        cc_on_screen = 0 as libc::c_int != 0;
        cc_in_memory = 0 as libc::c_int != 0;
    }
    if verbose >= 12 as libc::c_int {
        p = temp.as_mut_ptr() as *mut libc::c_uchar;
        i = 0 as libc::c_int;
        while i < ccDataLen {
            t = (ccData[i as usize] as libc::c_int & 0x7f as libc::c_int) as libc::c_uchar;
            if t as libc::c_int == 0x20 as libc::c_int {
                let fresh108 = p;
                p = p.offset(1);
                *fresh108 = '_' as i32 as libc::c_uchar;
            } else if t as libc::c_int > 0x20 as libc::c_int
                && (t as libc::c_int) < 0x7f as libc::c_int
            {
                let fresh109 = p;
                p = p.offset(1);
                *fresh109 = t;
            } else {
                let fresh110 = p;
                p = p.offset(1);
                *fresh110 = ' ' as i32 as libc::c_uchar;
            }
            let fresh111 = p;
            p = p.offset(1);
            *fresh111 = ' ' as i32 as libc::c_uchar;
            let fresh112 = p;
            p = p.offset(1);
            *fresh112 = ' ' as i32 as libc::c_uchar;
            i += 1;
        }
        let fresh113 = p;
        p = p.offset(1);
        *fresh113 = 0 as libc::c_int as libc::c_uchar;
        if ccData[0 as libc::c_int as usize] as libc::c_int == 'G' as i32 {
            temp[(7 as libc::c_int * 3 as libc::c_int) as usize] = ('0' as i32
                + (temp[(7 as libc::c_int * 3 as libc::c_int) as usize] as libc::c_int
                    & 0x3 as libc::c_int))
                as libc::c_char;
        }
        Debug(
            10 as libc::c_int,
            b"CCData for framenum %4i%c, length:%4i: %s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            framenum,
            pict_type as libc::c_int,
            ccDataLen,
            temp.as_mut_ptr(),
        );
        p = temp.as_mut_ptr() as *mut libc::c_uchar;
        i = 0 as libc::c_int;
        while i < ccDataLen {
            sprintf(
                hex.as_mut_ptr(),
                b"%2x \0" as *const u8 as *const libc::c_char,
                ccData[i as usize] as libc::c_int,
            );
            let fresh114 = p;
            p = p.offset(1);
            *fresh114 = hex[0 as libc::c_int as usize] as libc::c_uchar;
            let fresh115 = p;
            p = p.offset(1);
            *fresh115 = hex[1 as libc::c_int as usize] as libc::c_uchar;
            let fresh116 = p;
            p = p.offset(1);
            *fresh116 = ' ' as i32 as libc::c_uchar;
            i += 1;
        }
        let fresh117 = p;
        p = p.offset(1);
        *fresh117 = 0 as libc::c_int as libc::c_uchar;
        Debug(
            10 as libc::c_int,
            b"CCData for framenum %4i%c, length:%4i: %s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            framenum,
            pict_type as libc::c_int,
            ccDataLen,
            temp.as_mut_ptr(),
        );
    }
    if ccData[0 as libc::c_int as usize] as libc::c_char as libc::c_int == 'C' as i32
        && ccData[1 as libc::c_int as usize] as libc::c_char as libc::c_int == 'C' as i32
        && ccData[2 as libc::c_int as usize] as libc::c_int == 0x1 as libc::c_int
        && ccData[3 as libc::c_int as usize] as libc::c_int == 0xf8 as libc::c_int
    {
        reorderCC = 0 as libc::c_int;
        packetCount = ccData[4 as libc::c_int as usize];
        if packetCount as libc::c_int & 0x80 as libc::c_int != 0 {
            cc1First = 1 as libc::c_int != 0;
        } else {
            cc1First = 0 as libc::c_int != 0;
        }
        offset = 5 as libc::c_int;
        packetCount = ((packetCount as libc::c_int & 0x1e as libc::c_int) / 2 as libc::c_int)
            as libc::c_uchar;
        if !cc1First || packetCount as libc::c_int != 15 as libc::c_int {
            Debug(
                11 as libc::c_int,
                b"CC Field Order: %i.  There appear to be %i packets.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
                cc1First as libc::c_int,
                packetCount as libc::c_int,
            );
        }
        proceed = 1 as libc::c_int;
        is_CC = 1 as libc::c_int;
    } else if ccData[0 as libc::c_int as usize] as libc::c_char as libc::c_int == 'G' as i32
        && ccData[1 as libc::c_int as usize] as libc::c_char as libc::c_int == 'A' as i32
        && ccData[2 as libc::c_int as usize] as libc::c_int == '9' as i32
        && ccData[3 as libc::c_int as usize] as libc::c_int == '4' as i32
        && ccData[4 as libc::c_int as usize] as libc::c_int == 0x3 as libc::c_int
    {
        reorderCC = 1 as libc::c_int;
        packetCount = (ccData[5 as libc::c_int as usize] as libc::c_int & 0x1f as libc::c_int)
            as libc::c_uchar;
        proceed = (ccData[5 as libc::c_int as usize] as libc::c_int & 0x40 as libc::c_int)
            >> 6 as libc::c_int;
        offset = 7 as libc::c_int;
        is_GA = 1 as libc::c_int;
    } else if ccData[0 as libc::c_int as usize] as libc::c_int == 0x5 as libc::c_int
        && ccData[1 as libc::c_int as usize] as libc::c_int == 0x2 as libc::c_int
    {
        reorderCC = 0 as libc::c_int;
        proceed = 0 as libc::c_int;
        offset = 7 as libc::c_int;
        let fresh118 = offset;
        offset = offset + 1;
        cctype = ccData[fresh118 as usize] as libc::c_int;
        if cctype == 2 as libc::c_int {
            offset += 1;
            let fresh119 = offset;
            offset = offset + 1;
            cc.cc1[0 as libc::c_int as usize] = ccData[fresh119 as usize];
            let fresh120 = offset;
            offset = offset + 1;
            cc.cc1[1 as libc::c_int as usize] = ccData[fresh120 as usize];
            AddCC(1 as libc::c_int);
            let fresh121 = offset;
            offset = offset + 1;
            cctype = ccData[fresh121 as usize] as libc::c_int;
            if cctype == 4 as libc::c_int
                && (ccData[offset as usize] as libc::c_int & 0x7f as libc::c_int)
                    < 32 as libc::c_int
            {
                let fresh122 = offset;
                offset = offset + 1;
                cc.cc1[0 as libc::c_int as usize] = ccData[fresh122 as usize];
                let fresh123 = offset;
                offset = offset + 1;
                cc.cc1[1 as libc::c_int as usize] = ccData[fresh123 as usize];
                AddCC(1 as libc::c_int);
            }
            offset += 3 as libc::c_int;
        } else if cctype == 4 as libc::c_int {
            offset += 1;
            let fresh124 = offset;
            offset = offset + 1;
            cc.cc1[0 as libc::c_int as usize] = ccData[fresh124 as usize];
            let fresh125 = offset;
            offset = offset + 1;
            cc.cc1[1 as libc::c_int as usize] = ccData[fresh125 as usize];
            AddCC(1 as libc::c_int);
            let fresh126 = offset;
            offset = offset + 1;
            cc.cc1[0 as libc::c_int as usize] = ccData[fresh126 as usize];
            let fresh127 = offset;
            offset = offset + 1;
            cc.cc1[1 as libc::c_int as usize] = ccData[fresh127 as usize];
            AddCC(1 as libc::c_int);
            offset += 3 as libc::c_int;
        } else if cctype == 5 as libc::c_int {
            i = 0 as libc::c_int;
            while i < prevccDataLen {
                cc.cc1[0 as libc::c_int as usize] = prevccData[i as usize];
                cc.cc1[1 as libc::c_int as usize] = prevccData[(i + 1 as libc::c_int) as usize];
                AddCC(i / 2 as libc::c_int);
                i += 2 as libc::c_int;
            }
            prevccDataLen = 0 as libc::c_int;
            let fresh128 = offset;
            offset = offset + 1;
            cctype = ccData[fresh128 as usize] as libc::c_int & 0x7f as libc::c_int;
            let fresh129 = offset;
            offset = offset + 1;
            cctype = ccData[fresh129 as usize] as libc::c_int & 0x7f as libc::c_int;
            let fresh130 = offset;
            offset = offset + 1;
            cctype = ccData[fresh130 as usize] as libc::c_int & 0x7f as libc::c_int;
            let fresh131 = offset;
            offset = offset + 1;
            cctype = ccData[fresh131 as usize] as libc::c_int & 0x7f as libc::c_int;
            let fresh132 = offset;
            offset = offset + 1;
            cctype = ccData[fresh132 as usize] as libc::c_int & 0x7f as libc::c_int;
            let fresh133 = offset;
            offset = offset + 1;
            cctype = ccData[fresh133 as usize] as libc::c_int & 0x7f as libc::c_int;
            let fresh134 = offset;
            offset = offset + 1;
            cctype = ccData[fresh134 as usize] as libc::c_int;
            offset += 1;
            prevccDataLen = 0 as libc::c_int;
            let fresh135 = offset;
            offset = offset + 1;
            let fresh136 = prevccDataLen;
            prevccDataLen = prevccDataLen + 1;
            prevccData[fresh136 as usize] = ccData[fresh135 as usize];
            let fresh137 = offset;
            offset = offset + 1;
            let fresh138 = prevccDataLen;
            prevccDataLen = prevccDataLen + 1;
            prevccData[fresh138 as usize] = ccData[fresh137 as usize];
            if cctype == 2 as libc::c_int {
                let fresh139 = offset;
                offset = offset + 1;
                cctype = ccData[fresh139 as usize] as libc::c_int;
                if cctype == 4 as libc::c_int
                    && (ccData[offset as usize] as libc::c_int & 0x7f as libc::c_int)
                        < 32 as libc::c_int
                {
                    let fresh140 = offset;
                    offset = offset + 1;
                    let fresh141 = prevccDataLen;
                    prevccDataLen = prevccDataLen + 1;
                    prevccData[fresh141 as usize] = ccData[fresh140 as usize];
                    let fresh142 = offset;
                    offset = offset + 1;
                    let fresh143 = prevccDataLen;
                    prevccDataLen = prevccDataLen + 1;
                    prevccData[fresh143 as usize] = ccData[fresh142 as usize];
                }
            } else {
                let fresh144 = offset;
                offset = offset + 1;
                let fresh145 = prevccDataLen;
                prevccDataLen = prevccDataLen + 1;
                prevccData[fresh145 as usize] = ccData[fresh144 as usize];
                let fresh146 = offset;
                offset = offset + 1;
                let fresh147 = prevccDataLen;
                prevccDataLen = prevccDataLen + 1;
                prevccData[fresh147 as usize] = ccData[fresh146 as usize];
            }
            offset += 3 as libc::c_int;
        }
        packetCount = (cctype / 2 as libc::c_int) as libc::c_uchar;
    }
    if proceed != 0 {
        i = 0 as libc::c_int;
        while i < packetCount as libc::c_int {
            if is_CC != 0 {
                if cc1First {
                    cc.cc1[0 as libc::c_int as usize] = (if CheckOddParity(
                        ccData[(i * 6 as libc::c_int + offset + 1 as libc::c_int) as usize],
                    ) as libc::c_int
                        != 0
                    {
                        ccData[(i * 6 as libc::c_int + offset + 1 as libc::c_int) as usize]
                            as libc::c_int
                            & 0x7f as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uchar;
                    cc.cc1[1 as libc::c_int as usize] = (if CheckOddParity(
                        ccData[(i * 6 as libc::c_int + offset + 2 as libc::c_int) as usize],
                    ) as libc::c_int
                        != 0
                    {
                        ccData[(i * 6 as libc::c_int + offset + 2 as libc::c_int) as usize]
                            as libc::c_int
                            & 0x7f as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uchar;
                } else {
                    cc.cc1[0 as libc::c_int as usize] = (if CheckOddParity(
                        ccData[(i * 6 as libc::c_int + offset + 4 as libc::c_int) as usize],
                    ) as libc::c_int
                        != 0
                    {
                        ccData[(i * 6 as libc::c_int + offset + 4 as libc::c_int) as usize]
                            as libc::c_int
                            & 0x7f as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uchar;
                    cc.cc1[1 as libc::c_int as usize] = (if CheckOddParity(
                        ccData[(i * 6 as libc::c_int + offset + 5 as libc::c_int) as usize],
                    ) as libc::c_int
                        != 0
                    {
                        ccData[(i * 6 as libc::c_int + offset + 5 as libc::c_int) as usize]
                            as libc::c_int
                            & 0x7f as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uchar;
                }
                AddCC(i);
            }
            if is_GA != 0 {
                if !((ccData[(i * 3 as libc::c_int + offset) as usize] as libc::c_int
                    & 4 as libc::c_int
                    == 0) as libc::c_int
                    >> 2 as libc::c_int
                    != 0)
                {
                    if !(ccData[(i * 3 as libc::c_int + offset) as usize] as libc::c_int
                        == 0xfa as libc::c_int)
                    {
                        if !(ccData[(i * 3 as libc::c_int + offset + 1 as libc::c_int) as usize]
                            as libc::c_int
                            == 0x80 as libc::c_int
                            && ccData[(i * 3 as libc::c_int + offset + 2 as libc::c_int) as usize]
                                as libc::c_int
                                == 0x80 as libc::c_int)
                        {
                            if !(ccData[(i * 3 as libc::c_int + offset + 1 as libc::c_int) as usize]
                                as libc::c_int
                                == 0 as libc::c_int
                                && ccData
                                    [(i * 3 as libc::c_int + offset + 2 as libc::c_int) as usize]
                                    as libc::c_int
                                    == 0 as libc::c_int)
                            {
                                cctype = ccData[(i * 3 as libc::c_int + offset) as usize]
                                    as libc::c_int
                                    & 3 as libc::c_int;
                                cc.cc1[0 as libc::c_int as usize] = (ccData
                                    [(i * 3 as libc::c_int + offset + 1 as libc::c_int) as usize]
                                    as libc::c_int
                                    & 0x7f as libc::c_int)
                                    as libc::c_uchar;
                                cc.cc1[1 as libc::c_int as usize] = (ccData
                                    [(i * 3 as libc::c_int + offset + 2 as libc::c_int) as usize]
                                    as libc::c_int
                                    & 0x7f as libc::c_int)
                                    as libc::c_uchar;
                                if cctype == 1 as libc::c_int {
                                    AddXDS(
                                        ccData[(i * 3 as libc::c_int + offset + 1 as libc::c_int)
                                            as usize],
                                        ccData[(i * 3 as libc::c_int + offset + 2 as libc::c_int)
                                            as usize],
                                    );
                                }
                                if !(cctype != 0 as libc::c_int && cctype != 1 as libc::c_int) {
                                    if cctype == 0 as libc::c_int {
                                        AddCC(i);
                                    } else {
                                        cc.cc1[0 as libc::c_int as usize] =
                                            0 as libc::c_int as libc::c_uchar;
                                        cc.cc1[1 as libc::c_int as usize] =
                                            0 as libc::c_int as libc::c_uchar;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            i += 1;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn CheckOddParity(mut ch: libc::c_uchar) -> bool {
    let mut i: libc::c_int = 0;
    let mut test: libc::c_uchar = 1 as libc::c_int as libc::c_uchar;
    let mut count: libc::c_int = 0 as libc::c_int;
    i = 1 as libc::c_int;
    while i <= 8 as libc::c_int {
        if ch as libc::c_int & test as libc::c_int != 0 {
            count += 1;
        }
        test = (test as libc::c_int * 2 as libc::c_int) as libc::c_uchar;
        i += 1;
    }
    if count % 2 as libc::c_int != 0 {
        return 1 as libc::c_int != 0;
    } else {
        return 0 as libc::c_int != 0;
    };
}
#[no_mangle]
pub unsafe extern "C" fn AddNewCCBlock(
    mut current_frame: libc::c_long,
    mut type_0: libc::c_int,
    mut cc_on_screen_0: bool,
    mut cc_in_memory_0: bool,
) {
    if (*cc_block.offset(cc_block_count as isize)).type_0 == type_0 {
        (*cc_block.offset(cc_block_count as isize)).end_frame = current_frame;
    } else {
        Debug(
            11 as libc::c_int,
            b"\nFrame - %6i\t%s captions start\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            current_frame,
            CCTypeToStr(type_0),
        );
        if (*cc_block.offset(cc_block_count as isize)).end_frame
            == -(1 as libc::c_int) as libc::c_long
        {
            Debug(
                11 as libc::c_int,
                b"New cblock found\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            );
            (*cc_block.offset(cc_block_count as isize)).end_frame =
                current_frame - 1 as libc::c_int as libc::c_long;
            cc_block_count += 1;
            InitializeCCBlockArray(cc_block_count);
            (*cc_block.offset(cc_block_count as isize)).start_frame = current_frame;
            (*cc_block.offset(cc_block_count as isize)).type_0 = type_0;
            if cc_block_count > 1 as libc::c_int as libc::c_long {
                if (if !frame.is_null() {
                    (if (*cc_block
                        .offset((cc_block_count - 1 as libc::c_int as libc::c_long) as isize))
                    .end_frame
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*cc_block
                            .offset((cc_block_count - 1 as libc::c_int as libc::c_long) as isize))
                        .end_frame
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                (*cc_block.offset(
                                    (cc_block_count - 1 as libc::c_int as libc::c_long) as isize,
                                ))
                                .end_frame as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    (*cc_block.offset((cc_block_count - 1 as libc::c_int as libc::c_long) as isize))
                        .end_frame as libc::c_double
                        / fps
                }) - (if !frame.is_null() {
                    (if (*cc_block
                        .offset((cc_block_count - 1 as libc::c_int as libc::c_long) as isize))
                    .start_frame
                        <= 0 as libc::c_int as libc::c_long
                    {
                        (*frame.offset(1 as libc::c_int as isize)).pts
                    } else {
                        (if (*cc_block
                            .offset((cc_block_count - 1 as libc::c_int as libc::c_long) as isize))
                        .start_frame
                            >= framenum_real as libc::c_long
                        {
                            (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                        } else {
                            (*frame.offset(
                                (*cc_block.offset(
                                    (cc_block_count - 1 as libc::c_int as libc::c_long) as isize,
                                ))
                                .start_frame as isize,
                            ))
                            .pts
                        })
                    })
                } else {
                    (*cc_block.offset((cc_block_count - 1 as libc::c_int as libc::c_long) as isize))
                        .start_frame as libc::c_double
                        / fps
                }) < 1.0f64
                    && (*cc_block.offset(cc_block_count as isize)).type_0
                        == (*cc_block
                            .offset((cc_block_count - 2 as libc::c_int as libc::c_long) as isize))
                        .type_0
                    && (*cc_block.offset(cc_block_count as isize)).type_0 != 0 as libc::c_int
                {
                    cc_block_count -= 2 as libc::c_int as libc::c_long;
                    (*cc_block.offset(cc_block_count as isize)).end_frame =
                        -(1 as libc::c_int) as libc::c_long;
                }
            }
        } else {
            cc_block_count += 1;
            InitializeCCBlockArray(cc_block_count);
            (*cc_block.offset(cc_block_count as isize)).start_frame = current_frame;
            (*cc_block.offset(cc_block_count as isize)).type_0 = type_0;
        }
        OutputCCBlock(cc_block_count);
    };
}
#[no_mangle]
pub unsafe extern "C" fn CCTypeToStr(mut type_0: libc::c_int) -> *mut libc::c_char {
    if processCC {
        match type_0 {
            0 => {
                sprintf(
                    tempString.as_mut_ptr(),
                    b"NONE\0" as *const u8 as *const libc::c_char,
                );
            }
            1 => {
                sprintf(
                    tempString.as_mut_ptr(),
                    b"ROLLUP\0" as *const u8 as *const libc::c_char,
                );
            }
            3 => {
                sprintf(
                    tempString.as_mut_ptr(),
                    b"PAINTON\0" as *const u8 as *const libc::c_char,
                );
            }
            2 => {
                sprintf(
                    tempString.as_mut_ptr(),
                    b"POPON\0" as *const u8 as *const libc::c_char,
                );
            }
            4 => {
                sprintf(
                    tempString.as_mut_ptr(),
                    b"COMMERCIAL\0" as *const u8 as *const libc::c_char,
                );
            }
            _ => {
                sprintf(
                    tempString.as_mut_ptr(),
                    b"%d\0" as *const u8 as *const libc::c_char,
                    type_0,
                );
            }
        }
    } else {
        tempString[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    }
    return tempString.as_mut_ptr();
}
#[no_mangle]
pub unsafe extern "C" fn DetermineCCTypeForBlock(
    mut start: libc::c_long,
    mut end: libc::c_long,
) -> libc::c_int {
    let mut type_0: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut cc_block_first: libc::c_int = cc_block_count as libc::c_int;
    let mut cc_block_last: libc::c_int = 0 as libc::c_int;
    let mut cc_type_count: [libc::c_int; 5] = [
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ];
    while (*cc_block.offset(cc_block_first as isize)).start_frame > start {
        cc_block_first -= 1;
    }
    while (*cc_block.offset(cc_block_last as isize)).end_frame < end {
        cc_block_last += 1;
    }
    i = cc_block_first;
    while i <= cc_block_last {
        if (*cc_block.offset(i as isize)).type_0 != 0 as libc::c_int {
            if i > 0 as libc::c_int {
                if (*cc_block.offset((i - 1 as libc::c_int) as isize)).type_0 == 3 as libc::c_int
                    && (*cc_block.offset(i as isize)).type_0 == 2 as libc::c_int
                {
                    type_0 = 4 as libc::c_int;
                    break;
                }
            }
            if i > 1 as libc::c_int {
                if (*cc_block.offset((i - 2 as libc::c_int) as isize)).type_0 == 3 as libc::c_int
                    && (*cc_block.offset((i - 1 as libc::c_int) as isize)).type_0
                        == 0 as libc::c_int
                    && (if !frame.is_null() {
                        (if (*cc_block.offset((i - 1 as libc::c_int) as isize)).end_frame
                            <= 0 as libc::c_int as libc::c_long
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*cc_block.offset((i - 1 as libc::c_int) as isize)).end_frame
                                >= framenum_real as libc::c_long
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(
                                    (*cc_block.offset((i - 1 as libc::c_int) as isize)).end_frame
                                        as isize,
                                ))
                                .pts
                            })
                        })
                    } else {
                        (*cc_block.offset((i - 1 as libc::c_int) as isize)).end_frame
                            as libc::c_double
                            / fps
                    }) - (if !frame.is_null() {
                        (if (*cc_block.offset((i - 1 as libc::c_int) as isize)).start_frame
                            <= 0 as libc::c_int as libc::c_long
                        {
                            (*frame.offset(1 as libc::c_int as isize)).pts
                        } else {
                            (if (*cc_block.offset((i - 1 as libc::c_int) as isize)).start_frame
                                >= framenum_real as libc::c_long
                            {
                                (*frame.offset((framenum_real - 1 as libc::c_int) as isize)).pts
                            } else {
                                (*frame.offset(
                                    (*cc_block.offset((i - 1 as libc::c_int) as isize)).start_frame
                                        as isize,
                                ))
                                .pts
                            })
                        })
                    } else {
                        (*cc_block.offset((i - 1 as libc::c_int) as isize)).start_frame
                            as libc::c_double
                            / fps
                    }) <= 1.5f64
                    && (*cc_block.offset(i as isize)).type_0 == 2 as libc::c_int
                {
                    type_0 = 4 as libc::c_int;
                    break;
                }
            }
        }
        i += 1;
    }
    if type_0 != 4 as libc::c_int {
        i = start as libc::c_int;
        while i as libc::c_long <= end {
            j = 0 as libc::c_int;
            while (j as libc::c_long) < cc_block_count {
                if i as libc::c_long > (*cc_block.offset(j as isize)).start_frame
                    && (i as libc::c_long) < (*cc_block.offset(j as isize)).end_frame
                {
                    cc_type_count[(*cc_block.offset(j as isize)).type_0 as usize] += 1;
                    break;
                } else {
                    j += 1;
                }
            }
            i += 1;
        }
        type_0 = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < 5 as libc::c_int {
            if cc_type_count[i as usize] > cc_type_count[type_0 as usize] {
                type_0 = i;
            }
            i += 1;
        }
    }
    Debug(
        4 as libc::c_int,
        b"Start - %6i\tEnd - %6i\tCCF - %2i\tCCL - %2i\tType - %s\n\0" as *const u8
            as *const libc::c_char as *mut libc::c_char,
        start,
        end,
        cc_block_first,
        cc_block_last,
        CCTypeToStr(type_0),
    );
    return type_0;
}
#[no_mangle]
pub unsafe extern "C" fn SetARofBlocks() {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut sumAR: libc::c_double = 0.0f64;
    let mut frameCount: libc::c_int = 0 as libc::c_int;
    if commDetectMethod & 32 as libc::c_int == 0 {
        return;
    }
    k = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        sumAR = 0.0f64;
        frameCount = 0 as libc::c_int;
        j = (cblock[i as usize].f_start + cblock[i as usize].b_head as libc::c_long) as libc::c_int;
        while (j as libc::c_long)
            < cblock[i as usize].f_end - cblock[i as usize].b_tail as libc::c_int as libc::c_long
        {
            if (k as libc::c_long) < ar_block_count && j >= (*ar_block.offset(k as isize)).end {
                k += 1;
            }
            if (*ar_block.offset(k as isize)).ar_ratio > 1 as libc::c_int as libc::c_double {
                sumAR += (*ar_block.offset(k as isize)).ar_ratio;
                frameCount += 1;
            }
            j += 1;
        }
        if frameCount == 0 as libc::c_int {
            cblock[i as usize].ar_ratio = 1.0f64;
        } else {
            cblock[i as usize].ar_ratio = sumAR / frameCount as libc::c_double;
        }
        i += 1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn ProcessCCDict() -> bool {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut phrase: [libc::c_char; 1024] = [0; 1024];
    let mut goodPhrase: bool = 1 as libc::c_int != 0;
    let mut dict: *mut FILE = 0 as *mut FILE;
    dict = myfopen(
        dictfilename.as_mut_ptr(),
        b"r\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    if dict.is_null() {
        return 0 as libc::c_int != 0;
    }
    Debug(
        2 as libc::c_int,
        b"\n\nStarting to process dictionary\n-------------------------------------\n\0"
            as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    while !(fgets(
        phrase.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong as libc::c_int,
        dict,
    ))
    .is_null()
    {
        ptr = strchr(phrase.as_mut_ptr(), '\n' as i32);
        if !ptr.is_null() {
            *ptr = '\0' as i32 as libc::c_char;
        }
        if !(strstr(
            phrase.as_mut_ptr(),
            b"-----\0" as *const u8 as *const libc::c_char,
        ))
        .is_null()
        {
            goodPhrase = 0 as libc::c_int != 0;
            Debug(
                3 as libc::c_int,
                b"Finished with good phrases.  Now starting bad phrases.\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
        } else {
            if strlen(phrase.as_mut_ptr()) < 1 as libc::c_int as libc::c_ulong {
                continue;
            }
            Debug(
                3 as libc::c_int,
                b"Searching for: %s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                phrase.as_mut_ptr(),
            );
            i = 0 as libc::c_int;
            while (i as libc::c_long) < cc_text_count {
                if !(strstr(
                    _strupr(((*cc_text.offset(i as isize)).text).as_mut_ptr() as *mut libc::c_char),
                    _strupr(phrase.as_mut_ptr()),
                ))
                .is_null()
                {
                    Debug(
                        2 as libc::c_int,
                        b"%s found in cc_text_block %i\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        phrase.as_mut_ptr(),
                        i,
                    );
                    if goodPhrase {
                        j = FindBlock(
                            ((*cc_text.offset(i as isize)).start_frame
                                + (*cc_text.offset(i as isize)).end_frame)
                                / 2 as libc::c_int as libc::c_long,
                        );
                        if j == -(1 as libc::c_int) {
                            Debug(
                                1 as libc::c_int,
                                b"There was an error finding the correct cblock for cc text cblock %i.\n\0"
                                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                                i,
                            );
                        } else {
                            Debug(
                                3 as libc::c_int,
                                b"Block %i score:\tBefore - %.2f\t\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                j,
                                cblock[j as usize].score,
                            );
                            cblock[j as usize].score /= dictionary_modifier;
                            Debug(
                                3 as libc::c_int,
                                b"After - %.2f\n\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                                cblock[j as usize].score,
                            );
                        }
                    } else {
                        j = FindBlock(
                            ((*cc_text.offset(i as isize)).start_frame
                                + (*cc_text.offset(i as isize)).end_frame)
                                / 2 as libc::c_int as libc::c_long,
                        );
                        if j == -(1 as libc::c_int) {
                            Debug(
                                1 as libc::c_int,
                                b"There was an error finding the correct cblock for cc text cblock %i.\n\0"
                                    as *const u8 as *const libc::c_char as *mut libc::c_char,
                                i,
                            );
                        } else {
                            Debug(
                                3 as libc::c_int,
                                b"Block %i score:\tBefore - %.2f\t\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                j,
                                cblock[j as usize].score,
                            );
                            cblock[j as usize].score *= dictionary_modifier;
                            Debug(
                                3 as libc::c_int,
                                b"After - %.2f\n\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                                cblock[j as usize].score,
                            );
                        }
                    }
                }
                i += 1;
            }
        }
    }
    fclose(dict);
    return 1 as libc::c_int != 0;
}
#[no_mangle]
pub unsafe extern "C" fn FindBlock(mut frame_0: libc::c_long) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while (i as libc::c_long) < block_count {
        if frame_0 >= cblock[i as usize].f_start && frame_0 < cblock[i as usize].f_end {
            return i;
        }
        i += 1;
    }
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn BuildCommListAsYouGo() {
    let mut c_start: [libc::c_long; 100000] = [0; 100000];
    let mut c_end: [libc::c_long; 100000] = [0; 100000];
    let mut filename_0: [libc::c_char; 255] = [0; 255];
    let mut commercials: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut remainder: libc::c_double = 0.;
    let mut added: libc::c_double = 0.;
    let mut oldbreak: bool = false;
    let mut useLogo: bool = false;
    let mut onTheFlyBlackFrame: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut onTheFlyBlackCount: libc::c_int = 0 as libc::c_int;
    if (framenum_real as libc::c_long - lastFrameCommCalculated) as libc::c_double
        <= 15 as libc::c_int as libc::c_double * fps
    {
        return;
    }
    if black_count > 0 as libc::c_int as libc::c_long {
        lastFrameCommCalculated = framenum_real as libc::c_long;
        onTheFlyBlackFrame = calloc(
            black_count as libc::c_ulong,
            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
        ) as *mut libc::c_int;
        if onTheFlyBlackFrame.is_null() {
            Debug(
                0 as libc::c_int,
                b"Could not allocate memory for onTheFlyBlackFrame\n\0" as *const u8
                    as *const libc::c_char as *mut libc::c_char,
            );
            exit(8 as libc::c_int);
        }
        i = 1 as libc::c_int;
        while (i as libc::c_long) < black_count {
            k = 0 as libc::c_int;
            if (*black.offset(i as isize)).cause as libc::c_long
                & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                != 0
                || (*black.offset(i as isize)).cause & (1 as libc::c_int) << 4 as libc::c_int != 0
                || (*black.offset(i as isize)).cause & (1 as libc::c_int) << 3 as libc::c_int != 0
            {
                j = max(
                    1 as libc::c_int,
                    ((*black.offset(i as isize)).frame as libc::c_double - shrink_logo * fps)
                        as libc::c_int,
                );
                while j < min(
                    framenum_real,
                    ((*black.offset(i as isize)).frame as libc::c_double + shrink_logo * fps)
                        as libc::c_int,
                ) {
                    if !(*frame.offset(j as isize)).logo_present {
                        k = 1 as libc::c_int;
                        Debug(
                            11 as libc::c_int,
                            b"[%d] Cutpoint %s without logo\n\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            (*black.offset(i as isize)).frame,
                            CauseString((*black.offset(i as isize)).cause),
                        );
                        break;
                    } else {
                        j += 1;
                    }
                }
                if k == 0 as libc::c_int
                    && (*black.offset(i as isize)).cause as libc::c_long
                        & (1 as libc::c_int as libc::c_long) << 18 as libc::c_int
                        != 0
                {
                    j = max(
                        1 as libc::c_int,
                        ((*black.offset(i as isize)).frame as libc::c_double
                            - volume_slip as libc::c_double * fps)
                            as libc::c_int,
                    );
                    while j < min(
                        framenum_real,
                        ((*black.offset(i as isize)).frame as libc::c_double
                            + volume_slip as libc::c_double * fps)
                            as libc::c_int,
                    ) {
                        if (*frame.offset(j as isize)).isblack as libc::c_int
                            & (1 as libc::c_int) << 4 as libc::c_int
                            != 0
                        {
                            Debug(
                                11 as libc::c_int,
                                b"[%d] Silence and dark\n\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char,
                                (*black.offset(i as isize)).frame,
                            );
                            k = 1 as libc::c_int;
                        }
                        j += 1;
                    }
                }
                if k != 0 {
                    *onTheFlyBlackFrame.offset(onTheFlyBlackCount as isize) =
                        (*black.offset(i as isize)).frame as libc::c_int;
                    onTheFlyBlackCount += 1;
                }
            }
            i += 1;
        }
        useLogo = commDetectMethod & 2 as libc::c_int != 0;
        if logo_block_count == -(1 as libc::c_int) as libc::c_long || !logoInfoAvailable {
            useLogo = 0 as libc::c_int != 0;
        }
        i = 0 as libc::c_int;
        while i < onTheFlyBlackCount {
            x = i + 1 as libc::c_int;
            while x < onTheFlyBlackCount {
                let mut gap_length: libc::c_int =
                    *onTheFlyBlackFrame.offset(x as isize) - *onTheFlyBlackFrame.offset(i as isize);
                if !((gap_length as libc::c_double) < min_commercial_size * fps) {
                    oldbreak = commercials > 0 as libc::c_int
                        && ((*onTheFlyBlackFrame.offset(i as isize) as libc::c_long
                            - c_end[(commercials - 1 as libc::c_int) as usize])
                            as libc::c_double)
                            < 10 as libc::c_int as libc::c_double * fps;
                    if gap_length as libc::c_double > max_commercialbreak * fps
                        || !oldbreak && gap_length as libc::c_double > max_commercial_size * fps
                        || oldbreak as libc::c_int != 0
                            && (*onTheFlyBlackFrame.offset(x as isize) as libc::c_long
                                - c_end[(commercials - 1 as libc::c_int) as usize])
                                as libc::c_double
                                > max_commercial_size * fps
                    {
                        break;
                    }
                    added = gap_length as libc::c_double / fps + div5_tolerance;
                    remainder = added
                        - (5 as libc::c_int * (added / 5.0f64) as libc::c_int) as libc::c_double;
                    if require_div5 as libc::c_int != 1 as libc::c_int
                        || remainder >= 0 as libc::c_int as libc::c_double
                            && remainder <= 2 as libc::c_int as libc::c_double * div5_tolerance
                    {
                        if oldbreak {
                            if CheckFramesForLogo(
                                *onTheFlyBlackFrame.offset((x - 1 as libc::c_int) as isize),
                                *onTheFlyBlackFrame.offset(x as isize),
                            ) as libc::c_int
                                != 0
                                && useLogo as libc::c_int != 0
                                && logo_present_modifier != 1 as libc::c_int as libc::c_double
                            {
                                c_end[(commercials - 1 as libc::c_int) as usize] =
                                    *onTheFlyBlackFrame.offset((x - 1 as libc::c_int) as isize)
                                        as libc::c_long;
                                Debug(
                                    10 as libc::c_int,
                                    b"Logo detected between frames %i and %i.  Setting commercial to %i to %i.\n\0"
                                        as *const u8 as *const libc::c_char as *mut libc::c_char,
                                    *onTheFlyBlackFrame.offset((x - 1 as libc::c_int) as isize),
                                    *onTheFlyBlackFrame.offset(x as isize),
                                    c_start[(commercials - 1 as libc::c_int) as usize],
                                    c_end[(commercials - 1 as libc::c_int) as usize],
                                );
                            } else if *onTheFlyBlackFrame.offset(x as isize) as libc::c_double
                                > c_end[(commercials - 1 as libc::c_int) as usize] as libc::c_double
                                    + fps
                            {
                                c_end[(commercials - 1 as libc::c_int) as usize] =
                                    *onTheFlyBlackFrame.offset(x as isize) as libc::c_long;
                                Debug(
                                    5 as libc::c_int,
                                    b"--start: %i, end: %i, len: %.2fs\t%.2fs\n\0" as *const u8
                                        as *const libc::c_char
                                        as *mut libc::c_char,
                                    *onTheFlyBlackFrame.offset(i as isize),
                                    *onTheFlyBlackFrame.offset(x as isize),
                                    (*onTheFlyBlackFrame.offset(x as isize)
                                        - *onTheFlyBlackFrame.offset(i as isize))
                                        as libc::c_double
                                        / fps,
                                    (c_end[(commercials - 1 as libc::c_int) as usize]
                                        - c_start[(commercials - 1 as libc::c_int) as usize])
                                        as libc::c_double
                                        / fps,
                                );
                            }
                        } else if CheckFramesForLogo(
                            *onTheFlyBlackFrame.offset(i as isize),
                            *onTheFlyBlackFrame.offset(x as isize),
                        ) as libc::c_int
                            != 0
                            && useLogo as libc::c_int != 0
                            && logo_present_modifier != 1 as libc::c_int as libc::c_double
                        {
                            Debug(
                                11 as libc::c_int,
                                b"Logo detected between frames %i and %i.  Skipping to next i.\n\0"
                                    as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                *onTheFlyBlackFrame.offset(i as isize),
                                *onTheFlyBlackFrame.offset(x as isize),
                            );
                            i = x - 1 as libc::c_int;
                            break;
                        } else {
                            Debug(
                                1 as libc::c_int,
                                b"\n  start: %i, end: %i, len: %.2fs\n\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                *onTheFlyBlackFrame.offset(i as isize),
                                *onTheFlyBlackFrame.offset(x as isize),
                                (*onTheFlyBlackFrame.offset(x as isize)
                                    - *onTheFlyBlackFrame.offset(i as isize))
                                    as libc::c_double
                                    / fps,
                            );
                            c_start[commercials as usize] =
                                *onTheFlyBlackFrame.offset(i as isize) as libc::c_long;
                            let fresh148 = commercials;
                            commercials = commercials + 1;
                            c_end[fresh148 as usize] =
                                *onTheFlyBlackFrame.offset(x as isize) as libc::c_long;
                            Debug(
                                1 as libc::c_int,
                                b"\n  start: %i, end: %i, len: %is\n\0" as *const u8
                                    as *const libc::c_char
                                    as *mut libc::c_char,
                                c_start[(commercials - 1 as libc::c_int) as usize],
                                c_end[(commercials - 1 as libc::c_int) as usize],
                                ((c_end[(commercials - 1 as libc::c_int) as usize]
                                    - c_start[(commercials - 1 as libc::c_int) as usize])
                                    as libc::c_double
                                    / fps) as libc::c_int,
                            );
                        }
                        i = x - 1 as libc::c_int;
                        x = onTheFlyBlackCount;
                    }
                }
                x += 1;
            }
            i += 1;
        }
        Debug(
            1 as libc::c_int,
            b"\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
        if output_default as libc::c_int != 0
            || output_edl as libc::c_int != 0
            || output_live as libc::c_int != 0
            || output_dvrmstb as libc::c_int != 0
        {
            if output_default {
                out_file = myfopen(
                    out_filename.as_mut_ptr(),
                    b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if out_file.is_null() {
                    usleep((50 as libc::c_long * 1000 as libc::c_long) as useconds_t);
                    out_file = myfopen(
                        out_filename.as_mut_ptr(),
                        b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    );
                    if out_file.is_null() {
                        Debug(
                            0 as libc::c_int,
                            b"ERROR writing to %s\n\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            out_filename.as_mut_ptr(),
                        );
                        exit(103 as libc::c_int);
                    }
                }
            }
            if output_edl {
                sprintf(
                    filename_0.as_mut_ptr(),
                    b"%s.edl\0" as *const u8 as *const libc::c_char,
                    outbasename.as_mut_ptr(),
                );
                edl_file = myfopen(
                    filename_0.as_mut_ptr(),
                    b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if edl_file.is_null() {
                    usleep((50 as libc::c_long * 1000 as libc::c_long) as useconds_t);
                    edl_file = myfopen(
                        filename_0.as_mut_ptr(),
                        b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    );
                    if edl_file.is_null() {
                        Debug(
                            0 as libc::c_int,
                            b"ERROR writing to %s\n\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            filename_0.as_mut_ptr(),
                        );
                        exit(103 as libc::c_int);
                    }
                }
            }
            if output_live {
                sprintf(
                    filename_0.as_mut_ptr(),
                    b"%s.live\0" as *const u8 as *const libc::c_char,
                    outbasename.as_mut_ptr(),
                );
                live_file = myfopen(
                    filename_0.as_mut_ptr(),
                    b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if live_file.is_null() {
                    usleep((50 as libc::c_long * 1000 as libc::c_long) as useconds_t);
                    live_file = myfopen(
                        filename_0.as_mut_ptr(),
                        b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    );
                    if live_file.is_null() {
                        Debug(
                            0 as libc::c_int,
                            b"ERROR writing to %s\n\0" as *const u8 as *const libc::c_char
                                as *mut libc::c_char,
                            filename_0.as_mut_ptr(),
                        );
                        exit(103 as libc::c_int);
                    }
                }
            }
            dvrmstb_file = 0 as *mut FILE;
            if output_dvrmstb {
                sprintf(
                    filename_0.as_mut_ptr(),
                    b"%s.xml\0" as *const u8 as *const libc::c_char,
                    outbasename.as_mut_ptr(),
                );
                dvrmstb_file = myfopen(
                    filename_0.as_mut_ptr(),
                    b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if !dvrmstb_file.is_null() {
                    fprintf(
                        dvrmstb_file,
                        b"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<root>\n\0" as *const u8
                            as *const libc::c_char,
                    );
                } else {
                    fprintf(
                        __stderrp,
                        b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                        strerror(*__error()),
                        filename_0.as_mut_ptr(),
                    );
                    exit(6 as libc::c_int);
                }
            }
            reffer_count = -(1 as libc::c_int);
            commercial_count = -(1 as libc::c_int);
            i = 0 as libc::c_int;
            while i < commercials {
                len = (c_end[i as usize] - c_start[i as usize]) as libc::c_int;
                if len as libc::c_double
                    >= min_commercialbreak as libc::c_int as libc::c_double * fps
                    && len as libc::c_double
                        <= max_commercialbreak as libc::c_int as libc::c_double * fps
                {
                    Debug(
                        2 as libc::c_int,
                        b"Output: %i - start: %i   end: %i\n\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char,
                        i,
                        c_start[i as usize],
                        c_end[i as usize],
                    );
                    commercial_count += 1;
                    if commercial_count >= 100000 as libc::c_int {
                        Debug(
                            0 as libc::c_int,
                            b"Insufficient memory to manage live_tv commercials\n\0" as *const u8
                                as *const libc::c_char
                                as *mut libc::c_char,
                        );
                        exit(8 as libc::c_int);
                    }
                    commercial[commercial_count as usize].start_frame =
                        (c_start[i as usize] as libc::c_double + padding as libc::c_double * fps
                            - remove_before as libc::c_double * fps)
                            as libc::c_long;
                    commercial[commercial_count as usize].end_frame =
                        (c_end[i as usize] as libc::c_double - padding as libc::c_double * fps
                            + remove_after as libc::c_double * fps)
                            as libc::c_long;
                    commercial[commercial_count as usize].length = (c_end[i as usize]
                        - (2 as libc::c_int * padding) as libc::c_long
                        - c_start[i as usize]
                        + remove_before as libc::c_long
                        + remove_after as libc::c_long)
                        as libc::c_double;
                    if output_live {
                        reffer_count += 1;
                        reffer[reffer_count as usize].start_frame =
                            commercial[reffer_count as usize].start_frame;
                        reffer[reffer_count as usize].end_frame =
                            commercial[reffer_count as usize].end_frame;
                    }
                    if !out_file.is_null() {
                        fprintf(
                            out_file,
                            b"%li\t%li\n\0" as *const u8 as *const libc::c_char,
                            c_start[i as usize] + padding as libc::c_long,
                            c_end[i as usize] - padding as libc::c_long,
                        );
                    }
                    if !edl_file.is_null() {
                        fprintf(
                            edl_file,
                            b"%.2f\t%.2f\t%d\n\0" as *const u8 as *const libc::c_char,
                            max(
                                (c_start[i as usize] + padding as libc::c_long
                                    - edl_offset as libc::c_long)
                                    as libc::c_int,
                                0 as libc::c_int,
                            ) as libc::c_double
                                / fps,
                            max(
                                (c_end[i as usize]
                                    - padding as libc::c_long
                                    - edl_offset as libc::c_long)
                                    as libc::c_int,
                                0 as libc::c_int,
                            ) as libc::c_double
                                / fps,
                            edl_skip_field,
                        );
                    }
                    if !live_file.is_null() {
                        fprintf(
                            live_file,
                            b"%.2f\t%.2f\t%d\n\0" as *const u8 as *const libc::c_char,
                            max(
                                (c_start[i as usize] + padding as libc::c_long
                                    - edl_offset as libc::c_long)
                                    as libc::c_int,
                                0 as libc::c_int,
                            ) as libc::c_double
                                / fps,
                            max(
                                (c_end[i as usize]
                                    - padding as libc::c_long
                                    - edl_offset as libc::c_long)
                                    as libc::c_int,
                                0 as libc::c_int,
                            ) as libc::c_double
                                / fps,
                            edl_skip_field,
                        );
                    }
                    if !dvrmstb_file.is_null() {
                        fprintf(
                            dvrmstb_file,
                            b"  <commercial start=\"%f\" end=\"%f\" />\n\0" as *const u8
                                as *const libc::c_char,
                            (c_start[i as usize] + padding as libc::c_long) as libc::c_double / fps,
                            (c_end[i as usize] - padding as libc::c_long) as libc::c_double / fps,
                        );
                    }
                }
                i += 1;
            }
            if !out_file.is_null() {
                fflush(out_file);
            }
            if !out_file.is_null() {
                fclose(out_file);
            }
            out_file = 0 as *mut FILE;
            if !edl_file.is_null() {
                fflush(edl_file);
            }
            if !edl_file.is_null() {
                fclose(edl_file);
            }
            edl_file = 0 as *mut FILE;
            if !live_file.is_null() {
                fflush(live_file);
            }
            if !live_file.is_null() {
                fclose(live_file);
            }
            live_file = 0 as *mut FILE;
            if !dvrmstb_file.is_null() {
                fprintf(
                    dvrmstb_file,
                    b" </root>\n\0" as *const u8 as *const libc::c_char,
                );
                fclose(dvrmstb_file);
                dvrmstb_file = 0 as *mut FILE;
            }
            if output_incommercial {
                sprintf(
                    filename_0.as_mut_ptr(),
                    b"%s.incommercial\0" as *const u8 as *const libc::c_char,
                    workbasename.as_mut_ptr(),
                );
                incommercial_file = myfopen(
                    filename_0.as_mut_ptr(),
                    b"w\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                );
                if incommercial_file.is_null() {
                    fprintf(
                        __stderrp,
                        b"%s - could not create file %s\n\0" as *const u8 as *const libc::c_char,
                        strerror(*__error()),
                        filename_0.as_mut_ptr(),
                    );
                } else {
                    if commercial[commercial_count as usize].end_frame
                        > (framenum_real - incommercial_frames) as libc::c_long
                    {
                        fprintf(
                            incommercial_file,
                            b"1\n\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        fprintf(
                            incommercial_file,
                            b"0\n\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    fclose(incommercial_file);
                }
            }
        }
        free(onTheFlyBlackFrame as *mut libc::c_void);
    }
}
#[no_mangle]
pub unsafe extern "C" fn get_fps() -> libc::c_double {
    return fps;
}
#[no_mangle]
pub unsafe extern "C" fn set_fps(
    mut fp: libc::c_double,
    mut dfps: libc::c_double,
    mut ticks: libc::c_int,
    mut rfps: libc::c_double,
    mut afps: libc::c_double,
) {
    let mut old_fps: libc::c_double = fps;
    static mut showed_fps: libc::c_int = 0 as libc::c_int;
    fps = 1.0f64 / fp;
    if fps != old_fps {
        showed_fps = 0.0f64 as libc::c_int;
    }
    if fabs(old_fps - fps) > 0.01f64 {
        Debug(
            1 as libc::c_int,
            b"Frame Rate set to %5.3f f/s\n\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            fps,
        );
        if ticks > 1 as libc::c_int {
            Debug(
                1 as libc::c_int,
                b"Ticks per frame = %d\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                ticks,
            );
        }
        if fabs(fps - dfps) > 0.1f64 {
            Debug(
                1 as libc::c_int,
                b"DFps[%d]= %5.3f f/s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                ticks,
                dfps,
            );
        }
        if fabs(fps - rfps) > 0.1f64 {
            Debug(
                1 as libc::c_int,
                b"RFps[%d]= %5.3f f/s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                ticks,
                rfps,
            );
        }
        if fabs(fps - afps) > 0.1f64 {
            Debug(
                1 as libc::c_int,
                b"AFps[%d]= %5.3f f/s\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                ticks,
                afps,
            );
        }
    }
    if fps < 9.0f64 || fps > 100 as libc::c_int as libc::c_double {
        fps = dfps;
        if showed_fps < 4 as libc::c_int {
            Debug(
                1 as libc::c_int,
                b"Frame Rate corrected to %5.3f f/s\n\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                fps,
            );
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn set_frame_volume(mut f: libc::c_uint, mut volume: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut act_framenum: libc::c_int = 0;
    if !initialized {
        return;
    }
    act_framenum = f as libc::c_int;
    if act_framenum > 0 as libc::c_int {
        if framearray {
            if act_framenum as libc::c_long <= frame_count {
                if (*frame.offset(act_framenum as isize)).brightness > 5 as libc::c_int {
                    (*frame.offset(act_framenum as isize)).volume = volume;
                }
                if volume >= 0 as libc::c_int {
                    volumeHistogram[(if volume / volumeScale < 255 as libc::c_int {
                        volume / volumeScale
                    } else {
                        255 as libc::c_int
                    }) as usize] += 1;
                    silenceHistogram[(if volume < 255 as libc::c_int {
                        volume
                    } else {
                        255 as libc::c_int
                    }) as usize] += 1;
                }
            }
        }
        i = (black_count - 1 as libc::c_int as libc::c_long) as libc::c_int;
        while i > 0 as libc::c_int
            && (*black.offset(i as isize)).frame > act_framenum as libc::c_long
        {
            i -= 1;
        }
        if i >= 0 as libc::c_int
            && (*black.offset(i as isize)).frame == act_framenum as libc::c_long
        {
            if (*black.offset(i as isize)).brightness > 0 as libc::c_int {
                (*black.offset(i as isize)).volume = volume;
            }
        }
    }
}
#[no_mangle]
pub static mut dump_audio_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub unsafe extern "C" fn dump_audio_start() {
    let mut temp: [libc::c_char; 256] = [0; 256];
    if !output_demux {
        return;
    }
    if dump_audio_file.is_null() {
        sprintf(
            temp.as_mut_ptr(),
            b"%s.mp2\0" as *const u8 as *const libc::c_char,
            workbasename.as_mut_ptr(),
        );
        dump_audio_file = myfopen(
            temp.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn dump_audio(mut start: *mut libc::c_char, mut end: *mut libc::c_char) {
    if !output_demux {
        return;
    }
    if dump_audio_file.is_null() {
        return;
    }
    fwrite(
        start as *const libc::c_void,
        end.offset_from(start) as libc::c_long as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        dump_audio_file,
    );
}
#[no_mangle]
pub static mut dump_video_file: *mut FILE = 0 as *const FILE as *mut FILE;
#[no_mangle]
pub unsafe extern "C" fn dump_video_start() {
    let mut temp: [libc::c_char; 256] = [0; 256];
    if !output_demux {
        return;
    }
    if dump_video_file.is_null() {
        sprintf(
            temp.as_mut_ptr(),
            b"%s.m2v\0" as *const u8 as *const libc::c_char,
            workbasename.as_mut_ptr(),
        );
        dump_video_file = myfopen(
            temp.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn dump_video(mut start: *mut libc::c_char, mut end: *mut libc::c_char) {
    if !output_demux {
        return;
    }
    if dump_video_file.is_null() {
        return;
    }
    fwrite(
        start as *const libc::c_void,
        end.offset_from(start) as libc::c_long as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        dump_video_file,
    );
}
#[no_mangle]
pub unsafe extern "C" fn close_dump() {
    if !output_demux {
        return;
    }
    if !dump_audio_file.is_null() {
        fclose(dump_audio_file);
    }
    dump_audio_file = 0 as *mut FILE;
    if !dump_video_file.is_null() {
        fclose(dump_video_file);
    }
    dump_video_file = 0 as *mut FILE;
}
#[no_mangle]
pub unsafe extern "C" fn dump_data(mut start: *mut libc::c_char, mut length: libc::c_int) {
    let mut temp: [libc::c_char; 2000] = [0; 2000];
    let mut i: libc::c_int = 0;
    if !output_data {
        return;
    }
    if length == 0 {
        return;
    }
    if dump_data_file.is_null() {
        sprintf(
            temp.as_mut_ptr(),
            b"%s.data\0" as *const u8 as *const libc::c_char,
            workbasename.as_mut_ptr(),
        );
        dump_data_file = myfopen(
            temp.as_mut_ptr(),
            b"wb\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        );
    }
    if length > 1900 as libc::c_int {
        return;
    }
    sprintf(
        temp.as_mut_ptr(),
        b"%7d:%4d\0" as *const u8 as *const libc::c_char,
        framenum_real,
        length,
    );
    i = 0 as libc::c_int;
    while i < length {
        temp[(i + 12 as libc::c_int) as usize] =
            (*start.offset(i as isize) as libc::c_int & 0xff as libc::c_int) as libc::c_char;
        i += 1;
    }
    fwrite(
        temp.as_mut_ptr() as *const libc::c_void,
        (length + 12 as libc::c_int) as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        dump_data_file,
    );
}
#[no_mangle]
pub unsafe extern "C" fn close_data() {
    if !dump_data_file.is_null() {
        fclose(dump_data_file);
        dump_data_file = 0 as *mut FILE;
    }
}
unsafe extern "C" fn run_static_initializers() {
    commDetectMethod = 1 as libc::c_int
        + 2 as libc::c_int
        + 8 as libc::c_int
        + 32 as libc::c_int
        + 64 as libc::c_int
        + (if 1 as libc::c_int != 0 {
            16 as libc::c_int
        } else {
            0 as libc::c_int
        });
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
